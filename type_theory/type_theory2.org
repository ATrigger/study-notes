#+TODO: X 0 1 2 | OK
#+TITLE: Tеория типов, часть вторая.

* Martin-Lof type system
** Источники
   http://www.cse.chalmers.se/~bengt/papers/hlcs.pdf1
** Вступление
   Напомним всем, чем отличается конструктивный интуиционизм от
   классического подхода. Наглядная иллюстрация: конструктивное
   доказательство очень близко к компьютерной программе. Пусть нужно
   доказать:
   (∀x∈A)(∃y∈B)P(x,y)                                        (1)
   С конструктивной точки зрения, вывод такого утверждения значит
   показать функцию f, такую что f:A → B, и она дает ровно нужный y для
   того чтобы удовлетворить P(x, y). Тогда если (1) выражает некоторую
   спецификацию, то конкретная f -- это программа, удовлетворяющая этой
   спецификации. Отсюда конструктивное доказательство может
   рассматриваться как программа, а процесс вычисления значения --
   нормализация доказательства.

   # Забавные (?) факты.
   Был такой ученый, значит, Brouwer Luitzen Egbertus Jan (Брауер
   Лёйтзен Эгберт Ян, фамилия -- первое) (1881-1966), голлндский
   математик. Ему удалось в некоторый момент показать, что в
   некоторых случаях невычислимость функций классической математики
   исходит не от аксиомы выбора, как тогда было принято считать, а от
   таких вещей, как правило исключенного третьего, доказательство от
   противного и закон снятия двойного отрицания. Брауера называют
   основоположником интуиционизма, хотя идею в основном развил
   Гейтинг, его ученик (Гейтинг сформулировал интуиционистскую логику
   в 1930).

   # Рассказать что-то про интенсиональность и экстенциональность
   # теории типов.
** Утверждения как множества
#   Первоначально идея воспринимать утверждения как множества была
#   выдвинута Карри, впоследствии того, что было замечено сходство
#   аксиом импликативного фрагмента интуиционистской логики первого
#   порядка:
#   A ⊃ B ⊃ A
#   (A ⊃ B ⊃ C) ⊃ (A ⊃ B) ⊃ A ⊃ C
#   С типами базовых комбинаторов K и S:
#   K ∈ A → B → A
#   S ∈ (A → B → C) → (A → B) → A → C
#   Тогда MP соответствует применению функций (комбинаторов).
   Утверждения можно сопоставлять множествам. Это можно увидеть,
   рассмотрев объяснения Гейтинга в терминах доказательств.
   Для импликации верно:
   Доказательство A ⊃ B -- функция, которая по каждому доказательству
   A выдает доказательство B.
   Нотация функции или метода тут примитивна в конструктивной
   математике, и функцию из A в B можно рассматривать как программу,
   которая, когда применена к элементу из A, выдает элемент B как
   выходной параметр. Давайте тогда сопоставим утверждение с набором
   его доказательств:
   * A ⊃ B сопоставимо с A → B, множество функций из A в B.
   Элементы из A → B имеют форму λx.b, где b ∈ B, и b зависит от x∈A.

   Гейтинг обяъсняет конъюнкцию как пару из двух доказательств. Тогда
   сопоставление с множеством очевидно:
   * A ∧ B сопоставимо с A × B, прямое произведение A и B.

   Для дизъюнкции -- она верна, если у нас есть доказательство одного
   из двух утверждений, причем с конкретным указанием, какого. Отсюда:
   * A ∨ B сопоставимо с A + B.
   Элементы A + B имеют форму inl(a) или inr(b), где a∈A, b∈B.

   ¬A ≡ A ⊃ ⊥.
   С таким определением, где ⊥ -- противоречие, утвеждение без
   доказательства, сопоставление таково:
   * ¬A сопоставимо с A → ∅.

   Чтобы отождествить утверждения с кванторами, нам нужны операции на
   наборах множеств. Пусть B[x ← a] -- выражение, полученное
   подстановкой a для всех свободных вхождений x в B. Тогда Гейтингово
   объяснение таково:
   Доказательство (∃x ∈ A)B состоит из построения элемента a множества A
   вместе с доказательством B[x ← a].
   Таким образом, доказательство -- пара. Сопоставимое с парой
   множество -- это непересекающееся объединение множеств,
   обозначающееся (∑x ∈ A)B. Элементы -- пары <a,b>, где a∈A, b∈B[x ← a].
   Тогда формальное сопоставление таково:
   * (∃x ∈ A)B сопоставляется с множеством (∑x ∈ A)B.

   И, наконец, квантор всеобщности:
   Доказательство (∀x ∈ A)B -- функция (метод/программа), которая
   каждому элементу a из множества A сопоставляет доказательство
   B[x ← a].
   Множество, которое соответствует квантору всеобщности -- прямое
   произведение семейства множеств, обозначается (Πx ∈ A)B. Элементы
   этого множества -- функции, которые, в применении к элементу a ∈ A
   возвращают элемент B[x ← a]. Отсюда, формально:
   * (∀x ∈ A)B сопоставляется с множеством (Πx ∈ A)B.
   Элементы (Πx ∈ A)B находятся в форме λx.b, где b ∈ B, причем как b
   так и B зависят от x ∈ A. Отметим, что если B не зависит от x, то
   (Πx ∈ A)B есть то же самое, что и A → B, отсюда можно обойтись без
   →, если есть прямое произведение семейства множеств. В этом же
   смысле, (∑x ∈ A)B есть ничто иное, как A × B, когда B не зависит от
   x.

   Все эти нотации -- сахар, который будет раскрыт позже.
** Типы, их равенство, равенство объектов
   Базовая нотация в MLTT -- нотация типа. Объясним, что такое тип, и
   что значит для двух типов быть идентичными. Мы проводим суждение
   A -- тип, и формально записываем это как "A type", когда знаем
   условия для того, чтобы утверждать "некий объект имеет тип A" и
   когда знаем условия для того, чтобы утверждать, что два объекта типа A
   идентичны. Последнее условие должно определять отношение
   эквивалентности.
   Первое есть удовлетворение следующего условия:
   a -- объект типа A.
   Что формально записывается:
   a ∈ A.
   Второе -- удовлетворение такого условия:
   a и b -- идентичные объекты типа A.
   Что формально записывается
   a = b ∈ A

   A -- тип, если знаем условия для того, чтобы утверждать:
   1. a ∈ A
   2. a = b ∈ A

   Равенство на типах выполняется, когда объект одного типа является
   объектом и другого типа и когда два идентичных объекта одного типа
   являются идентичными для другого.
   A и B идентичны.
   A = B.
   Равенство на объектах симметрично, рефлексивно и транзитивно.
   * a ∈ A                ⇒⇒ a = a ∈ A
   * a = b ∈ A            ⇒⇒ b = a ∈ A
   * a = b ∈ A, b = c ∈ A ⇒⇒ a = c ∈ A
   Равенство на типах тоже есть отношение эквивалентности.
   * A type       ⇒⇒ A = A
   * A = B        ⇒⇒ B = A
   * A = B, B = C ⇒⇒ A = C
   Кроме того, равенство на типах:
   * a ∈ A, A = B     ⇒⇒ a ∈ B
   * a = b ∈ A, A = B ⇒⇒ a = b ∈ B
** Гипотетические суждения, контекст
   Гипотетическое суждение -- суждение, сделанное в контексте:
   x₁ ∈ A₁, x₂ ∈ A₂, ... xₙ ∈ Aₙ
   Где A₁ тип, A₂ тип в контексте x₁ ∈ A₁, ... Aₙ тип в контексте
   всех перед ним.

   Пусть C -- тип, не зависящий ни от каких посылок. Тогда A -- тип,
   когда x ∈ C:
   A type [x ∈ C]
   То есть для любого c ∈ C A[x ← c] есть тип.
   Тогда A будет называться семеством типов над (over) C.

   * A = B [x ∈ C] значит, что A[x ← c], B[x ← c] одинаковые типы для
     любого c ∈ C.
   * a ∈ A [x ∈ C] значит, что a -- объект типа A при x ∈ C, то есть
     мы уже знаем, что a[x ← c] есть объект типа A[x ← c] для любого
     c ∈ C.

   Пусть x₁∈A, x₂∈A₂,...xₙ∈Aₙ -- контекст длины n-1.
   Тогда верно:
   A₁ type
   A₁ type [x₁ ∈ A₁]
   ...
   Aₙ type [x₁ ∈ A₁, x₂ ∈ A₂, ... x{n-1} ∈ A{n-1}]

   Допустим мы хотим знать
   A type [x₁ ∈ A₁, ... xₙ ∈ Aₙ]
   Это значит (формально), что мы хотим знать следующее:
   A[x₁ ← a] type [x₂ ∈ A₂ [x₁ ← a],... xₙ ∈ Aₙ [xₙ ← a]]
   Причем такое утврерждение должно быть верно в пустом контексте.
   Тогда если к томе же a = b ∈ A, также верно:
   A[x₁ ← a] = A[x₁ ← b] [x₂ ∈ A₂ [x₁ ← a],... xₙ ∈ Aₙ [xₙ ← a]]
   Формально это выражается так:
   * A type [x₁ ∈ A₁...xₙ ∈ Aₙ], a ∈ A₁     ⇒⇒
     A[x₁ ← a] type [x₂ ∈ A₂[x₁ ← a],.. xₙ ∈ Aₙ[x₁ ← a]]
   * A type [x₁ ∈ A₁...xₙ ∈ Aₙ], a = b ∈ A₁ ⇒⇒
     A[x₁ ← a] = A[x₁ ← b] [x₂ ∈ A₂[x₁ ← a],.. xₙ ∈ Aₙ[x₁ ← a]]

   Подстановка в равных типах:
   Пусть A, B -- типы в контексте [x₁ ∈ A₁...xₙ ∈ Aₙ].
   * A = B [x₁ ∈ A₁...xₙ ∈ Aₙ], a ∈ A₁ ⇒⇒
     A[x₁ ← a] = B[x₁ ← a] [x₂ ∈ A₂[xᵢ ← a],...xₙ ∈ Aₙ[xᵢ ← a]]

   Подстановка в объектах:
   Пусть A -- тип в контексте [x₁ ∈ A₁...xₙ ∈ Aₙ].
   * a ∈ A [x₁ ∈ A₁...xₙ ∈ Aₙ], a ∈ A₁ ⇒⇒
     a[x₁ ← a] ∈ A[x₁ ← a] [x₂ ∈ A₂[xᵢ ← a],...xₙ ∈ Aₙ[xᵢ ← a]]

   Подстановка в равных объектах:
   Пусть c = d ∈ A -- тип в контексте [x₁ ∈ A₁...xₙ ∈ Aₙ].
   * c = d ∈ A [x₁ ∈ A₁...xₙ ∈ Aₙ], a ∈ A₁ ⇒⇒
     c[x₁ ← a] = d[x₁ ← a] ∈ A[x₁ ← a]
                            [x₂ ∈ A₂[xᵢ ← a],...xₙ ∈ Aₙ[xᵢ ← a]]

   Предположение:
   A₁ type
   A₂ type [x₁ ∈ A₁]
   ...
   Aₙ type [x₁ ∈ A₁ ... до n-1]
   A type [x₁ ∈ A₁ ... xₙ ∈ Aₙ]
   ⇒⇒
   x ∈ A[x₁ ∈ A₁...xₙ ∈ Aₙ, x ∈ A]

** Типы-функции
   Пусть A -- тип, B -- семейство типов над A, тогда (x ∈ A)B -- тип
   функции.
   Быть объектом c типа (x ∈ A)B значит знать, что когда мы применяем
   его к a типа A, то получаем c(a) в B[x ← a]. И что мы получаем
   одинаковые объекты в B[x ← a], когда применяем к a = b ∈ A.
   c = d ∈ (x ∈ A)B значит, что для любого a ∈ A c(a) и b(a) есть
   одинаковые элементы типа B[x ← a].

   Функциональный тип.
   * A type, B type [x ∈ A] ⇒⇒ (x ∈ A)B type
   Тип равенства функций.
   * A = A', B = B' [x ∈ A] ⇒⇒ (x ∈ A)B = (x ∈ A')B'

   Синтаксический сахар:
   * (A)B есть (x∈A)B, когда B не зависит от x.
   * (x ∈ A; y ∈ B)C есть (x ∈ A)(y ∈ B)C
   * (x,y ∈ A)B есть (x ∈ A; y ∈ A)C
   * c(a₁,a₂,...aₙ) есть c(a₁)(a₂)...(aₙ)

   Правила для аппликации:
   * c ∈ (x ∈ A)B, a ∈ A     ⇒⇒ c(a) ∈ B[x ← a]
   * c ∈ (x ∈ A)B, a = b ∈ A ⇒⇒ c(a) = c(b) ∈ B[x ← a]

   Правила, показывающие равенство функций:
   Аппликация (тут переходим от функций к применению):
   * c = d ∈ (x ∈ A)B, a ∈ A ⇒⇒ c(a) = d(a) ∈ B[x ← a]
   Экзистенциональность (тут переходим от применений к чистым):
   * c ∈ (x ∈ A)B, d ∈ (x ∈ A)B, c(x) = d(x) ∈ B[x ∈ A] ⇒⇒
     c = d ∈ (x ∈ A)B,
     тут x не входит свободно ни в c ни в d.

   Абстракция:
   * b ∈ B[x ∈ A] ⇒⇒ ([x]b) ∈ (x ∈ A)B
   Сахар:
   * [x₁,...xₙ]b = [x₁][x₂]..[xₙ]b
   β-конверсия:
   * a ∈ A, b ∈ B[x ∈ A] ⇒⇒ ([x]b)(a) = b[x ← a] ∈ B[x ← a]

   Два доказываемых правила:
   # Заставить кого-нибудь доказать
   η-конверсия:
   * c ∈ (x ∈ A)B ⇒⇒ ([x]c)(x) = c ∈ (x ∈ A)B, x не свободно в c
     Какой-то очевидный переход (лол)
     c ∈ (x ∈ A)B ⇒⇒ x ∈ A, c ∈ B[x ∈ A]
     β-конверсия:
     x ∈ A, c ∈ B[x ∈ A] ⇒⇒ ([x]c)(x) = c[x ← x] ∈ B[x ← c]
   ξ-правило
   * b = d ∈ B[x ∈ A] ⇒⇒ [x]b = [x]d ∈ (x ∈ A)B
** Тип Set
   Set -- тип, в котором есть объекты.
   Сразу сахар: A -- сет (set) значит, что A является элементом
   (объектом) в Set.
   1. Чтобы знать, что A -- сет необходимо знать, как определять
      канонические элементы A и когда они одинаковы.
      Канонический элемент -- это элемент в форме некоторого
      конструктора, вроде zero или succ.
   2. Два сета одинаковые (два элемента одинаковы и являются объектами
      в Set), если элемент одного сета есть элементом и другого сета, и
      если два элемента равны и принадлежат первому сету, то и
      второму.

   Формально:
   * Set type
   * A ∈ Set ⇒⇒ El(A) type
   # В оригинале так: A : Set ⇒⇒ El(A) type, что бы это ни значило.

   El -- некий оператор, отображающий элементы Set (сеты) в
   соответствующие им типы (поскольку, формально, элементы Set есть не
   типы, а объекты). На практике не пишется нигде, потому что и так
   понятно (так считают авторы повсеместно).
** Определения
   Мы умеем делать всякие константы! Давайте различать примитивные и
   определяемые константы. Значение примитивной константы есть сама
   константа. Константа имеет только тип, не определение. Значение она
   получает из семантики теории.
   Примеры примитивных констант: ℕ, succ, 0.
     N    ∈ Set
     succ ∈ N → N
     0    ∈ N

   Определяемые константы определяются в терминах других объектов. Они
   бывают эксплицитно или имплицитно определенными.
   Эксплицитно определенная константа -- такое c, что:
     c = a ∈ A
   Примеры эксплицитно определенных констант:
     1  = succ(0) ∈ N
     In = [x]x ∈ N → N
     # Напоминание: (B)A -- сахар для: (x ∈ B)A, A не зависит от x
     I  = [A,x]x ∈ (A ∈ Set; A)A
   Имплицитно определенная константа -- это предоставление некоротых
   определяющих слов которые она имеет, когда мы применяем ее к
   аргументам.
   Пользуемся паттерн-матчингом и рекурсией. Примеры:
     +            ∈ ℕ → ℕ → ℕ
     +(0,y)       = y
     +(succ(x),y) = succ( +(x,y))
   Вот примитивная рекурсия:
     natrec                 ∈ ℕ → (ℕ → ℕ → ℕ) → ℕ → ℕ
     natrec (d, e, 0)       = d
     natrec (d, e, succ(a)) = e(a, natrec(d, e, a))
** Пропозициональная логика
   Теория -- набор типизаций:
     c₁ ∈ A₁ ... cₙ ∈ Aₙ
   Где c₁...cₙ -- новые примитивные константы. И еще список определений
   из определяемых констант:
     d₁ = e₁ ∈ B₁ ... dₘ = eₘ ∈ Aₘ

   Базовые типы в MLTT -- Set и все типы элементов в конкретных сетах,
   которые мы представим позже.
   Давайте определим всякие множественные связки:

*** Конъюнкция
    Введем примитивную константу:
    * & ∈ (Set; Set)Set
    &-formation:
    * A ∈ Set, B ∈ Set ⇒⇒ A&B ∈ Set
    Доказательством конъюнкции будет следующяя примитивная константа:
    * &I ∈ (A,B ∈ Set; A; B) A&B
    Это объявление -- индуктивное определение сета &(A,B), такое что
    все элементы сета &(A,B) равны элементу в форме &I(A,B,a,b),
    где A и B -- сеты и a ∈ A, b ∈ B.
    Доказательство в такой синтаксической форме называется каноническим.

    По правилу функциональной аппликации (применному 4 раза), получаем:
    # Оно, кстати, выглядит так:
    # c ∈ (x ∈ A)B, a ∈ B  ⇒⇒ c(a) ∈ B[x ← a]
    &-introduction:
    * A ∈ Set, B ∈ Set, a ∈ A, b ∈ A ⇒⇒ &I(A,B,a,b) ∈ A&B
      Доказательство:
      &I ∈ (A ∈ Set)(B ∈ Set; A; B)A&B,  A ∈ Set ⇒⇒
      &I(A) ∈ (B ∈ Set; A; B)A&B      ,  B ∈ Set ⇒⇒
      &I(A,B) ∈ (A; B)A&B             ,  a ∈ A   ⇒⇒
      &I(A,B,a) ∈ (B)A&B              ,  b ∈ B   ⇒⇒
      &I(A,B,a,b) ∈ A&B

    Чтобы получить два правила, раскрывающих конъюнкцию, введем две
    определенные константы с помощью равенств:
    # Напоминаем, что синтаксис работает в виде (a = b) ∈ C
    * &E1(A,B,&I(A,B,a,b)) = a ∈ A
    * &E2(A,B,&I(A,B,a,b)) = b ∈ B

    Проверим, что типизации констант корректны.
    * Если A ∈ Set, B ∈ Set, p ∈ A&B, то &E1(A,B,p) ∈ A.
      p ∈ A&B, тогда p равно элементу формы &I(A,B,a,b), где a ∈ A,
      b ∈ B -- это свойство канонического доказательства.
      Тогда:
      &E1(A,B,p) = &E1(A,B,&I(A,B,a,b)) = {раскрыли по опр &E1} = a ∈ A.
    * Второе аналогично

    Из последнего семантического доказательства типизаций получаем
    формальные правила:
    &-elimination 1 and 2:
    * A ∈ Set, B ∈ Set, c ∈ A & B ⇒⇒ &E1(A,B,c) ∈ A
    * A ∈ Set, B ∈ Set, c ∈ A & B ⇒⇒ &E2(A,B,c) ∈ B
*** Импликация
    Примитивная константа ⊃ вводится декларацией:
    * ⊃ ∈ (Set;Set)Set
    ⊃-formation (доказывается применением функциональной аппликации):
    * A ∈ Set, B ∈ Set ⇒ A ⊃ B ∈ Set
    Каноническое доказательство:
    * ⊃I ∈ (A, B ∈ Set, (A)B)A ⊃ B
    ⊃-introduction (доказывается):
    * A ∈ Set, B ∈ Set, b(x) ∈ B[x ∈ A] ⇒⇒ ⊃I(A,B,b) ∈ A ⊃ B
      Доказательство
      ⊃I ∈ (A ∈ Set)(B ∈ Set; (A)B)A ⊃ B, A ∈ Set      ⇒⇒
      ⊃I(A) ∈ (B ∈ Set; (A)B)A ⊃ B,       B ∈ Set      ⇒⇒
      Тут нужно дополнительно привести b(x) к виду b, это можно
      сделать с помощью правила абстракции (наверное).
      ⊃I(A,B) ∈ ((A)B)A ⊃ B,              b ∈ (x ∈ A)B ⇒⇒
      ⊃I(A,B,b) ∈ A ⊃ B
    Как и в конъюнкции, introduction помогает из трех элементов
    получить каноническое доказательство связки.

    Чтобы получить Modus Ponens, то есть ⊃-elimination, нам нужна
    определенная константа, заданная с помощью равенства:
    * ⊃E(A,B,⊃I(A,B,b,a)) = b(a) ∈ B
    Имеющая тип:
    * ⊃E ∈ (A,B ∈ Set; A ⊃ B; A)B
    ⊃-elimination aka Modus Ponens (из функциональной аппликации и
    типизации ⊃E):
    * A ∈ Set, B ∈ Set, b ∈ A ⊃ B, a ∈ A ⇒⇒ ⊃E(A,B,b,a) ∈ B
      Доказательство:
      ⊃E ∈ (A,B ∈ Set; A ⊃ B; A)B,  A ∈ Set   ⇒⇒
      ⊃E(A) ∈ (B ∈ Set; A ⊃ B; A)B, B ∈ Set   ⇒⇒
      ⊃E(A,B) ∈ (A ⊃ B; A)B,        b ∈ A ⊃ B ⇒⇒
      ⊃E(A,B,b) ∈ (A)B,             a ∈ A     ⇒⇒
      ⊃E(A,B,b,a) ∈ B
** Теория сетов
   Вкратце.
   Давайте определять сеты с натуральными числами, листами, функциями
   и прочим.

   Как определить новый сет:
   1. Ввести примитивную константу для сета.
   2. Ввести примитивные константы для конструкторов.
   3. Вывести formation rule -- типизационное правило для
      константы, обозначающей сет.
   4. Вывести introduction rules -- типизационные правила для
      конструкторов.
   5. Определить селектор -- имплицитно определенную константу (то
      есть можно рекурсию, паттерн-матчинг), выражающую сущность,
      индуктивный принцип сета.
      Equality rules -- равенства, задающие селектор(ы).
   6. Вывести elimination rules для селектора.

   Поехали.
*** Boolean set
    1. Bool ∈ Set
    2. true ∈ Bool
       false ∈ Bool
    3. formation rule не нужен, так как Bool атомарен.
    4. introduction rule не нужен, так как конструкторы не сложные.
    5. Селектор (equality rules):
       if(C,true,a,b)  = a
       if(C,false,a,b) = b

       В equality rules опущены типы в силу очевидности.
       Сахар: a = b пишется вместо a = b ∈ A когда A очевидно.

       Должно быть понятно, какой тип у if:
       if ∈ (C ∈ (Bool)Set; b ∈ Bool; C(true); C(false))C(b)
    6. elimination rules выводятся из функциональной аппликации
       elimination-2 (1 -- аналогично):
       * C ∈ (Bool)Set, c ∈ C(true), d ∈ C(false) ⇒⇒
         if(C, false, c, d) ∈ C(false)
         Доказательство:
         if ∈ (C ∈ (Bool)Set; b ∈ Bool; C(true); C(false))C(b); C ∈
         (Bool)Set ⇒⇒
         if(C) ∈ (b ∈ Bool; C(true); C(false))C(b), false ∈ Bool ⇒⇒
         if(C, false) ∈ (C(true); C(false))C(false), c ∈ C(true) ⇒⇒
         if(C, false, c) ∈ (C(false))C(false),      d ∈ C(false) ⇒⇒
         if(C, false, c, d) ∈ C(false)
*** Empty set
    1. {} ∈ Set
    2. Конструкторов нет
    3. ∅
    4. ∅
    5. case ∈ (C ∈ ({})Set; a ∈ {})C(a)
       Соответствует утверждению абсурдности
       ⊥ true, C prop ⇒⇒ C true
    6. ∅
*** Natural numbers
    1. ℕ ∈ Set
    2. 0 ∈ ℕ
       succ ∈ (n ∈ ℕ)ℕ
    3. Не нужен
    4. Можно вывести succ-introduction rule:
       a ∈ ℕ ⇒⇒ succ(a) ∈ ℕ
       Доказательство очевидно через аппликацию.
    5. natrec ∈ (C ∈ (ℕ)Set;
                 d ∈ C(0);
                 e ∈ (x ∈ ℕ, y ∈ C(x))C(succ(x));
                 n ∈ ℕ) C(n)

       natrec(C,d,e,0) = d
       natrec(C,d,e,succ(m)) = e(n,natrec(C,d,e,m))

       Ввести еще можно plus,mult:
       plus ∈ (ℕ,ℕ)ℕ
       mult ∈ (ℕ,ℕ)ℕ
       plus(m,n) = natrec([x]ℕ, n, [x,y]succ(y), m)
       mult(m,n) = natrec([x]ℕ, 0, [x,y]plus(y,n), m)
    6. Выводится
*** Set of functions (Π)
    (x ∈ A)B -- это тип. Мы хотим коррелирующий сет. Пусть есть сет A
    и семейство сетов B над A (A -- сет, для каждого a ∈ A существует
    B(a) -- тоже сет), тогда Π(A,B) -- прямое произведение A и B.
    Π(A,B) хранит в себе функции, которые отображают элементы a ∈ A в
    какие-то элементы z ∈ B(a).
    1. Π ∈ (A ∈ Set; B ∈ (x ∈ A)Set) Set
    2. λ ∈ (A ∈ Set; B ∈ (x ∈ A)Set; f ∈ (x ∈ A)B) Π(A,B)
       Тут f отображает из элемента x в сет, являющийся
       подсемейством B.

       Тут я придумал пример!
       λ(ℕ, [x](if x > 1 then ℕ else Bool), foo) ∈ Π(ℕ, {ℕ, Bool})
       где foo(0) = false
           foo(1) = true
           foo(n) = n - 2
    3. A ∈ Set, B(x) ∈ Set[x ∈ A] ⇒⇒ Π(A,B) ∈ Set
    4. A ∈ Set, B(x) ∈ Set[x ∈ A], f ∈ B(x)[x ∈ A] ⇒⇒
       λ(A,B,f) ∈ Π(A,B)
       Заметим, что эти "функции" гораздо более общие, чем обычные --
       Π(A,B) -- прямое произведение семейств сетов.
    5. apply ∈ (A ∈ Set; B ∈ (x ∈ A)Set; g ∈ Π(A,B); a ∈ A)B(a)
       apply(A,B,λ(A,B,f),a) = f(a)

       Заметим также, что в отождествлении с выражениями, Π(A,B)
       соответствует (∀x ∈ A)B(x).

       Пусть семейство функций B над A никак не меняется в зависимости
       от элементов x ∈ A. Тогда прямое произведение -- сет функций.
       → ∈ (A,B ∈ Set)Set
       → = [A,B]Π(A, [x]B)

       ¬ ∈ (A ∈ Set)Set
       ¬(A) = A → {}
**** Бонус
     Давайте докажем A ⊃ ¬¬A.
     Что эквивалентно следующей задаче:
     Найдем хоть какой-нибудь элемент в сете:
     A → (¬(¬A)) ≡ A → ((A → {}) → {})

     !!!
     Хинт: мы пользуемся тут λ для →, упрощенной версией.
     такой:
     λ' ∈ (A, B ∈ Set; f ∈ (x ∈ A)B)(A → B)
     Это работает, потому что:
     A ∈ Set, B ∈ Set.
     λ(A, [x]B, [x]f([x]B(x))) ∈ Π(A, [x]B)
     λ(A, [x]B, [x]f([x]B(x))) ∈ A → B

     Аналогично для apply:
     apply' ∈ (A, B ∈ Set; g ∈ A → B, a ∈ A) B(a)
     Потому что:
     A, B ∈ Set,
     apply(A, [x]B, λ'(A, B, f), a) = f(a) ∈ B(a)

     Пусть верно:
     A → ¬¬A
     Давайте докажем A → ((A → {}) → {}).
     Для этого нужно доказать:
     λ'(A, ((A → {}) → {}), foo).
     При этом хотим foo ∈ (x ∈ A)((A → {}) → {}).
     Пусть foo выглядит как [x]bar, тогда bar имеет стрелочный тип,
     отсюда:
     foo := [x]λ(A → {}, {}, foo2).
     Ага, ну то есть foo2 должна быть типа (y ∈ A → {})({}).
     Опять-таки, представим foo2 как [y]bar2.

     Что имеем (последовательно):
     λ'(A, (A → {}) → {}, [x]bar),
     bar ∈ (A → {}) → {}
     λ'(A, (A → {}) → {}, [x](λ'(A → {}, {}, [y]bar2)),
     bar2 ∈ {}
     bar2 = apply'(A, A → {}, y, x) (это тут мы применяем y ∈ A → {} к
     x ∈ A, то есть получаем элемент z ∈ {})

     Вот вам корректно типизируемое выражение нужного типа:
     λ'(A, (A → {}) → {},
         [x](λ'(A → {}, {},
             [y](apply(A, A → {}, y, x)))).

     Ну и все, типы сошлись, A → ¬¬A доказывается.
*** Disjoint unions (+)
    Это сет кусков слева или кусков справа -- inl или inr.
    1. + ∈ (A, B ∈ Set) Set
    2. inl ∈ (A,B ∈ Set; A) A + B
       inr ∈ (A,B ∈ Set; B) A + B
    3. -
    4. -
    5. when ∈ (A, B ∈ Set;
               C ∈ (A + B) Set;
               e ∈ (x ∈ A) C(inl(A,B,x));
               f ∈ (y ∈ B) C(inr(A,B,y));
               p ∈ A + B)
               C(p)
       when(A, B, C, e, f, inl(A,B,a)) = e(a)
       when(A, B, C, e, f, inr(A,B,b)) = f(b)

       Эта связка соответствует логическому ∨.
*** Disjoint union of a family of sets (Σ)
    Это сет пар.
    1. Σ ∈ (A ∈ Set; B ∈ (A)Set) Set
    2. pair ∈ (A ∈ Set; B ∈ (A)Set; a ∈ A; B(a)) Σ(A,B)
    3. Selector:
       split ∈ (A ∈ Set;
                B ∈ (A) Set;
                C ∈ (Σ(A,B)) Set;
                d ∈ (a ∈ A; b ∈ B(a)) C(pair(A,B,a,b));
                p ∈ Σ(A,B))
                C(p)
       split(A,B,C,d,pair(A,B,a,b)) = d(a,b)

       fst ∈ (A ∈ Set, B ∈ (A)Set; p ∈ Σ(A,B)) A
       fst(A,B,p) = split(A,B, [x]A, [x,y]x, p)

       snd ∈ (A ∈ Set, B ∈ (A)Set; p ∈ Σ(A,B)) B(fst(A, B, p))
       snd(A,B,p) = split(A,B,[x]B(fst(A,B,p)), [x,y]y, p)
** W-типы
   http://mazzo.li/epilogue/index.html?p=324.html
   Мы выбираем некоторый сет и строим функцию из его элементов в
   какой-то другой сет. Это очень похоже на Π, но конструктор другой.
   * W ∈ (S ∈ Set; P ∈ (x ∈ S)Set) Set

   Конструктор:
   * sup ∈ (S ∈ Set;
            P ∈ (x ∈ S)Set;
            f ∈ (y ∈ P) W(S, P))
            W(S, P)

     S -- сет.
     P -- семейство сетов, порождаемое каждым элементом из S.
     f -- функция, сопоставляющая каждому элементу семейства P другой
     узел W.

   # {a → b; c → d} -- это анонимный паттерн матчинг!
   ψ -- функция, которая имеет 0 аргументов, соответствует {}.

   Вот вам натуральные числа:
   * mapping = {true → Unit; false → {}} ∈ (x ∈ Bool)Set
   * Nat = W Bool mapping ∈ Set
   * zero = sup(false, mapping, ψ) ∈ Nat
   * suc (n: Nat) = sup(true, mapping, {_ → n})

   И еще дерево:
   * mapping = {true → Bool; false → {}} ∈ (x ∈ Bool)Set
   * Tree = W Bool mapping ∈ Set
   * leaf = sup(false, mapping, ψ) ∈ Tree
   * node(L,R ∈ Tree) = sup(true, mapping, {true → L, false → R}) ∈ Tree
* Constructive math & programming
** Мотивация
   Очень хочется высокоуровневое программирование.
   Для этого нужен вагон логики.
   Заметим высокое сходство математических сущностей и сущностей из
   программирования (тысячи их):
   |--------------------------------+-----------------------|
   | Programming                    | Mathematics           |
   |--------------------------------+-----------------------|
   | программа, процедура, алгоритм | функция               |
   | input                          | аргументы             |
   | output                         | значение              |
   | присваивание                   | равенство             |
   | S; P                           | композиция функций    |
   | if then else                   | определения по кейсам |
   | integer, real, boolean         | ℤ, ℝ, {0,1}           |
   |--------------------------------+-----------------------|
   Давайте тогда опишем систему.
