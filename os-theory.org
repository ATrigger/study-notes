#+TODO: X 0 1 2 | 3
#+TITLE: Tickets for exam on operating systems lectures course given by Yan Malakhovski, 4th term, 2015

* Legend
  X -- нифига не написано и непонятно, где брать
  0 -- нифига не написано
  1 -- что-то написано, но не дописано
  2 -- написано, но возможно, что что-то серьезно упущено
  3 -- все хорошо.
* Sources
  Тут только самые важные источники. Всякие статьи, которые по мере необходимости встречаются в тексте, встречаются только там.
  1. Raw notes by volhovm
  2. OS course plan
     http://rain.ifmo.ru/~trojan/linux/year2009/
  3. Yet another plan
     http://rain.ifmo.ru/~trojan/linux/year2007/
  4. Prev. year googledoc
     https://docs.google.com/spreadsheets/d/1CoPjN7shou3m3kAQdsRHY1HxQYyKho5f7Qn1KeL9n-U/edit#gid=0
  5. Malakhovski's notes
     https://github.com/oxij/unix-notes-ru/blob/master/compiled/main.pdf
  6. Wikipedia ofc
* Ticket 1
** RAM, SRAM, DRAM
   RAM (random-access memory) - это оперативная память.
   От постоянной памяти ее отличает:
   1) скорость работы
   2) потеря данных в отсутствие питания
   3) да вообще все по-другому!

   SRAM (static random-access memory) - статическая память.
   CMOS-ячейка SRAM основана на защелке: [[http://2.bp.blogspot.com/-dCCrTGB-c6U/T1zaY5TG1oI/AAAAAAAAAu8/MutoYbjglvs/s1600/SRAM.gif][схема]]
   *Read-операция*: мы даем на WL напряжение, сигнал уходит с BL и ¬BL.
   *Write-операция*: мы даем на WL напряжение и в BL тоже даем сигнал, он запоминается.

   Pros:
   + Быстрая
   + Не надо ничего перезаписывать
   Cons:
   - Защелки жрут электричество все время
   - Схема ячейки сложная, делать дороже
   - Ячейка занимает много площади

   DRAM (dynamic random-access memory) - динамическая память.
   CMOS-ячейка DRAM основана на конденсаторе: [[https://www.cs.auckland.ac.nz/~jmor159/363/html/fig/dram_cell.gif][схема]], [[https://upload.wikimedia.org/wikipedia/commons/3/3d/Square_array_of_mosfet_cells_read.png][схема банка]]
   *Read-операция*: мы даем на WL напряжение, конденсаторы разряжаются, сигнал уходит,
   и теперь его надо перезаписать обратно.
   *Write-операция*: даем на WL и BLs напряжения, те конденсаторы, на которых 1, заряжаются,
   а те, на которых 0 - разряжаются.
   *Замечание*: так как конденсаторы разряжаются сами по себе, периодически надо их перезаписывать
   (memory refresh)

   Pros:
   + Дешевая
   + Ячейки маленькие, можно много понапихать
   + Жрет энергию только во время read/write и refresh
   Cons:
   - Медленная (конденсаторы разряжаются не мгновенно)
   - Refresh-и тоже не прибавляют отзывчивости

** Структурно-операционная схема обычной планки памяти (DDR)
   Схема одного банка: [[https://upload.wikimedia.org/wikipedia/commons/3/3d/Square_array_of_mosfet_cells_read.png][схема банка]]
   Банки лежат на планочке рядом. Верхняя часть адреса ячейки отвечает за номер банка

   DDR (double-data rate) - хитрость, позволяющая передавать 2 слова за такт процессора вместо 1
   Хитрость в том, что мы передаем данные как на восходящем, так и на нисходящем фронте меандра.
** Кеши CPU: L1, L2, L3
   Кэш - быстрый кусок SRAM рядом с процессором, в который складываются часто используемые данные
   Кэш - всегда SRAM, чтобы было быстро, и потому всегда маленький, чтобы было не так
   дорого и энергозатратно.

   L1 - это самый маленький и близкий к процессору кэш. Он обычно сидит на том же куске
   кремния. Иногда подразделяется на L1i (кэш инструкций) b L1d (кэш данных)
   Его подстраховывает кэш L2 - который побольше и чуть подальше.
   Для многоядерных процессоров есть также кэш L3, к которому могут обращаться все ядра.
   (подробнее про это все - в последнем пункте)

   Кэши могут быть inclusive (L1 ⊂ L2 ⊂ L3 - данные дублируются) или exclusive (данные не дублируются)

   Кэш разбит на кэш-линии -- последовательно индексируемые куски памяти
   Структура кэш-линии:
   | tag | data block | flags |

   * tag - кусок адреса того куска памяти, который дублируется в этой кэш-линии.
     Нужен, чтобы искать данные по адресу в кэше
   * data - собственно, сами данные
   * flags - различная мета-инфа, а еще тут бывают коды коррекции ошибок

   Обычный адрес в памяти выглядит так:
   | tag | index | offset |
   * tag - как раз тот кусок, который матчится с tag в кэше
   * index - индекс кэш-линии, определяет, в каком наборе линий искать данные
   * offset - отступ от начала линии

   Контроллер обычной памяти же воспринимает адрес по-своему (как?)

   По методике синхронизации с памятью кэши бывают write-through и write-back.
   write-through - это когда любой запрос на запись всегда досылается в память,
   write-back - это когда данные из кэша дампятся в память только при вытеснении

   sources:
   [[https://en.wikipedia.org/wiki/CPU_cache]]
   [[http://arstechnica.com/gadgets/2002/07/caching/2/]]
** Схема параллельного извлечения
   Параллельное извлечение используется в кэше (там где у кэш-линий есть tag)
   Мы просто посылаем tag адреса на компараторы кэш-линий. Компаратор сравнивает
   tag линии с переданным, и высылает 1, если он совпал, и 0 - если нет.

   Данные извлекаются из всех кэш-линий одновременно, и данные каждой кэш-линии
   and-ятся с результатом компаратора. Выходные провода данных спаиваются вместе,
   и в итоге на выходе получаются только данные из кэш-линии с нужным тэгом.

   Если же все компараторы вернули 0, то мы детектируем cache miss и перенаправляем запрос к
   контроллеру памяти.

   sources:
   [[http://www.csbio.unc.edu/mcmillan/Media/L20Spring2012.pdf]]
   [[http://lwn.net/Articles/252125/]]
** Извлечение демультиплексором
   Демультиплексор - это штука, которая принимает n-битное число и сигнал
   и дает этот сигнал на соответствующий числу выход (один из 2ⁿ).
   [[https://en.wikipedia.org/wiki/Multiplexer#/media/File:Demultiplexer_Example01.svg][Схема]]

   Извлекать данные демультиплексором надо так:
   [[http://lwn.net/images/cpumemory/cpumemory.9.png][схема]]
   Row Address Selection - демультиплексор (выбираем строку но номеру)
   Column Address Selection - мультиплексор (выбираем столбец по номеру из тех, что пришли)

   Демультиплексор также используется в кэшах с неполной ассоциативностью, где с его
   помощью извлекаются кэш-линии с заданным индексом.
** Ассоциативность
   Суть кэша - в том, чтобы быстро проверить, лежат ли данные по
   заданному адресу в кэше, и если да - вернуть их.

   Если кэш полностью ассоциативный (fully-associative), то мы должны сделать параллельное
   извлечение сразу из всего кэша! С этим есть несколько бед:
   - Теги должны быть большими, слишком много места в кэше отведено под тэги
   - Теги большие - и компараторы для них тоже большие, а значит -
     дорогие и медленные

   Однако, есть плюсы:
   + Не бывает коллизий кэша - если мы хотим положить что-то в кэш и в нем еще
     вообще есть место, нам это удастся
   + Как следствие этого, происходит мало cache miss-ов

   Противоположность: direct-mapped cache.
   Адрес в памяти однозначно определяет кэш-линию,
   в которой эта ячейка памяти может содержаться.

   Делается это так: адрес демультиплексируется по index, выбирается 1 кэш-линия,
   тэг в ней сравнивается с данным, и если тэг равен - данные кэш-линии возвращаются.
   Иначе - регистрируется кэш-мисс.

   Pros:
   + Все это делается быстро, нет кучи компараторов
   Cons:
   - Так как каждая ячейка памяти может быть сохранена только в 1 кэш-линии,
     возникает множество *коллизий* - это когда 2 разные ячейки попадают в одну
     и ту же кэш-линию и кто-то из них вытесняет другую
   - Вследствие этого, много кэш-миссов

   Золотая середина - n-ассоциативный кэш, когда каждая ячейка может содержаться в
   одной из n линий. Делается это так:
   1) Демультиплексор отсеивает n кэш-линий по index адреса
   2) Из этих n линий по тэгу извлекаются параллельно данные

   sources:
   [[http://www.csbio.unc.edu/mcmillan/Media/L20Spring2012.pdf]]
   [[http://arstechnica.com/gadgets/2002/07/caching/5/]]
   [[http://arstechnica.com/gadgets/2002/07/caching/6/]]
** TLB
   TLB - translation lookaside buffer - это такой специальный кэш, который
   маппит виртуальные адреса в реальные.
   Он небольшой, и, конечно, не содержит все используемые виртуальные адреса, а лишь
   часто используемые.
   Трансляцией из виртуальных адресов в реальные занимается MMU - memory management unit
   - специальный кусок процессора.
   Он глядит в TLB, и если не находит там, пускается в долгий путь
   по page table-ам в основной памяти
** Общее влияние кеша на работу с памятью
   Кэш, в целом, ускоряет работу с памятью (кто бы мог подумать?)
   Иногда получается так, что работа идет только с кэшом, а к памяти обращений
   и вовсе нет (в случае look-aside)

   ?? Что здесь написать ??
** Кеши в мультипроцессорных системах и когерентность кешей
   Если у нас есть много ядер, то у каждого ядра есть собственные
   кэши L1 и L2.
   Однако, что же делать, если одна и та же ячейка памяти продублирована
   в кэшах разных ядер, и одно ядро меняет эту ячейку в своем кэше?
   Другое должно как-то увидеть это изменение.

   Для таких ситуаций существует *протоколы когерентности кэша*
   Например, MESI

   Во flags каждой кэш-линии кодируется ее состояние, 1 из 4:
   * Modified  - актуальная кэш-линия есть только в этом кэше, и она была изменена,
     то есть не соответствует данным в основной памяти
   * Exclusive - кэш-линия актуальна только в этом кэше, и она совпадает с данными в памяти.
   * Shared    - кэш-линия совпадает с данными в памяти и может присутствовать в нескольких кэшах
   * Invalid   - кэш-линия невалидна

   Read может происходить из любого состояния, кроме Invalid. Если пытаемся читать
   из Invalid, то нужно сначала пофетчить данные (извлечь из соседних кэшей или из памяти).

   Write может происходить только в Modified или Exclusive. Иначе сначала нам нужно инвалидировать
   все копии в других кэшах, а потом выставить статус Modified.

   Перед инвалидацией Modified-линии нужно сбросить данные из нее в память (write-back)

   sources:
   [[https://en.wikipedia.org/wiki/MESI_protocol]]
* Ticket 2
** Пайплайн и стадии
** Регистровый файл
** Пузыри (pipeline bubbles)
** Предсказание переходов (branch prediction)
** Out of order исполнение
** Интерфейс между устройствами ввода и CPU
** Прерывания
** DMA
* Ticket 3
** Виртуальная память
** MMU: TLB, каталог страниц (page table)
** Биты: readable, writeable, executable, present, dirty, copy-on-write
** IOMMU
** Память процессов
** Общая память
** Пулы памяти со специальными требованиями.
* 0 Ticket 4
** "География" адресного пространства процесса
** Структуры ядра описывающие процесс с MMU: работа с физической памятью, VMA
** Системные вызовы: brk, sbrk, mmap
** Общая память: mmaping файлов и shm_open
** Реализация malloc.
* 0 Ticket 5
** Процессы и треды
** init, родители, дети, зомби
** Треды, группы тредов, процессы, группы процессов, сессии
** Системные вызовы fork, clone, exec, wait
** Интерфейс bash
** Реализация переключения контекстов процессов: структуры данных ядра, состояния процессов, различные методы реализации CPS-преобразования.
* 0 Ticket 6
** Файловые дескрипторы и пайпы
** Системные вызовы open, read, write, close
** Структуры данных ядра: таблица файловых дескрипторов, файловые объекты POSIX, флаг CLOEXEC
** Системные вызовы dup2, fcntl, flock
** Структуры данных ядра для реализации пайпов, семафоров, блокировок на файлы.
* 0 Ticket 7
** Драйвера устройств в пространстве ядра
** Прерывания
** Монолитная обработка прерываний
** Hi/Lo прерывания
** Polling
** Драйвера как контексты исполнения и их отличия от процессов
** Реализация драйверов: структуры данных ядра, различные методы реализации CPS-преобразования.
* 0 Ticket 8    FS
** Файловые системы
** Структура данных inode
** VFS
** Структуры данных: FSObject, Namespace
** Path resolution
** Операции над неймспейсами: mount, bind mount, move mount, chroot, pivot_root
** Linux FUSE
** ФС как функция inodeno → inode
** Структуры ядра: файловый дескриптор (на устройство, файл, директорию), различные кеши
** mmaping файлов.
* 0 Ticket 9    Users/access
** Пользователи и права
** Модели прав доступа к объектам: дискретная и ролевая
** Права на объекты файловой системы
** Пользователи и группы с точки зрения ядра
** Пользователи и группы с точки зрения пространства пользователя
** Системные вызовы setuid, setgid и товарищи
** setuid bit
** PAM
** /etc/passwd, /etc/shadow, /etc/group
** Capabilities.
* 0 Ticket 10   Signals
** Стандартные сигналы
** Маски
** Правила доставки
** Реалтаймовые сигналы
** Маски и очереди
** Правила доставки
** Системные вызовы kill, sigaction
** Прерывание сигналами: кода программы, обработчиков сигналов, системных вызовов
** Реентрабельность и безопасные системные вызовы
** Сигналы и треды
** Семантика сигналов: TERM, KILL, STOP, CONT, CHLD, PIPE, ILL/FPE, SEGV, BUS.
* 0 Ticket 11   Polling
** Мултиплексирование ввода-вывода
** O_NONBLOCK
** Edge и level triggered события
** Преобразование асинхронного ввода-вывода в синхронный CPS-преобразованием
** Структуры данных пространства ядра для реализации мультиплексора файловых дескрипторов
** Системные вызовы select, poll, epoll
** Управление скоростью передачи данных через файловые дескрипторы.
* 0 Ticket 12   Synchronisation
** Синхронизация
** Спинлоки
** Ядерные семафоры
** Блокировки и лизинги на файлы
** Структуры данных пространства ядра для реализации блокировок и лизингов
** Системные вызовы: flock, fcntl.
* 2 Ticket 13   Netstack
** Сетевой стек
   Сетевой стек -- весь набор протоколов необходимых для соединения компюьтеров друг к другу.
   OSI -- один из первых базовых сетевых стеков, который не допилили. BSD сокеты -- протокол, который развивался параллельно. Проблема OSI с их разработкой была в планировке, к примеру часть разработчиков хотела разрабатывать пакетную передачу данных (на тот момент новшество), но разработчики из бывшых телефонных компаниях считали эту затею плохой. До пакетной передачи соединение обеспечивалось правильным подключением клиентов друг к другу через свичи.
   Существует три широко используемых протокола низшего уровня: MAC(через Ethernet/DSL), PPP, ARP.
   Первый всем хорошо известен, второй -- это как раз телефоны, третий используется для общения между устройствами в сети для обмена данными необходимыми для других протоколов (IP → MAC).
** PPP
** Ethernet
   Самый простой сетевой порт это COM. У него 6 проводов, одна пара из которых передает данные в одну сторону, пара в другую, еще пара сигнальная. Двухпроводное решение широко используется, есть однопроводные, которые очень сложные и непопулярные (чипы в домофонах!). После установления соединения, по проводу передается меандр. Проблемы COM-порта в нарушении целостности сигнала из-за наводки.
   Ethernet реализован чаще всего в формате UTP (unshielded twisted pair) -- много маленьких проводов очень сильно скручены друг между другом. Сигнал по витой паре задается разницой потенциалов (по 2м соседним проводам передаются сигналы, а смысл имеет их разница). Такое решение имеет смысл, потому что любая наводка одинаково искажает сигнал на двух проводах и разность остается неизменной. UTP чаще всего в этой стране встречается в формате двух и четырех пар проводов. Проводов для синхронизации нету, SIGHUB генерируется по таймауту.
   Еще есть коаксиальный кабель (тонкий кабель внутри обертки), профит которого в том, что обертка как-то защищает внутренний кабель от помех, выступая некой клеткой Фарадея.
   Сеть по формату Ethernet до 1Гб/c реализуется подключением всех юзеров к одной общей ethernet-шине. Политика такая: пока кто-то посылает пакеты, другие молчат. Если есть несколько пользователей, которые пользуются шиной одновременно, все замолкают на рандомный интервал времени, потом продолжают. [[https://en.wikipedia.org/wiki/Carrier_sense_multiple_access_with_collision_detection][CSMA/CD]]
   Сеть с большей скоростью нуждается в различных вспомогательных машинах, типа хабов.
   Хаб -- железяка, которая передает пакеты, которые ему приходят, на все свои выходы (броадкастит).
   Есть еще параллельный COM для принтеров, называется LBT. Параллельные шины плохи, потому что сложно синхронизировать передачу данных по многим проводам одновременно, учитывая всякие помехи.

   Ethernet пакет по стандарту (802.3) состоит из:
   1. Преамбула (какие-то метаданные)
   2. Header
      1. Протокол (ethertype) -- есть разные форматы ethernet (LLC, Ethernet II)
      2. Size of packet (or data). MTU -- 1500.
      3. Два MAC-адреса (отправитель и получатель)
   3. Payload (всякие данные)
   4. CRC всего кроме данных
   Больше здесь: [[https://en.wikipedia.org/wiki/Ethernet_frame][Ethernet Frame]].

   Wifi представляет из себя Ethernet по радио. Есть некоторый диапазон частот разрешенный для использования wifi-устройствами, который разделен на поддиапазоны -- каналы. В разных странах используются разные диапазоны. Wifi передает синусоиду, все как по радио, с этими вашими модуляциями.
** IP
   IP протокол находится на уровне выше и обычно запихивается в Ethernet. IP пакет содержит флаги, IP адресата/адресанта, данные и crc для всего кроме данных.
   Сетевые карты обычно фильтруют пакеты которые ей не принадлежат (адрес назначения не совпадает с нашим) на уровне MAC, IP пакеты фильтрует уже ОС. И то и другое поведение может быть изменено с помощью [[https://en.wikipedia.org/wiki/Promiscuous_mode][promiscuous mode]] опции.
   Ethernet bonding — это объединение двух или более физических сетевых интерфейсов в один виртуальный для обеспечения отказоустойчивости и повышения пропускной способности. Гуглится.

   IP -- уникальный идентификатор размером в 4 байта. Подсети бывают классов A, B и C. Для класса A определена маска 255.0.0.0, для B 255.255.0.0, для C 255.255.255.0. Кроме того, определены зарезервированные адреса для сетей: A: 10.0.0.0, B: 172.16.0.0 -- 172.13.0.0, C: 192.168.0.0 -- 192.168.255.0. Маска подсети -- число от 0 до 32, означающее количество единичек перед ноликами в двоичной записи 4-байтового числа. Маска записывается как IP. 24 -- 255.255.255.0, 31 -- 255.255.255.255. Первая нотация называется префиксной (CIDR).
   Работает это следующим образом. Пусть нужно отправить пакет. У каждого интерфейса в компьютере есть своя маска и IP (ifconfig -a). ОС выбирает интерфейс, который наиболее близок по маске с ip с ip адресата (сравниваются and, полагаю). В BSD сокетах это поведение реализуется, если делать bind(0.0.0.0). Можно сделать bind на конкретный интерфейс, и тогда пакеты будут отправляться ровно куда надо.
   Ядро хранит таблицу роутинга, которая говорит, какие пакеты в какой интерфейс пихать (ip r, netstat -rn, route). Есть дефолтный гейтвей (шлюз по умолчанию), в который отправляются пакеты, если они не матчатся по другим маскам (default в route).
** ARP
   Проблема отправки IP пакетов состоит в том, что нам нужны MAC-адреса (можно указать MAC broadcast ff:ff:ff:ff:ff:ff). Для того, чтобы по IP найти MAC, существует протокол ARP. Ядро содержит ARP-таблицу, которая заполняется по мере необходимости и отображает IP в MAC (arp -e). Если в таблице нет записи, а нужно отправить, по сети прогоняется ARP-запрос на уровне "у кого тут такой ip?", и получает ответ.
   Обратный протокол получения IP по MAC первоначально назывался RARP (reversed ARP). Потом он перетек в BOOTP, теперь это DHCP. Существенная разница RARP и DHCP в том, что DHCP -- протокол на уровне TCP/IP, а RARP был на netlink уровне (самом низком). Зачем DHCP оборачивать в IP -- никто не знает.
** Hardware
   Свитч -- это хаб с ARP таблицей внутри, который умеет отправлять пакеты не всем сразу (как хаб), а только тем, кому надо, если в ARP-таблице есть необходимая запись.
   Маршрутизатор -- это свитч с таблицей маршрутизации! Конечно, он тоже имеет ARP, и чаще всего связывает локальную сеть с внешним миром. В таком случае, обычно, в локальной сети у нодов дефолтный гейтвей как раз машрутизатор. Сам маршрутизатор получает свой дефолтный гейтвей обычно от провайдера.
** TCP/UDP/SCIP
   Протоколы, которые обычно запихивают в IP: UDP, TCP, SCIP
   1. UDP, TCP: хедеры, в UDP crc берется от хедеров, в TCP от всего пакета. UDP не обеспечивает никакого механизма проеврки доставки пакета, в отличии от TCP. TCP/UDP пакеты внутри содержат порт (/etc/services).
      Механизм подключения в TCP похож на трехкратное рукопожатие:
      1. Отправляется запрос 1→2 (syn)
      2. Отправляется подтверждение о получении запроса 2→1 (syn-ack, ack = acknowledgment), эта сторона запоминает кому отправила syn-ack
      3. Клиент отправляет 1→2 (ack) еще раз и сервер проверяет, правда ли, что отправлял клиенту syn-ack. Если да, соединение установлено.
      Забавное наблюдение заключается в том, что можно много раз отправлять некоторому набору серверов syn с подмененным ip возврата, и syn-ack будут возвращаться на желаемый адрес, от чего желаемому адресу может стать плохо. Еще минус -- приходится хранить в сервере данные о том, кому отправил syn-ack.
   2. SCTP (stream control transport protocol) -- штука похожая на TCP, но если среди N пакетов некоторые зафейлились, то только зафейленные будут отправляться заново (в TCP все начиная с первого зафейленного). Кроме того, этот протокол подразумевает, что всякие данные для подключения отправляются клиенту от сервера зашифрованными и только сервер может их расшифровать, когда эти же данные ему придут в ack. Отпадает необходимость помнить о syn-ack которые сервер отправляет.

   IPv6 имеет все из коробки внутри. Имеет обратную совместимость с IPv4, зашитый внутрь MAC. Утверждается, что использование IPv6 избавляет от необходимости использовать NAT и DHCP.
** BSD sockets: API, Stream-сокеты, Datagram-сокеты, RAW-сокеты, файловый объект для accept-сокета.
   man socket
   BSD socket API выглядит примерно так (по всему лучше читать man):
   * socket(...) -- создать сокет. Тут устанавливаются всякие параметры, тип сокета (datagram -- UDP, stream -- TCP), другие настройки.
   * connect(...) -- создать соединение на сокете. Первоначально сокет висит в пространстве и ничего не делает, connect его инициализирует.
   * bind(...) -- другой способ инициализации сокета, серверный.
   * listen(...) -- обычно следует за bind.
   * getaddrinfo(...) -- супер обобщенный вызов, возвращающий данные о хосте, которые могут быть использованы для создания сокетов. Прелесть в том, что он удобный и одинаковый для ipv4/v6 сокетов (и еще много чего).
     Есть файл /etc/nsswitch.conf. Сервисы типа getaddrinfo пользуются им чтобы определить откуда искать данные. К примеру, в nsswitch поле hosts хранит "files dns", что соответствует /etc/host.conf и /etc/resolv.conf. Есть демон nscd, который занимается тем, что резолвит запросы "откуда мне бы почитать". Этот демон первоначально запускается от рута и как-то связан с ldap, может резолвить пароли. Есть еще PAM, которой все пользуются (su), и иногда эти сервисы могут конфликтить.

   man socket описывает семейства сокетов как IPv4, IPv6, полезно еще знать про существование AF_UNIX, который используется для общения ядра самого с собой.
   Сокет конкретного семейства имеет тип. RAW сокеты -- это уровень IPv4, но сырой, без части хедеров. Поскольку с такими сокетами можно набагать и застопорить какую-нибудь очередь IO, они доступны только руту.

** ICMP, TFTP, DNS, NAT
   ICMP протокол, который завернут в Ethernet, используется для общения между роутерами, логирования ошибок, для ping/traceroute. IP пакеты имеют TTL и на каждом hop отправляют запрос обратно.
   TFTP -- UDP-протокол, обеспечивающий наивную реализацию того, что делает FTP (достань-ка мне тот файл).
   DNS -- /etc/resolv.conf. Та самая штука, которая мапит имена в <host,port>. Самый простой вариант использовать DNS -- gethostbyname -- как раз получает IP по хосту. DNS пакеты имеют тип и имя. Типы: A(IPv4), AAAA(IPv4), MX(email), TXT(что угодно). Именем является хост. Ответы бывают рекурсивными и нет. Рекурсивные ответы возвращают кучу ip-адресов, соответсвтующих одному хосту (например, сервер распределяется между несколькими хостами для уменьшения нагрузки).
   NAT (network address translation): пусть есть локальная сеть и мы пользуемся внутри локальной адресацией. Тогда если узел отправляет пакет во внешний мир, он проходит через шлюз по умолчанию. Устройство, которое имеет адрес шлюза, содержит таблицу, которая сохраняет данные о пакетах. Устройство подменяет source пакета на свой, и отправляет куда надо. Когда возвращается ответ, он перенаправляется юзеру согласно таблице. Существуют хаки, которые позволяют отправлять пакеты напрямую. Гуглить tsocks, UPnP.
* 0 Ticket 14
** Терминалы и управление заданиями в POSIX
** Терминалы, псевдотерминалы и режимы их работы
** Группы процессов и сессии
** Foreground и background группы
** Сигналы: INT, HUP, TSTP, TTIN, TTOU, WINCH
** Демоны и демонизация.
* 0 Ticket 15
  There's -2 level of execution, for example something that governs how to operate with cooler.
  Available protocols for hard drives and stuff:
  ATA-IDE, SATA-SCSI. BIOS loads first 512b - MBR - from hard drive and loads system. Standard MBR program reads something from HDD. For example, any bootloader like grub or lilo. USB is harder to program than sata -- one should rapidly poll USB device to get any data, so the driver is harder to write.
  PXE is loading from network, that uses driver for the netcard on your motherboard. Long time ago, a driver for netcard was located on the netcard itself. It uses Now the most popular is pxelinux or ipxe. pxelinux also supports TCP that's cool, because basic TFTP by UDP can lose some packets, and it's kind of critical, when kernel size is bigger then epsilon, so there's an overhead because of re-downloading the kernel.
** Загрузка: BIOS → MBR (DOS Label), DOS/Windows boot, GRUB
** initrd
** Инициализация системы: последовательная, учитывая зависимости, resource/socket activation, lazy activation
** Стандартные init системы: System V init (не забыв про runlevel), Upstart, OpenRC, systemd
** Стандартные демоны: init, syslog, klog, cron, at, ssh
** Стандартные файлы /etc: fstab, mtab, sysctl.conf, motd, issue, nologin.
* 0 Ticket 16
** Запуск программ, динамическая линковка и загрузка
** Exec magic и интерпретаторы
** Релокация кода: релокационные дырки, кеширование релокаций, GOT, PIC
** Объектные, исполняемые и библиотечные файлы
** Формат ELF
** ld-linux и его x86 32 шные ужасы.
