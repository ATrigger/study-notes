#+TODO: X 0 1 2 | OK
#+TITLE: Tеория типов, часть вторая.

* Martin-Lof type system
** Источники
   http://www.cse.chalmers.se/~bengt/papers/hlcs.pdf1
** Вступление
   Напомним всем, чем отличается конструктивный интуиционизм от
   классического подхода. Наглядная иллюстрация: конструктивное
   доказательство очень близко к компьютерной программе. Пусть нужно
   доказать:
   (∀x∈A)(∃y∈B)P(x,y)                                        (1)
   С конструктивной точки зрения, вывод такого утверждения значит
   показать функцию f, такую что f:A → B, и она дает ровно нужный y для
   того чтобы удовлетворить P(x, y). Тогда если (1) выражает некоторую
   спецификацию, то конкретная f -- это программа, удовлетворяющая этой
   спецификации. Отсюда конструктивное доказательство может
   рассматриваться как программа, а процесс вычисления значения --
   нормализация доказательства.

   # Забавные (?) факты.
   Был такой ученый, значит, Brouwer Luitzen Egbertus Jan (Брауер
   Лёйтзен Эгберт Ян, фамилия -- первое) (1881-1966), голлндский
   математик. Ему удалось в некоторый момент показать, что в
   некоторых случаях невычислимость функций классической математики
   исходит не от аксиомы выбора, как тогда было принято считать, а от
   таких вещей, как правило исключенного третьего, доказательство от
   противного и закон снятия двойного отрицания. Брауера называют
   основоположником интуиционизма, хотя идею в основном развил
   Гейтинг, его ученик (Гейтинг сформулировал интуиционистскую логику
   в 1930).

   # Рассказать что-то про интенсиональность и экстенциональность
   # теории типов.

   Теория, которая описана здесь, была предложена Мартином-Лёфом в
   1986 году.
** Утверждения как множества
#   Первоначально идея воспринимать утверждения как множества была
#   выдвинута Карри, впоследствии того, что было замечено сходство
#   аксиом импликативного фрагмента интуиционистской логики первого
#   порядка:
#   A ⊃ B ⊃ A
#   (A ⊃ B ⊃ C) ⊃ (A ⊃ B) ⊃ A ⊃ C
#   С типами базовых комбинаторов K и S:
#   K ∈ A → B → A
#   S ∈ (A → B → C) → (A → B) → A → C
#   Тогда MP соответствует применению функций (комбинаторов).
   Утверждения можно сопоставлять множествам. Это можно увидеть,
   рассмотрев объяснения Гейтинга в терминах доказательств.
   Для импликации верно:
   Доказательство A ⊃ B -- функция, которая по каждому доказательству
   A выдает доказательство B.
   Нотация функции или метода тут примитивна в конструктивной
   математике, и функцию из A в B можно рассматривать как программу,
   которая, когда применена к элементу из A, выдает элемент B как
   выходной параметр. Давайте тогда сопоставим утверждение с набором
   его доказательств:
   * A ⊃ B сопоставимо с A → B, множество функций из A в B.
   Элементы из A → B имеют форму λx.b, где b ∈ B, и b зависит от x∈A.

   Гейтинг обяъсняет конъюнкцию как пару из двух доказательств. Тогда
   сопоставление с множеством очевидно:
   * A ∧ B сопоставимо с A × B, прямое произведение A и B.

   Для дизъюнкции -- она верна, если у нас есть доказательство одного
   из двух утверждений, причем с конкретным указанием, какого. Отсюда:
   * A ∨ B сопоставимо с A + B.
   Элементы A + B имеют форму inl(a) или inr(b), где a∈A, b∈B.

   ¬A ≡ A ⊃ ⊥.
   С таким определением, где ⊥ -- противоречие, утвеждение без
   доказательства, сопоставление таково:
   * ¬A сопоставимо с A → ∅.

   Чтобы отождествить утверждения с кванторами, нам нужны операции на
   наборах множеств. Пусть B[x ← a] -- выражение, полученное
   подстановкой a для всех свободных вхождений x в B. Тогда Гейтингово
   объяснение таково:
   Доказательство (∃x ∈ A)B состоит из построения элемента a множества A
   вместе с доказательством B[x ← a].
   Таким образом, доказательство -- пара. Сопоставимое с парой
   множество -- это непересекающееся объединение множеств,
   обозначающееся (∑x ∈ A)B. Элементы -- пары <a,b>, где a∈A, b∈B[x ← a].
   Тогда формальное сопоставление таково:
   * (∃x ∈ A)B сопоставляется с множеством (∑x ∈ A)B.

   И, наконец, квантор всеобщности:
   Доказательство (∀x ∈ A)B -- функция (метод/программа), которая
   каждому элементу a из множества A сопоставляет доказательство
   B[x ← a].
   Множество, которое соответствует квантору всеобщности -- прямое
   произведение семейства множеств, обозначается (Πx ∈ A)B. Элементы
   этого множества -- функции, которые, в применении к элементу a ∈ A
   возвращают элемент B[x ← a]. Отсюда, формально:
   * (∀x ∈ A)B сопоставляется с множеством (Πx ∈ A)B.
   Элементы (Πx ∈ A)B находятся в форме λx.b, где b ∈ B, причем как b
   так и B зависят от x ∈ A. Отметим, что если B не зависит от x, то
   (Πx ∈ A)B есть то же самое, что и A → B, отсюда можно обойтись без
   →, если есть прямое произведение семейства множеств. В этом же
   смысле, (∑x ∈ A)B есть ничто иное, как A × B, когда B не зависит от
   x.

   Все эти нотации -- сахар, который будет раскрыт позже.
** Типы, их равенство, равенство объектов
   Базовая нотация в MLTT -- нотация типа. Объясним, что такое тип, и
   что значит для двух типов быть идентичными. Мы проводим суждение
   A -- тип, и формально записываем это как "A type", когда знаем
   условия для того, чтобы утверждать "некий объект имеет тип A" и
   когда знаем условия для того, чтобы утверждать, что два объекта типа A
   идентичны. Последнее условие должно определять отношение
   эквивалентности.
   Первое есть удовлетворение следующего условия:
   a -- объект типа A.
   Что формально записывается:
   a ∈ A.
   Второе -- удовлетворение такого условия:
   a и b -- идентичные объекты типа A.
   Что формально записывается
   a = b ∈ A

   A -- тип, если знаем условия для того, чтобы утверждать:
   1. a ∈ A
   2. a = b ∈ A

   Равенство на типах выполняется, когда объект одного типа является
   объектом и другого типа и когда два идентичных объекта одного типа
   являются идентичными для другого.
   A и B идентичны.
   A = B.
   Равенство на объектах симметрично, рефлексивно и транзитивно.
   * a ∈ A                ⇒⇒ a = a ∈ A
   * a = b ∈ A            ⇒⇒ b = a ∈ A
   * a = b ∈ A, b = c ∈ A ⇒⇒ a = c ∈ A
   Равенство на типах тоже есть отношение эквивалентности.
   * A type       ⇒⇒ A = A
   * A = B        ⇒⇒ B = A
   * A = B, B = C ⇒⇒ A = C
   Кроме того, равенство на типах:
   * a ∈ A, A = B     ⇒⇒ a ∈ B
   * a = b ∈ A, A = B ⇒⇒ a = b ∈ B
** Гипотетические суждения, контекст
   Гипотетическое суждение -- суждение, сделанное в контексте:
   x₁ ∈ A₁, x₂ ∈ A₂, ... xₙ ∈ Aₙ
   Где A₁ тип, A₂ тип в контексте x₁ ∈ A₁, ... Aₙ тип в контексте
   всех перед ним.

   Пусть C -- тип, не зависящий ни от каких посылок. Тогда A -- тип,
   когда x ∈ C:
   A type [x ∈ C]
   То есть для любого c ∈ C A[x ← c] есть тип.
   Тогда A будет называться семеством типов над (over) C.

   * A = B [x ∈ C] значит, что A[x ← c], B[x ← c] одинаковые типы для
     любого c ∈ C.
   * a ∈ A [x ∈ C] значит, что a -- объект типа A при x ∈ C, то есть
     мы уже знаем, что a[x ← c] есть объект типа A[x ← c] для любого
     c ∈ C.

   Пусть x₁∈A, x₂∈A₂,...xₙ∈Aₙ -- контекст длины n-1.
   Тогда верно:
   A₁ type
   A₁ type [x₁ ∈ A₁]
   ...
   Aₙ type [x₁ ∈ A₁, x₂ ∈ A₂, ... x{n-1} ∈ A{n-1}]

   Допустим мы хотим знать
   A type [x₁ ∈ A₁, ... xₙ ∈ Aₙ]
   Это значит (формально), что мы хотим знать следующее:
   A[x₁ ← a] type [x₂ ∈ A₂ [x₁ ← a],... xₙ ∈ Aₙ [xₙ ← a]]
   Причем такое утврерждение должно быть верно в пустом контексте.
   Тогда если к томе же a = b ∈ A, также верно:
   A[x₁ ← a] = A[x₁ ← b] [x₂ ∈ A₂ [x₁ ← a],... xₙ ∈ Aₙ [xₙ ← a]]
   Формально это выражается так:
   * A type [x₁ ∈ A₁...xₙ ∈ Aₙ], a ∈ A₁     ⇒⇒
     A[x₁ ← a] type [x₂ ∈ A₂[x₁ ← a],.. xₙ ∈ Aₙ[x₁ ← a]]
   * A type [x₁ ∈ A₁...xₙ ∈ Aₙ], a = b ∈ A₁ ⇒⇒
     A[x₁ ← a] = A[x₁ ← b] [x₂ ∈ A₂[x₁ ← a],.. xₙ ∈ Aₙ[x₁ ← a]]

   Подстановка в равных типах:
   Пусть A, B -- типы в контексте [x₁ ∈ A₁...xₙ ∈ Aₙ].
   * A = B [x₁ ∈ A₁...xₙ ∈ Aₙ], a ∈ A₁ ⇒⇒
     A[x₁ ← a] = B[x₁ ← a] [x₂ ∈ A₂[xᵢ ← a],...xₙ ∈ Aₙ[xᵢ ← a]]

   Подстановка в объектах:
   Пусть A -- тип в контексте [x₁ ∈ A₁...xₙ ∈ Aₙ].
   * a ∈ A [x₁ ∈ A₁...xₙ ∈ Aₙ], a ∈ A₁ ⇒⇒
     a[x₁ ← a] ∈ A[x₁ ← a] [x₂ ∈ A₂[xᵢ ← a],...xₙ ∈ Aₙ[xᵢ ← a]]

   Подстановка в равных объектах:
   Пусть c = d ∈ A -- тип в контексте [x₁ ∈ A₁...xₙ ∈ Aₙ].
   * c = d ∈ A [x₁ ∈ A₁...xₙ ∈ Aₙ], a ∈ A₁ ⇒⇒
     c[x₁ ← a] = d[x₁ ← a] ∈ A[x₁ ← a]
                            [x₂ ∈ A₂[xᵢ ← a],...xₙ ∈ Aₙ[xᵢ ← a]]

   Предположение:
   A₁ type
   A₂ type [x₁ ∈ A₁]
   ...
   Aₙ type [x₁ ∈ A₁ ... до n-1]
   A type [x₁ ∈ A₁ ... xₙ ∈ Aₙ]
   ⇒⇒
   x ∈ A[x₁ ∈ A₁...xₙ ∈ Aₙ, x ∈ A]

** Типы-функции
   Пусть A -- тип, B -- семейство типов над A, тогда (x ∈ A)B -- тип
   функции.

   Быть объектом c типа (x ∈ A)B значит знать:
   1. Когда мы применяем c к a типа A, то получаем c(a)
      в B[x ← a].
   2. Мы получаем одинаковые объекты в B[x ← a], когда применяем к c
      a = b ∈ A.

   * c = d ∈ (x ∈ A)B значит, что для любого a ∈ A c(a) и b(a) есть
     одинаковые элементы типа B[x ← a].

   Функциональный тип.
   * A type, B type [x ∈ A] ⇒⇒ (x ∈ A)B type
   Тип равенства функций.
   * A = A', B = B' [x ∈ A] ⇒⇒ (x ∈ A)B = (x ∈ A')B'

   Синтаксический сахар:
   * (A)B есть (x∈A)B, когда B не зависит от x.
   * (x ∈ A; y ∈ B)C есть (x ∈ A)(y ∈ B)C
   * (x,y ∈ A)B есть (x ∈ A; y ∈ A)C
   * c(a₁,a₂,...aₙ) есть c(a₁)(a₂)...(aₙ)

   Правила для аппликации:
   * c ∈ (x ∈ A)B, a ∈ A     ⇒⇒ c(a) ∈ B[x ← a]
   * c ∈ (x ∈ A)B, a = b ∈ A ⇒⇒ c(a) = c(b) ∈ B[x ← a]

   Правила, показывающие равенство функций:
   Аппликация (тут переходим от функций к применению):
   * c = d ∈ (x ∈ A)B, a ∈ A ⇒⇒ c(a) = d(a) ∈ B[x ← a]
   Экзистенциональность (тут переходим от применений к чистым):
   * c ∈ (x ∈ A)B, d ∈ (x ∈ A)B, c(x) = d(x) ∈ B[x ∈ A] ⇒⇒
     c = d ∈ (x ∈ A)B,
     тут x не входит свободно ни в c ни в d.

   Абстракция:
   * b ∈ B[x ∈ A] ⇒⇒ ([x]b) ∈ (x ∈ A)B
   Сахар:
   * [x₁,...xₙ]b = [x₁][x₂]..[xₙ]b
   β-конверсия:
   * a ∈ A, b ∈ B[x ∈ A] ⇒⇒ ([x]b)(a) = b[x ← a] ∈ B[x ← a]

   Два доказываемых правила:
   # Заставить кого-нибудь доказать
   η-конверсия:
   * c ∈ (x ∈ A)B ⇒⇒ ([x]c)(x) = c ∈ (x ∈ A)B, x не свободно в c
     Какой-то очевидный переход (лол)
     c ∈ (x ∈ A)B ⇒⇒ x ∈ A, c ∈ B[x ∈ A]
     β-конверсия:
     x ∈ A, c ∈ B[x ∈ A] ⇒⇒ ([x]c)(x) = c[x ← x] ∈ B[x ← c]
   ξ-правило
   * b = d ∈ B[x ∈ A] ⇒⇒ [x]b = [x]d ∈ (x ∈ A)B
** Тип Set
   Set -- тип, в котором есть объекты.
   Сразу сахар: A -- сет (set) значит, что A является элементом
   (объектом) в Set.
   1. Чтобы знать, что A -- сет необходимо знать, как определять
      канонические элементы A и когда они одинаковы.
      Канонический элемент -- это элемент в форме некоторого
      конструктора, вроде zero или succ.
   2. Два сета одинаковые (два элемента одинаковы и являются объектами
      в Set), если элемент одного сета есть элементом и другого сета, и
      если два элемента равны и принадлежат первому сету, то и
      второму.

   Формально:
   * Set type
   * A ∈ Set ⇒⇒ El(A) type
   # В оригинале так: A : Set ⇒⇒ El(A) type, что бы это ни значило.

   El -- некий оператор, отображающий элементы Set (сеты) в
   соответствующие им типы (поскольку, формально, элементы Set есть не
   типы, а объекты). На практике не пишется нигде, потому что и так
   понятно (так считают авторы повсеместно).
** Определения, константы
   Мы умеем делать всякие константы! Давайте различать примитивные и
   определяемые константы. Значение примитивной константы есть сама
   константа. Константа имеет только тип, не определение. Значение она
   получает из семантики теории.
   Примеры примитивных констант: ℕ, succ, 0.
     N    ∈ Set
     succ ∈ N → N
     0    ∈ N

   Определяемые константы определяются в терминах других объектов. Они
   бывают эксплицитно или имплицитно определенными.
   Эксплицитно определенная константа -- такое c, что:
     c = a ∈ A
   Примеры эксплицитно определенных констант:
     1  = succ(0) ∈ N
     In = [x]x ∈ N → N
     # Напоминание: (B)A -- сахар для: (x ∈ B)A, A не зависит от x
     I  = [A,x]x ∈ (A ∈ Set; A)A
   Имплицитно определенная константа -- это предоставление некоротых
   определяющих слов которые она имеет, когда мы применяем ее к
   аргументам.
   Пользуемся паттерн-матчингом и рекурсией. Примеры:
     +            ∈ ℕ → ℕ → ℕ
     +(0,y)       = y
     +(succ(x),y) = succ( +(x,y))
   Вот примитивная рекурсия:
     natrec                 ∈ ℕ → (ℕ → ℕ → ℕ) → ℕ → ℕ
     natrec (d, e, 0)       = d
     natrec (d, e, succ(a)) = e(a, natrec(d, e, a))
** Пропозициональная логика
   Теория -- набор типизаций:
     c₁ ∈ A₁ ... cₙ ∈ Aₙ
   Где c₁...cₙ -- новые примитивные константы. И еще список определений
   из определяемых констант:
     d₁ = e₁ ∈ B₁ ... dₘ = eₘ ∈ Aₘ

   Базовые типы в MLTT -- Set и все типы элементов в конкретных сетах,
   которые мы представим позже.
   Давайте определим всякие множественные связки:

*** Конъюнкция
    Введем примитивную константу:
    * & ∈ (Set; Set)Set
    &-formation:
    * A ∈ Set, B ∈ Set ⇒⇒ A&B ∈ Set
    Доказательством конъюнкции будет следующяя примитивная константа:
    * &I ∈ (A,B ∈ Set; A; B) A&B
    Это объявление -- индуктивное определение сета &(A,B), такое что
    все элементы сета &(A,B) равны элементу в форме &I(A,B,a,b),
    где A и B -- сеты и a ∈ A, b ∈ B.
    Доказательство в такой синтаксической форме называется каноническим.

    По правилу функциональной аппликации (применному 4 раза), получаем:
    # Оно, кстати, выглядит так:
    # c ∈ (x ∈ A)B, a ∈ B  ⇒⇒ c(a) ∈ B[x ← a]
    &-introduction:
    * A ∈ Set, B ∈ Set, a ∈ A, b ∈ A ⇒⇒ &I(A,B,a,b) ∈ A&B
      Доказательство:
      &I ∈ (A ∈ Set)(B ∈ Set; A; B)A&B,  A ∈ Set ⇒⇒
      &I(A) ∈ (B ∈ Set; A; B)A&B      ,  B ∈ Set ⇒⇒
      &I(A,B) ∈ (A; B)A&B             ,  a ∈ A   ⇒⇒
      &I(A,B,a) ∈ (B)A&B              ,  b ∈ B   ⇒⇒
      &I(A,B,a,b) ∈ A&B

    Чтобы получить два правила, раскрывающих конъюнкцию, введем две
    определенные константы с помощью равенств:
    # Напоминаем, что синтаксис работает в виде (a = b) ∈ C
    * &E1(A,B,&I(A,B,a,b)) = a ∈ A
    * &E2(A,B,&I(A,B,a,b)) = b ∈ B

    Проверим, что типизации констант корректны.
    * Если A ∈ Set, B ∈ Set, p ∈ A&B, то &E1(A,B,p) ∈ A.
      p ∈ A&B, тогда p равно элементу формы &I(A,B,a,b), где a ∈ A,
      b ∈ B -- это свойство канонического доказательства.
      Тогда:
      &E1(A,B,p) = &E1(A,B,&I(A,B,a,b)) = {раскрыли по опр &E1} = a ∈ A.
    * Второе аналогично

    Из последнего семантического доказательства типизаций получаем
    формальные правила:
    &-elimination 1 and 2:
    * A ∈ Set, B ∈ Set, c ∈ A & B ⇒⇒ &E1(A,B,c) ∈ A
    * A ∈ Set, B ∈ Set, c ∈ A & B ⇒⇒ &E2(A,B,c) ∈ B
*** Импликация
    Примитивная константа ⊃ вводится декларацией:
    * ⊃ ∈ (Set;Set)Set
    ⊃-formation (доказывается применением функциональной аппликации):
    * A ∈ Set, B ∈ Set ⇒ A ⊃ B ∈ Set
    Каноническое доказательство:
    * ⊃I ∈ (A, B ∈ Set, (A)B)A ⊃ B
    ⊃-introduction (доказывается):
    * A ∈ Set, B ∈ Set, b(x) ∈ B[x ∈ A] ⇒⇒ ⊃I(A,B,b) ∈ A ⊃ B
      Доказательство
      ⊃I ∈ (A ∈ Set)(B ∈ Set; (A)B)A ⊃ B, A ∈ Set      ⇒⇒
      ⊃I(A) ∈ (B ∈ Set; (A)B)A ⊃ B,       B ∈ Set      ⇒⇒
      Тут нужно дополнительно привести b(x) к виду b, это можно
      сделать с помощью правила абстракции (наверное).
      ⊃I(A,B) ∈ ((A)B)A ⊃ B,              b ∈ (x ∈ A)B ⇒⇒
      ⊃I(A,B,b) ∈ A ⊃ B
    Как и в конъюнкции, introduction помогает из трех элементов
    получить каноническое доказательство связки.

    Чтобы получить Modus Ponens, то есть ⊃-elimination, нам нужна
    определенная константа, заданная с помощью равенства:
    * ⊃E(A,B,⊃I(A,B,b,a)) = b(a) ∈ B
    Имеющая тип:
    * ⊃E ∈ (A,B ∈ Set; A ⊃ B; A)B
    ⊃-elimination aka Modus Ponens (из функциональной аппликации и
    типизации ⊃E):
    * A ∈ Set, B ∈ Set, b ∈ A ⊃ B, a ∈ A ⇒⇒ ⊃E(A,B,b,a) ∈ B
      Доказательство:
      ⊃E ∈ (A,B ∈ Set; A ⊃ B; A)B,  A ∈ Set   ⇒⇒
      ⊃E(A) ∈ (B ∈ Set; A ⊃ B; A)B, B ∈ Set   ⇒⇒
      ⊃E(A,B) ∈ (A ⊃ B; A)B,        b ∈ A ⊃ B ⇒⇒
      ⊃E(A,B,b) ∈ (A)B,             a ∈ A     ⇒⇒
      ⊃E(A,B,b,a) ∈ B
** Теория сетов
   Вкратце.
   Давайте определять сеты с натуральными числами, листами, функциями
   и прочим.

   Как определить новый сет:
   1. Ввести примитивную константу для сета.
   2. Ввести примитивные константы для конструкторов.
   3. Вывести formation rule -- типизационное правило для
      константы, обозначающей сет.
   4. Вывести introduction rules -- типизационные правила для
      конструкторов.
   5. Определить селектор -- имплицитно определенную константу (то
      есть можно рекурсию, паттерн-матчинг), выражающую сущность,
      индуктивный принцип сета.
      Equality rules -- равенства, задающие селектор(ы).
   6. Вывести elimination rules для селектора.

   Поехали.
*** Boolean set
    1. Bool ∈ Set
    2. true ∈ Bool
       false ∈ Bool
    3. formation rule не нужен, так как Bool атомарен.
    4. introduction rule не нужен, так как конструкторы не сложные.
    5. Селектор (equality rules):
       if(C,true,a,b)  = a
       if(C,false,a,b) = b

       В equality rules опущены типы в силу очевидности.
       Сахар: a = b пишется вместо a = b ∈ A когда A очевидно.

       Должно быть понятно, какой тип у if:
       if ∈ (C ∈ (Bool)Set; b ∈ Bool; C(true); C(false))C(b)
    6. elimination rules выводятся из функциональной аппликации
       elimination-2 (1 -- аналогично):
       * C ∈ (Bool)Set, c ∈ C(true), d ∈ C(false) ⇒⇒
         if(C, false, c, d) ∈ C(false)
         Доказательство:
         if ∈ (C ∈ (Bool)Set; b ∈ Bool; C(true); C(false))C(b); C ∈
         (Bool)Set ⇒⇒
         if(C) ∈ (b ∈ Bool; C(true); C(false))C(b), false ∈ Bool ⇒⇒
         if(C, false) ∈ (C(true); C(false))C(false), c ∈ C(true) ⇒⇒
         if(C, false, c) ∈ (C(false))C(false),      d ∈ C(false) ⇒⇒
         if(C, false, c, d) ∈ C(false)
*** Empty set
    1. {} ∈ Set
    2. Конструкторов нет
    3. ∅
    4. ∅
    5. case ∈ (C ∈ ({})Set; a ∈ {})C(a)
       Соответствует утверждению абсурдности
       ⊥ true, C prop ⇒⇒ C true
    6. ∅
*** Natural numbers
    1. ℕ ∈ Set
    2. 0 ∈ ℕ
       succ ∈ (n ∈ ℕ)ℕ
    3. Не нужен
    4. Можно вывести succ-introduction rule:
       a ∈ ℕ ⇒⇒ succ(a) ∈ ℕ
       Доказательство очевидно через аппликацию.
    5. natrec ∈ (C ∈ (ℕ)Set;
                 d ∈ C(0);
                 e ∈ (x ∈ ℕ, y ∈ C(x))C(succ(x));
                 n ∈ ℕ) C(n)

       natrec(C,d,e,0) = d
       natrec(C,d,e,succ(m)) = e(n,natrec(C,d,e,m))

       Ввести еще можно plus,mult:
       plus ∈ (ℕ,ℕ)ℕ
       mult ∈ (ℕ,ℕ)ℕ
       plus(m,n) = natrec([x]ℕ, n, [x,y]succ(y), m)
       mult(m,n) = natrec([x]ℕ, 0, [x,y]plus(y,n), m)
    6. Выводится
*** Cartesian product of a family of sets (Π)
    (x ∈ A)B -- это тип. Мы хотим коррелирующий сет. Пусть есть сет A
    и семейство сетов B над A (A -- сет, для каждого a ∈ A существует
    B(a) -- тоже сет), тогда Π(A,B) -- прямое произведение A и B.
    Π(A,B) хранит в себе функции, которые отображают элементы a ∈ A в
    какие-то элементы z ∈ B(a).
    1. Π ∈ (A ∈ Set; B ∈ (x ∈ A)Set) Set
    2. λ ∈ (A ∈ Set; B ∈ (x ∈ A)Set; f ∈ (x ∈ A)B) Π(A,B)
       Тут f отображает из элемента x в сет, являющийся
       подсемейством B.

       Тут я придумал пример!
       λ(ℕ, [x](if x > 1 then ℕ else Bool), foo) ∈ Π(ℕ, {ℕ, Bool})
       где foo(0) = false
           foo(1) = true
           foo(n) = n - 2
    3. A ∈ Set, B(x) ∈ Set[x ∈ A] ⇒⇒ Π(A,B) ∈ Set
    4. A ∈ Set, B(x) ∈ Set[x ∈ A], f ∈ B(x)[x ∈ A] ⇒⇒
       λ(A,B,f) ∈ Π(A,B)
       Заметим, что эти "функции" гораздо более общие, чем обычные --
       Π(A,B) -- прямое произведение семейств сетов.
    5. apply ∈ (A ∈ Set; B ∈ (x ∈ A)Set; g ∈ Π(A,B); a ∈ A)B(a)
       apply(A,B,λ(A,B,f),a) = f(a)

       Заметим также, что в отождествлении с выражениями, Π(A,B)
       соответствует (∀x ∈ A)B(x).

       Пусть семейство функций B над A никак не меняется в зависимости
       от элементов x ∈ A. Тогда прямое произведение -- сет функций.
       → ∈ (A,B ∈ Set)Set
       → = [A,B]Π(A, [x]B)

       ¬ ∈ (A ∈ Set)Set
       ¬(A) = A → {}
**** Бонус
     Давайте докажем A ⊃ ¬¬A.
     Что эквивалентно следующей задаче:
     Найдем хоть какой-нибудь элемент в сете:
     A → (¬(¬A)) ≡ A → ((A → {}) → {})

     !!!
     Хинт: мы пользуемся тут λ для →, упрощенной версией.
     такой:
     λ' ∈ (A, B ∈ Set; f ∈ (x ∈ A)B)(A → B)
     Это работает, потому что:
     A ∈ Set, B ∈ Set.
     λ(A, [x]B, [x]f([x]B(x))) ∈ Π(A, [x]B)
     λ(A, [x]B, [x]f([x]B(x))) ∈ A → B

     Аналогично для apply:
     apply' ∈ (A, B ∈ Set; g ∈ A → B, a ∈ A) B(a)
     Потому что:
     A, B ∈ Set,
     apply(A, [x]B, λ'(A, B, f), a) = f(a) ∈ B(a)

     Пусть верно:
     A → ¬¬A
     Давайте докажем A → ((A → {}) → {}).
     Для этого нужно доказать:
     λ'(A, ((A → {}) → {}), foo).
     При этом хотим foo ∈ (x ∈ A)((A → {}) → {}).
     Пусть foo выглядит как [x]bar, тогда bar имеет стрелочный тип,
     отсюда:
     foo := [x]λ'(A → {}, {}, foo2).
     Ага, ну то есть foo2 должна быть типа (y ∈ A → {})({}).
     Опять-таки, представим foo2 как [y]bar2.

     Что имеем (последовательно):
     λ'(A, (A → {}) → {}, [x]bar),
     bar ∈ (A → {}) → {}
     λ'(A, (A → {}) → {}, [x](λ'(A → {}, {}, [y]bar2)),
     bar2 ∈ {}
     bar2 = apply'(A, {}, y, x) (это тут мы применяем y ∈ A → {} к
     x ∈ A, то есть получаем элемент z ∈ {})

     Вот вам корректно типизируемое выражение нужного типа:
     Ans ≡ λ'(A, (A → {}) → {},
              [x](λ'(A → {}, {},
                  [y](apply(A, {}, y, x))))
     Тогда, выходит, Ans ∈ A → ((A → {}) → {}) = A → ¬¬A.
     Мы нашли элемент в типе, чего и хотели.
*** Identity set
    a = b ∈ A -- это равенство определяемое, два объекта равны, когда
    имеют одинаковую нормальную форму.
    Мы хотим же, например, выразить тот факт, что сложение натуральных
    чисел -- коммутативная операция. Для этого нам потребуется:
    * Id ∈ (X ∈ Set; a ∈ X; b ∈ X) Set
      В этом сете лежат доказательства того, что элементы a и b равны
      (достаточно семантическое объяснение).
    * id ∈ (X ∈ Set; x ∈ X) Id(X, x, x)
      id -- единственный конструктор для Id(A, a, b), то есть
      Id(A, a, b) наименьшее рефлексивное отношение на
      A. Транзитивность, симметричность могут быть доказаны.
    * idpeel ∈ (A ∈ Set;
                C ∈ (x,y ∈ A; e ∈ Id(A, x, y)) Set;
                a, b ∈ A;
                e ∈ Id(A, a, b);
                d ∈ (x ∈ A)C(x, x, id(A, x))) C(a, b, e)
      idpeel(A, C, a, b, id(A, a), d) = d(a)
      О константе можно думать как о подстановке для равных элементов
      -- если у нас есть общий тип a, b, тип, куда мы будем мапать
      наши элементы, сами элементы, доказательство их равенства и
      мап-функция, то мап-функцию можно применять.

**** Примеры (доказательство симметричности и транзитивности)
     * Симметричность
       Пусть мы умеем доказывать равенство a и b:
       d ∈ Id(A, a, b)
       Построим элемент Id(A, b, a):
       idpeel(A, [x,y,e]Id(A,y,x), a, b, d, [x]id(A, x)) ∈ Id(A,b,a)
       Тогда опишем формально функцию, которая делает, что надо:
       idsymm ∈ (A ∈ Set; a,b ∈ A; d ∈ Id(A, a, b)) Id(A, b, a)
       idsymm(A, a, b, d) = idpeel(A, [x,y,e]Id(A,y,x),
                                   a, b, d, [x]id(A, x))
     * Транзитивность
       Пусть: A ∈ Set; a,b,c ∈ A;
       А также известны доказательства равенств:
       d ∈ Id(A, a, b), e ∈ Id(A, b, c)
       Тогда Воспользуемся стрелочным типом и apply'/λ':
       idtrans ∈ (A ∈ Set; a,b,c ∈ A; d ∈ Id(A, a, b);
                  e ∈ Id(A, b, c)) Id(A, a, c)

       Ну, мы можем сделать такое:
       Inner ≡ idpeel(A, [x,y,p](Id(A,y,c) → Id(A,x,c)), a, b, d,
                      [x]λ'(Id(A,x,c), Id(A,x,c), [w]w))
       Это будет выражение вида Id(A,b,c) → Id(A,a,c).
       Тогда применим к нему выражение e:Id(A,b,c):
       apply'(Id(A,b,c), Id(A,a,c), Inner, e) ∈ Id(A, a, c)

       Что и хотели показать.
**** Подстановка
     subst ∈ (A ∈ Set;
              P ∈ (A)Set;
              a, b ∈ A;
              c ∈ Id(A, a, b);
              p ∈ P(a))
              P(b)
     subst(A,P,a,b,c,p) = apply(P(a), P(b),
                                idpeel(A, [x,y,z](P(x) → P(y)),
                                       a, b, c,
                                       [x]λ(P(x), P(x), [w]w)),
                                p)
*** Set of lists
    Будем строить однотипные (а что если я хочу разнотипные?) листы:
    * List ∈ (A ∈ Set) Set
    * nil ∈ (A ∈ Set) List(A)
      cons ∈ (A ∈ Set, x ∈ A, xs ∈ List(A)) List(A)
      Достаточно канонично
    * listrec ∈ (A ∈ Set;
                 C ∈ (List(A)) Set;
                 c ∈ C(nil(A));
                 e ∈ (x ∈ A, y ∈ List(A); z ∈ C(y)) C(cons(A,x,y));
                 l ∈ List(A)) C(l)
      listrec(A,C,c,e,nil(A)) = c
      listrec(A,C,c,e,cons(A,a,l)) = e(l,a,listrec(A,C,c,e,l))

      Интуиция подсказывает, что listrec -- это рекурсия на листе!
      # Заставить кого-то написать левую свертку, эта -- правая
*** Disjoint unions of two sets (+)
    то сет кусков слева или кусков справа -- inl или inr.
    1. + ∈ (A, B ∈ Set) Set
    2. inl ∈ (A,B ∈ Set; A) A + B
       inr ∈ (A,B ∈ Set; B) A + B
    3. -
    4. -
    5. when ∈ (A, B ∈ Set;
               C ∈ (A + B) Set;
               e ∈ (x ∈ A) C(inl(A,B,x));
               f ∈ (y ∈ B) C(inr(A,B,y));
               p ∈ A + B)
               C(p)
       when(A, B, C, e, f, inl(A,B,a)) = e(a)
       when(A, B, C, e, f, inr(A,B,b)) = f(b)

       Эта связка соответствует логическому ∨.
*** Disjoint union of a family of sets (Σ)
    Это сет пар.
    1. Σ ∈ (A ∈ Set; B ∈ (A)Set) Set
       Отличие от Π в типе второго аргумента -- здесь Set не зависит
       от x, хотя B все еще функция. Тонкой разницы не чувствую --
       пожалуй, и в Π можно было написать (A)B (не уверен).
    2. pair ∈ (A ∈ Set; B ∈ (A)Set; a ∈ A; B(a)) Σ(A,B)
    3. Selector:
       split ∈ (A ∈ Set;
                B ∈ (A) Set;
                C ∈ (Σ(A,B)) Set;
                d ∈ (a ∈ A; b ∈ B(a)) C(pair(A,B,a,b));
                p ∈ Σ(A,B))
                C(p)
       split(A,B,C,d,pair(A,B,a,b)) = d(a,b)

       fst ∈ (A ∈ Set, B ∈ (A)Set; p ∈ Σ(A,B)) A
       fst(A,B,p) = split(A,B, [x]A, [x,y]x, p)

       snd ∈ (A ∈ Set, B ∈ (A)Set; p ∈ Σ(A,B)) B(fst(A, B, p))
       snd(A,B,p) = split(A,B,[x]B(fst(A,B,p)), [x,y]y, p)

       Эта связка соответствует квантору существования.
*** W-types
    * Source
       W-types: good news and bad news:
       http://mazzo.li/epilogue/index.html?p=324.html
    Мы выбираем некоторый сет и строим функцию из его элементов в
    какой-то другой сет. Это очень похоже на Π, но конструктор другой.
    * W ∈ (S ∈ Set; P ∈ (x ∈ S)Set) Set

    Конструктор:
    * sup ∈ (S ∈ Set;
             s ∈ S;
             P ∈ (x ∈ S) Set;
             f ∈ (y ∈ P) W(S, P))
             W(S, P)

      S -- сет.
      P -- семейство сетов, порождаемое каждым элементом из S.
      f -- функция, сопоставляющая каждому элементу семейства P другой
      узел W.

    # {a → b; c → d} -- это анонимный паттерн матчинг!
    ψ -- функция, которая имеет 0 аргументов, соответствует {}.

    Вот вам натуральные числа:
    * mapping = {true → Unit; false → {}} ∈ (x ∈ Bool)Set
    * Nat = W Bool mapping ∈ Set
    * zero = sup(Bool, false, mapping, ψ) ∈ Nat
    * suc (n: Nat) = sup(Bool, true, mapping, {_ → n})

    И еще дерево:
    * mapping = {true → Bool; false → {}} ∈ (x ∈ Bool)Set
    * Tree = W Bool mapping ∈ Set
    * leaf = sup(Bool, false, mapping, ψ) ∈ Tree
    * node(L,R ∈ Tree) = sup(Bool, true, mapping, {true → L, false → R}) ∈ Tree
*** Set of small sets
    U -- universe, это сет, отображающий часть структуры сета на
    объектном уровне, нужен для доказательства неравенств, тайпчекинга
    алгоритмов, создания рекурсивных сетов.
    S -- функция, которая мапает U в элементы.
    * U ∈ Set
      S ∈ (U)Set
    * Конструкторы
      1. Boolᵤ ∈ U
         S(Boolᵤ) = Bool
      2. {}ᵤ ∈ U
         S({}ᵤ) = {}
      3. Πᵤ ∈ (A ∈ U, B ∈ (S(A))U) U
         S(Πᵤ(A,B)) = Π(S(A), [x]S(B(x)))
      4. И так далее
**** Пример доказательства неравенства
     Пусть докажем ¬Id(N,0,succ(0)):
     Найдем элемент в Id(N,0,succ(0)) → {}:

     Для начала пусть x ∈ Id(N,0,succ(0)), то есть от противного.
     Построим Iszero:
     Iszero ∈ (N)U
     Iszero(m) = natrec(m, Boolᵤ, [y,z]{}ᵤ)
     # natrec ∈ (C ∈ (ℕ)Set;
     #           d ∈ C(0);
     #           e ∈ (x ∈ ℕ, y ∈ C(x))C(succ(x));
     #           n ∈ ℕ) C(n)
     Понятно, что:
     Iszero(0) = S(Boolᵤ) = Bool
     Iszero(succ(0)) = S({}ᵤ) = {}

     И тогда:
     true ∈ Bool = Iszero(0)
     # x ∈ Id(N,0,succ(0))
     # true ∈ Iszero(0)
     subst(x, true) ∈ Iszero(succ(0)) = {}

     Тогда этот элемент:
     λ'(Id(N,0,succ(0)), {}, [x]subst(x,true))
         ∈ Id(N,0,succ(0)) → {}

     Причем тут x явно не выписан, заметим, так что противоречия нет.

     Утверждение: без универсума невозможно доказать отрицания
     неравенства.
* Constructive math & programming
** Мотивация
   Очень хочется высокоуровневое программирование.
   Для этого нужен вагон логики.
   Заметим высокое сходство математических сущностей и сущностей из
   программирования (тысячи их):
   |--------------------------------+-----------------------|
   | Programming                    | Mathematics           |
   |--------------------------------+-----------------------|
   | программа, процедура, алгоритм | функция               |
   | input                          | аргументы             |
   | output                         | значение              |
   | присваивание                   | равенство             |
   | S; P                           | композиция функций    |
   | if then else                   | определения по кейсам |
   | integer, real, boolean         | ℤ, ℝ, {0,1}           |
   |--------------------------------+-----------------------|
   Давайте тогда опишем систему.
* Coq manual
   Смотри [[file:./coq_introduction.v][coq_introduction.v]].
** Introduction
   В Coq есть три основных типа: Set, Prop, Type.
   1. Set -- это знакомое уже.
   2. Prop -- это утверждения пропозициональной логики.
      Например, (x ∈ A) B = forall x : A, B
      Аналогично A → B
   4. Type -- тип.

   Типы этих типов выглядят так:
   {Set, Prop, Type(i) | i ∈ ℕ}
   Set : Type(1), Prop: Type(1), Type(i) : Type(i+1).

   Все остальное в coq_introduction.v.
* Докажем, что ¬Id(Nat, 0, 1).
  * Theorem.
    ∀ A type. Id(A, _, _) -- рефлексивное.
    ∀S -- рефлексивное отношение на A: ∀x, y ∈ A Id(A, x, y) → S(x,y)
    1. Рефлексивность Id
       ∀x : Id(A, x, x)
       exact (id x)
    2. Минимальность
       ∀x, y, S : Id(A, x, y) → S(x, y)
       S(x, x) -- работает из-за рефлексивности.
       Делаем rewrite.
    3. Используем теорему о минимальном отношении, теперь
       ∀ f, f -- экстенциональна на A.
  * Докажем, что 0 ≠ 1.
    eq_nat : Nat → Nat → Bool
    eq_nat zero m =  match m with zero => true', succ m' => false'
    eq_nat (succ n) m = match m with zero => false', succ m' =>
    eq_nat n m'

    * Theorem.
      Id(N, x, y) ↔ Is_true(eq_nat(x, y))
      1. ⇒
         Берем Id(N, x, y), делаем substitution(rewrite),
         Докажем Is_true(eq_nat(x, x,))
         С помощью индукции (elim).
      2. ⇐
         Is_true(eq_nat(x, y))
         1. База: x = 0.
            1. y = 0 ⇒ id 0 : Id(N, x, y).
            2. y ≠ 0 ⇒ у нас в предпосылках есть ложь, тогда верно
               Id(N, x, y).
               Тут типа вывели {}, отсюда сделаем case {}, все
               зайдет.
         2. Переход
            Посылка: ∀y : Is_true(eq_nat(x, y)) → Id(N, x, y)
            Докажем: ∀y : Is_true(eq_nat(succ(x), y)) → Id(N,
            succ(x), y)

            Индукция по y.
            1. y = 0, тогда у нас есть ложь и мы можем что угодно
               вывести.
            2. y = succ(u)
               По определению eq_nat сбросим succ(x), succ(y).
               Получим:
               из Is_true(eq, nat(x, u)), получим Id(N, x, u).
               хотим Id(N, succ(x), succ(y))

               Рассмотрим succ : N → N.
               Тогда по экстенциональности succ:
               Id(N, x, y) → Id(N, succ(x), succ(y)).
    * Поскольку мы доказали эквивалентность проверки через set и
      через механику (eq_nat), то возьмем eq_nat(0, 1), и из
      False → Id(N, 0, 1).
* Аксиомы выбора в MLTT
  ∀X : X ≠ ∅, (∀y ∈ X : y ≠ ∅) → (×X ≠ 0)

  Более интуитивное определение:
  S_{w∈W} -- семейство ⇒ ∃(f: w → ∪{w∈W}S_w), ∀w∈W: f(w) ∈ S_w.

** ТТ-аксиома выбора.
   R -- отношение между S и T (первый аргумент из S, второй из T).
   S, T ∈ Set.
   ∀x ∈ S, ∃ y ∈ T : R(x, y) ⇒ ∃f : S → T, ∀x ∈ S : R(x, f(x)).

   * Доказательство
     Построим стрелочный тип ans:
     Π(S, [x]Σ(T, [y]R(x, y))) → Σ(S → T, [f](Π(S, [x]R(x, f(x)))))
     Это будет ровно соответствующее утверждение в нашей теории.

     Заинтродюсим z.
     * z ∈ Π(S, [x]Σ(T, [y]R(x, y)))
     Применим apply:
     * x ∈ S → z(x) ∈ Σ(T, [y]R(x, y))
     Заметим, что:
     * fst(z(x)) ∈ T
       snd(z(x)) ∈ R(x, fst(z(x)))
     Подставим вместо fst эквивалентное выражение:
     * snd(z(x)) ∈ R(x, [y]fst(z(y)))(x)
     Рассмотрим:
     * [y]snd(z(y)) ∈ [f]Π(S, [z]R(z, f(z))).
     Заабстрагируем также fst:
     * [x]fst(z(x)) ∈ S → T
     О, круто, тогда:
     * pair([x]fst(z(x)), [y]snd(z(y))) ∈ нужный тип.
** Сетоиды
   Сетоид -- это пара <S ∈ Set, =ₛ>.
   * Введем понятие экстенционального отношения:
     (x ∈ A, y ∈ B), A, B -- сетоиды.
     R(x, y) экстенционально, если
     ∀x, y ∈ A, u, v ∈ B : R(x, u) ∧ x =ₐ y ∧ u =_b v → R(y, v).
   * f, g : A → B -- экстенциональные функции на сетоидах.
     f, g экстенционально эквивалентны (f =ₑ g), если
     ∀x ∈ A: f(x) =_b g(x).
** ZF-аксиома выбора в терминах сетоидов
   A, B -- сетоиды. R -- экстенциональное отношение на A, B.
   ∀x ∈ A, ∃y ∈ B : R(x, y) → ∃f:A → B (f экстенц., ∀x:R(x, f(x))).
   (экстенциональность для f: ∀ x, y ∈ A, x=ₐy → f(x) =_b f(y))

   Эта аксиома выбора отличается от TT-варианта.

   А вот уникальная аксиома выбора, которая доказуема.
   ∀x ∈ A, ∃!y ∈ B : R(x, y) → ∃f:A → B (f экстенц., ∀x:R(x, f(x))).
   Единственность y. ∃!y значит что R(x, a) и R(x, b), тогда a =_b b.

   * Доказательство последней (уникальной) аксиомы выбора
     Возьмем функцию f из TT-choice.

     Рассмотрим:
     * x ∈ A : R(x, f(x))
       u ∈ A : R(u, f(u))

     Отсюда:
     * x =ₐ u ⇒ R(x, f(u)) ⇒ f(x) =_b f(u).

     Тогда f экстенциональна, и тогда мы получили утверждение.

   * В аксиоме без ! нет условия единственности, у нас f может
     отображать элементы одного класса эквивалентности из A в разные
     классы эквивалентности в B. Эту аксиому нельзя доказать. Более
     того, можно показать, что из аксиомы выбора выводится закон
     исключенного третьего.
** Свойства сетоидов
   * A -- сетоид, тогда |A| -- это сет под сетоидом.
   * f - (|f| : |A| → |B|, ex_proof: extensional A B f)
   * Композиция:
     f : B → C, g : A → B ⇒ f ∘ g : A → C = {h, extₕ}, где
     h = |f|∘|g|
     extₕ = {x =ₐ y → g(x) =_b g(y) → f(g(x)) =_c f(g(y))}
   * Свойства
     1. f =ₑ h ∧ g =ₑ k ⇒ (f ∘ g =ₑ h ∘ k)
     2. h ∘ (g ∘ t) =ₑ (h ∘ g) ∘ f
     3. ∀ x, y, f : X → Y :
        f ∘ idₓ =ₑ f
        id_y ∘ f =ₑ f.
   * Сетоиды являются категориями, а экстенциональные функции
     являются морфизмами.
   * f : X → Y инъективно, если ∀x, y ∈ X : f(x) =y f(y) ⇒ x =ₓ y.
   * f : X → Y сюръективно, если ∀y ∈ Y ∃x ∈ X : f(x) =_y y
   * биективно, если сюръективно и инъективно
   * A, B -- сетоиды, тогда A×B = (|A|×|B|, =ₓ)
     (x, y) =ₓ (u, v) ⇔ x =ₐ u ∧ y_b v.
   * A + B := (|A|+|B|, =ₓ)
     x =₊ y ⇔ (∃a,c ∈ A, Id(|A|+|B|, x, inl(a)) ∧ Id(|A|+|B|, y,
     inl(c)) ∧ a =ₐ c)
     ∨
     (∃b,d ∈ B, Id(|A|+|B|, x, inr(b)) ∧ Id(|A|+|B|, y,
     inr(d)) ∧ b =_b d)
   * Свободный сетоид
     (A, Id(A,_,_)) -- свободный сетоид.
   * Утверждение
     A -- свободный сетоид.
     (∀x ∈ A, ∃y ∈ B: R(x, y)) →
     (∃f : A → B, f экстенциональна : ∀ x ∈ A : R(x, f(x)))

     Доказывается почти так же, как аксиома уникального выбора.
     * Доказательство
       Имеем (из 1 акс. выбора):
       * f : A → B, ∀ x : R(x, f(x))
       Но у нас есть (A, Id(A, _, _)) ⇒ f -- экстенциональна.

** Теорема Диаконеску
*** Общая теорема Диаконеску.
    Пусть P -- утверждение,
    ∃ M -- сетоид,
    f : Bool → M -- сюръекция,
    y : M → Bool -- экстенциональна,
    f ∘ g =ₑ idₘ
    Тогда верно P ∨ ¬P.

**** Доказательство
     M -- (Bool, λxy.(x =_bool y ∨ P))
     Подберем f : Bool → |M|.
     * id : Bool → M будет экстенциональна.
       g : f ∘ g =ₑ idₘ.

     Покажем, что:
     * g(true') =_Bool g(false') ∨ ¬(g(true') =_Bool g(false'))
     Для этого достаточно разобрать случаи (в силу конечности сета
     Bool.
     1. Пусть:
        * g(true') =_Bool g(false')
        Применим к этому нашу функцию f (по экстенциональности).
        * f(g(true')) =ₘ f(g(false'))
        поскольку f ∘ g =ₑ idₘ.
        * true' =ₘ false'
        Отсюда следует, что P верно.
     2. Аналогично получаем:
        * ¬(true' =ₘ false').
        Пусть P верно, тогда true' =ₘ false'.
        Отсюда P неверно.
     Тогда P ∨ ¬P.
*** Частная теорема Диаконеску
    Возьмем общую теорему, заметим что аксиома выбора с
    подставленными вещами будет выглядеть так:
    # Тут мы берем R(x, y) = id'y =ₘ y
    (∀x ∈ M, ∃y ∈ Bool : id'y =ₘ x) →
    (∃g:M → Bool, ∀x ∈ M: id'(g(x)) =ₘ x

    Тогда у нас есть нужная для общей теоремы функция g, отсюда для
    любого P будет верно P ∨ ¬P.
