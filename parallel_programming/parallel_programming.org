* 14.09.2015
  Линеаризуемость -- суперское свойство, тащемта.
  Даже если в каждом потоке все операции атомарны, мы не можем утверждать, что объект линеаризуем (пример с class Queue, def enq, def deq).
  Мы вот хотим линеаризуемую очередь.

  Самый простой метод сделать так -- это использование блокировок (locks, mutex (mutual exclusion)).
  Идея: заведем в объекте member Mutex m, будем его лочить и разлочивать. Этот объект будет гарантировать, что объект будет застрявать на .lock, если мьютекс уже залочен и т.д.
  Код с mutex'ами будет thread-safe, если операции будут защищены одним мьютексом.

  Как написать mutex, собственно?
  1. Тут мы рассматриваем примитивную неработающую имплементацию mutex'а
  2. Тут мы рассматриваем еще одну имплементацию, но работающую относительно гарантий взаимного исключения.
     Но алгоритм не гарантирует прогресс, то есть могут застопориться на wait() оба потока.
  3. Пример который решает проблемы 2, но один поток может голодать (starvation-freedom -- требование, чтобы если поток хочет войти в секцию, то он войдет за конечное время)
  4. алгоритм Петерсона -- гарантирует взаимное исключение, отсутствие взаимной блокировки и отсутствие голодания.
  5. алгоритм петерсона для N потоков -- все то же самое, но может делать O(N²) ожидания, к.

  Блокировки бывают грубыми и тонкими. Грубая -- блокировать всю операцию целиком. Тонкая -- блокировать операции над общими объектами внутри, а не вызов, но тогда необходима двухфазовая блокировка.

  Есть проблема deadlock'а. Допустим, что есть два mutex'а, мы лочимся в одном треде сначала по m1, потом по m2, в другом треде наоборот. Можем задедлочиться тут короче.
* 21.09.2015
  Алгоритмы без блокировок.
  Lock-free алгоритмы имеют некоторые безусловые условия прогресса:
  1. Obstruction-free (отсутствие помех) -- свойство алгоритма, в
     котором если остановить всп потоки кроме одного в любом месте,
     один должен завершиться за конечное время. Так должно работать
     для каждого объекта.
     Очевидно, что объект с блокировкой не имеет такого
     свойства.
  2. Lock-freedom -- если много потоков пытаются сделать операцию,
     то хотя бы один поток должен ее исполнить за конечное
     время. Плохо то, что это условие не исключает голодания.
  3. Wait-freedom (самое сильное условие) -- если какой-то поток
     пытается выполнить операцию, то он это сделает (вне
     зависимости от действия/бездействия других потоков).

  Объекты без блокировки.
  ОБъекты бывают с lock-freedom, но этот термин перегружен.
  * Регистры без блокировки
    * Свойства физических регистров:
      1. Неатомарны
      2. Работают без ожидания.
      3. Предполагают только одного читателя и одного писателя
      4. Попытка записать и прочитать одновременно -- UB
      5. Они безопасные (safe) -- в смысле, после записи, будет
         прочитано последнее записанное значение.
    * Классификация регистров
      1. Безопасные (safe), регулярные (regular) -- при чтении
         выдает последнее записанное, или то, что уже пишется,
         атомарные (atomic) -- линеаризуемое (как регулярный,
         только если уже прочитал новое значение, то старое нельзя
         прочитать).
      2. По количеству потоков (SR, MR, SW, MW : single/multi
         reader/writer)

    * Будем строить более сложные регистры из простых требуя
      wait-free условие.
      Пусть у нас есть Safe SRSW Boolean регистр.
      1. Regular SRSW Boolean
         #+BEGIN_SRC text
           safe shared boolan r
           threadlocal boolean last

           def write(x):
             if (x != last)
               last = x
               r = x

           def read(): return r
         #+END_SRC
      2. Regular SRSW M-Valued
         Пусть у нас массив r хранит булевые значения, и число в
         нем хранится последовательностью единиц,
         терминированной нулем. Тогда это реализуется так:

         #+BEGIN_SRC text
           regular shared boolean[M] r

           def write(x): // Справа налево
             r[x] = 0
             for i = x-1 downto 0: r[i] = 1

           def read(): // Слева направо
             for i = 0 to M-1: if r[i] == 0: return i
         #+END_SRC
      3. Atomic SRSW M-Valued
         Будем хранить пару -- значение и версию. Версию можно
         разумно ограничить. Есть алгоритм без жульничества с
         версиями, но он на практике плох.

         #+BEGIN_SRC text
           safe shared (int x, int v) r
           threadlocal (int x, int v) lastRead
           threadlocal int lastWriteV

           def write(x):
             lastWriteV++
             r = (x, lastWriteV)

           def read():
             cur = r
             if cur.v > lastRead.v:
               lastRead = cur
             return lastRead.x
         #+END_SRC

         Атомарный регистр: проблемы
         1. Версии -- могут хранить пару в регуярном, но версии
            растут неограниченно.
         2. Блокировки -- алгоритм Лампорта будет работать на
            регулярных регистрах, но это не дает алгоритм без ожидания

         Теорема: не существует алгоритма построения атомарного
         регистра без ожидания, который использует конечное
         число регулярных регистров конечного размера так, чтобы
         их писал только писатель, а читал только читатель
         * Доказательство
           Нужна обратная связь от читателя к писателю.
      4. Atomic MRSW M-Valued
         Нужно отслеживать версию записанного значения, храня пару
         (x, v) в каждом из N регистров в которые пишет писатель.
         Наивно сделать это нельзя.
         Заведем N*(N-1) регистров для общения между читателями.

         1. Каждый читатель выбирает более позднее значение из
            записанного писателем и из прочитанных значенией
            других читателей
         2. ??? Что-то ридеры пишут во все остальные ячейки для
            других читателей
      5. Atomic MRMW M-Valued
         Нужна поддержка N писателей
         Отслеживаем версию записанного значения
         1. Каждый читатель выбирает более позднюю версию
         2. Для проставления версий писателями используем doorway
            секцию из алгоритма булочника (Лампорта)
            * Версия состоит из пары номера потока писателя и
              собственно числа
    * Атомарный снимок состояния N регистров
      Наивная реализация не обеспечивает атомарность.

      #+NAME: lock-free implementation
      #+BEGIN_SRC text
        shared (int x, int v) r[N]

        // wait-free
        def update(i, x):
            r[i] = (x, r[i].v + 1)

        // lock-free
        def scan():
            old = copy()
            loop:
                cur = copy()
                if forall i: cur[i].v == old[i].v
                   return cur.x  // we can get starvation here,
                                 // if update is executed too frequent
                old = cur
      #+END_SRC

      #+NAME: wait-free implementation
      #+BEGIN_SRC text
        def update():
            ??? Потеряна

        shared (int x, int v, int[N] s) r[N]

        // wait-free, O(N^2)
        def scan():
            old = copy()
            boolean updated[N]
            loop:
                cur = copy()
                for i = 0..N-1:
                    if cur[i].v != old[i].v:
                       if updated[i]: return cur.s
                       else:
                        update[i] = true
                        old = cur
                        continue loop
                return cur.x
      #+END_SRC
      * Лемма: Если значение поменялось второй раз, значит копия
        снимка s была получена вложенной операцией scan.
