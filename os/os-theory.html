<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
<title>Notes on OS lectures given by Jan Malakhovski, 4th term, 2015</title>
<!-- 2015-12-15 Tue 02:37 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Volkhov Mikhail, Dmitry Mukhutdinov" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Notes on OS lectures given by Jan Malakhovski, 4th term, 2015</h1>
<div id="table-of-contents">
<h2>&#1057;&#1086;&#1076;&#1077;&#1088;&#1078;&#1072;&#1085;&#1080;&#1077;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Legend</a></li>
<li><a href="#sec-2">2. Sources</a></li>
<li><a href="#sec-3">3. <span class="todo 2">2</span> Ticket 1    RAM</a>
<ul>
<li><a href="#sec-3-1">3.1. RAM, SRAM, DRAM</a>
<ul>
<li><a href="#sec-3-1-1">3.1.1. SRAM</a></li>
<li><a href="#sec-3-1-2">3.1.2. DRAM</a></li>
</ul>
</li>
<li><a href="#sec-3-2">3.2. Структурно-операционная схема обычной планки памяти (DDR)</a></li>
<li><a href="#sec-3-3">3.3. Кеши CPU: L1, L2, L3</a></li>
<li><a href="#sec-3-4">3.4. Схема параллельного извлечения</a></li>
<li><a href="#sec-3-5">3.5. Извлечение демультиплексором</a></li>
<li><a href="#sec-3-6">3.6. Ассоциативность</a></li>
<li><a href="#sec-3-7">3.7. TLB</a></li>
<li><a href="#sec-3-8">3.8. Общее влияние кеша на работу с памятью</a></li>
<li><a href="#sec-3-9">3.9. Кеши в мультипроцессорных системах и когерентность кешей</a></li>
</ul>
</li>
<li><a href="#sec-4">4. <span class="todo 2">2</span> Ticket 2    CPU pipeline</a>
<ul>
<li><a href="#sec-4-1">4.1. Пайплайн и стадии</a></li>
<li><a href="#sec-4-2">4.2. Регистровый файл</a></li>
<li><a href="#sec-4-3">4.3. Пузыри (pipeline bubbles)</a></li>
<li><a href="#sec-4-4">4.4. Предсказание переходов (branch prediction)</a></li>
<li><a href="#sec-4-5">4.5. Out of order исполнение</a></li>
<li><a href="#sec-4-6">4.6. Интерфейс между устройствами ввода и CPU</a></li>
<li><a href="#sec-4-7">4.7. Прерывания</a></li>
<li><a href="#sec-4-8">4.8. DMA</a></li>
</ul>
</li>
<li><a href="#sec-5">5. <span class="todo 2">2</span> Ticket 3    Virtual memory</a>
<ul>
<li><a href="#sec-5-1">5.1. <span class="done 3">3</span> Виртуальная память</a></li>
<li><a href="#sec-5-2">5.2. <span class="done 3">3</span> MMU: TLB, каталог страниц (page table)</a></li>
<li><a href="#sec-5-3">5.3. <span class="todo 1">1</span> Биты: readable, writeable, executable, present, dirty, copy-on-write</a></li>
<li><a href="#sec-5-4">5.4. <span class="done 3">3</span> IOMMU</a></li>
<li><a href="#sec-5-5">5.5. <span class="todo 2">2</span> Память процессов</a></li>
<li><a href="#sec-5-6">5.6. <span class="todo 2">2</span> Общая память</a></li>
<li><a href="#sec-5-7">5.7. <span class="todo 2">2</span> Пулы памяти со специальными требованиями.</a></li>
</ul>
</li>
<li><a href="#sec-6">6. <span class="todo 1">1</span> Ticket 4    Maps</a>
<ul>
<li><a href="#sec-6-1">6.1. <span class="done 3">3</span> "География" адресного пространства процесса</a></li>
<li><a href="#sec-6-2">6.2. <span class="todo 1">1</span> Структуры ядра описывающие процесс с MMU: работа с физической памятью, VMA</a></li>
<li><a href="#sec-6-3">6.3. <span class="done 3">3</span> Системные вызовы: brk, sbrk, mmap</a></li>
<li><a href="#sec-6-4">6.4. <span class="done 3">3</span> Общая память: shm<sub>open</sub></a></li>
<li><a href="#sec-6-5">6.5. <span class="todo 2">2</span> Реализация malloc.</a></li>
</ul>
</li>
<li><a href="#sec-7">7. <span class="todo 0">0</span> Ticket 5    Processes</a>
<ul>
<li><a href="#sec-7-1">7.1. Процессы и треды</a></li>
<li><a href="#sec-7-2">7.2. init, родители, дети, зомби</a></li>
<li><a href="#sec-7-3">7.3. Треды, группы тредов, процессы, группы процессов, сессии</a></li>
<li><a href="#sec-7-4">7.4. Системные вызовы fork, clone, exec, wait</a></li>
<li><a href="#sec-7-5">7.5. Интерфейс bash</a></li>
<li><a href="#sec-7-6">7.6. Реализация переключения контекстов процессов: структуры данных ядра, состояния процессов, различные методы реализации CPS-преобразования.</a></li>
</ul>
</li>
<li><a href="#sec-8">8. <span class="todo 2">2</span> Ticket 6    FS 0</a>
<ul>
<li><a href="#sec-8-1">8.1. <span class="todo 2">2</span> Файловые дескрипторы и пайпы</a></li>
<li><a href="#sec-8-2">8.2. <span class="todo 2">2</span> Системные вызовы open, read, write, close</a></li>
<li><a href="#sec-8-3">8.3. <span class="todo 1">1</span> Структуры данных ядра: таблица файловых дескрипторов, файловые объекты POSIX, флаг CLOEXEC</a></li>
<li><a href="#sec-8-4">8.4. <span class="todo 2">2</span> Системные вызовы dup2, fcntl, flock</a></li>
</ul>
</li>
<li><a href="#sec-9">9. <span class="todo 1">1</span> Ticket 7    Drivers/ints</a>
<ul>
<li><a href="#sec-9-1">9.1. <span class="todo 2">2</span> Драйвера устройств в пространстве ядра</a></li>
<li><a href="#sec-9-2">9.2. <span class="todo 2">2</span> Прерывания</a></li>
<li><a href="#sec-9-3">9.3. <span class="todo 2">2</span> Монолитная обработка прерываний</a></li>
<li><a href="#sec-9-4">9.4. <span class="todo 2">2</span> Hi/Lo прерывания</a></li>
<li><a href="#sec-9-5">9.5. <span class="todo 2">2</span> Polling</a></li>
<li><a href="#sec-9-6">9.6. <span class="todo X">X</span> Драйвера как контексты исполнения и их отличия от процессов</a></li>
<li><a href="#sec-9-7">9.7. <span class="todo 2">2</span> Реализация драйверов: структуры данных ядра</a></li>
<li><a href="#sec-9-8">9.8. <span class="todo X">X</span> Различные методы реализации CPS-преобразования</a></li>
</ul>
</li>
<li><a href="#sec-10">10. <span class="todo 2">2</span> Ticket 8    FS 2</a>
<ul>
<li><a href="#sec-10-1">10.1. <span class="todo 1">1</span> Файловые системы</a></li>
<li><a href="#sec-10-2">10.2. <span class="todo 2">2</span> Структура данных inode</a></li>
<li><a href="#sec-10-3">10.3. <span class="todo 2">2</span> VFS</a></li>
<li><a href="#sec-10-4">10.4. <span class="todo 1">1</span> Структуры данных: FSObject, Namespace</a></li>
<li><a href="#sec-10-5">10.5. <span class="todo 2">2</span> Path resolution</a></li>
<li><a href="#sec-10-6">10.6. <span class="todo 2">2</span> Операции над namespace: mount, bind mount, move mount, chroot, pivot<sub>root</sub></a></li>
<li><a href="#sec-10-7">10.7. <span class="done 3">3</span> Linux FUSE</a></li>
<li><a href="#sec-10-8">10.8. <span class="todo 0">0</span> ФС как функция inodeno -&gt; inode</a></li>
<li><a href="#sec-10-9">10.9. <span class="todo 1">1</span> Структуры ядра: файловый дескриптор (на устройство, файл, директорию), различные кэши, mmaping файлов.</a></li>
<li><a href="#sec-10-10">10.10. <span class="todo 1">1</span> Кеши, mmapping</a></li>
</ul>
</li>
<li><a href="#sec-11">11. <span class="todo 2">2</span> Ticket 9    Users/access</a>
<ul>
<li><a href="#sec-11-1">11.1. <span class="todo 2">2</span> Пользователи и права</a></li>
<li><a href="#sec-11-2">11.2. <span class="todo 2">2</span> Модели прав доступа к объектам: дискретная и ролевая</a></li>
<li><a href="#sec-11-3">11.3. <span class="todo 2">2</span> Права на объекты файловой системы</a></li>
<li><a href="#sec-11-4">11.4. <span class="todo 1">1</span> Пользователи и группы с точки зрения ядра</a></li>
<li><a href="#sec-11-5">11.5. <span class="todo 1">1</span> Пользователи и группы с точки зрения пространства пользователя</a></li>
<li><a href="#sec-11-6">11.6. <span class="todo 1">1</span> Системные вызовы setuid, setgid и товарищи</a></li>
<li><a href="#sec-11-7">11.7. <span class="todo 1">1</span> setuid bit</a></li>
<li><a href="#sec-11-8">11.8. PAM</a></li>
<li><a href="#sec-11-9">11.9. /etc/passwd, /etc/shadow, /etc/group</a></li>
<li><a href="#sec-11-10">11.10. Capabilities.</a></li>
</ul>
</li>
<li><a href="#sec-12">12. <span class="done 3">3</span> Ticket 10   Signals</a>
<ul>
<li><a href="#sec-12-1">12.1. <span class="done 3">3</span> Стандартные сигналы</a></li>
<li><a href="#sec-12-2">12.2. <span class="done 3">3</span> Реалтаймовые сигналы</a></li>
<li><a href="#sec-12-3">12.3. <span class="done 3">3</span> Системные вызовы kill, sigaction.</a></li>
<li><a href="#sec-12-4">12.4. <span class="done 3">3</span> Прерывание сигналами: кода программы, обработчиков сигналов, системных вызовов</a></li>
<li><a href="#sec-12-5">12.5. <span class="done 3">3</span> Сигналы и треды</a></li>
<li><a href="#sec-12-6">12.6. <span class="done 3">3</span> Семантика сигналов: TERM, KILL, STOP, CONT, CHLD, PIPE, ILL/FPE, SEGV, BUS.</a></li>
</ul>
</li>
<li><a href="#sec-13">13. <span class="todo 0">0</span> Ticket 11   Polling</a>
<ul>
<li><a href="#sec-13-1">13.1. Мултиплексирование ввода-вывода</a></li>
<li><a href="#sec-13-2">13.2. O<sub>NONBLOCK</sub></a></li>
<li><a href="#sec-13-3">13.3. Edge и level triggered события</a></li>
<li><a href="#sec-13-4">13.4. Преобразование асинхронного ввода-вывода в синхронный CPS-преобразованием</a></li>
<li><a href="#sec-13-5">13.5. Структуры данных пространства ядра для реализации мультиплексора файловых дескрипторов</a></li>
<li><a href="#sec-13-6">13.6. Системные вызовы select, poll, epoll</a></li>
<li><a href="#sec-13-7">13.7. Управление скоростью передачи данных через файловые дескрипторы.</a></li>
</ul>
</li>
<li><a href="#sec-14">14. <span class="todo 0">0</span> Ticket 12   Synchronisation</a>
<ul>
<li><a href="#sec-14-1">14.1. Синхронизация</a></li>
<li><a href="#sec-14-2">14.2. Спинлоки</a></li>
<li><a href="#sec-14-3">14.3. Ядерные семафоры</a></li>
<li><a href="#sec-14-4">14.4. Блокировки и лизинги на файлы</a></li>
<li><a href="#sec-14-5">14.5. Структуры данных пространства ядра для реализации блокировок и лизингов</a></li>
<li><a href="#sec-14-6">14.6. <span class="todo 1">1</span> Системные вызовы: flock, fcntl.</a></li>
</ul>
</li>
<li><a href="#sec-15">15. <span class="done 3">3</span> Ticket 13   Netstack</a>
<ul>
<li><a href="#sec-15-1">15.1. <span class="done 3">3</span> Сетевой стек</a></li>
<li><a href="#sec-15-2">15.2. <span class="done 3">3</span> PPP</a></li>
<li><a href="#sec-15-3">15.3. <span class="done 3">3</span> Ethernet</a></li>
<li><a href="#sec-15-4">15.4. <span class="done 3">3</span> IP</a></li>
<li><a href="#sec-15-5">15.5. <span class="done 3">3</span> ARP</a></li>
<li><a href="#sec-15-6">15.6. <span class="done 3">3</span> Hardware</a></li>
<li><a href="#sec-15-7">15.7. <span class="done 3">3</span> TCP/UDP/SCTP</a></li>
<li><a href="#sec-15-8">15.8. <span class="todo 2">2</span> BSD sockets: API, Stream-сокеты, Datagram-сокеты, RAW-сокеты, файловый объект для accept-сокета.</a></li>
<li><a href="#sec-15-9">15.9. <span class="done 3">3</span> ICMP, TFTP, DNS, NAT</a></li>
</ul>
</li>
<li><a href="#sec-16">16. <span class="done 3">3</span> Ticket 14   Terminals/Groups</a>
<ul>
<li><a href="#sec-16-1">16.1. <span class="done 3">3</span> Терминалы, псевдотерминалы и режимы их работы</a></li>
<li><a href="#sec-16-2">16.2. <span class="done 3">3</span> Группы процессов, сессии, управление заданиями</a></li>
<li><a href="#sec-16-3">16.3. <span class="done 3">3</span> Сигналы: INT, HUP, TSTP, TTIN, TTOU, WINCH</a></li>
<li><a href="#sec-16-4">16.4. <span class="done 3">3</span> Демоны и демонизация</a></li>
<li><a href="#sec-16-5">16.5. <span class="done 3">3</span> Getty и рандомные факты</a></li>
</ul>
</li>
<li><a href="#sec-17">17. <span class="todo 2">2</span> Ticket 15   Booting</a>
<ul>
<li><a href="#sec-17-1">17.1. <span class="todo 2">2</span> Pre-BIOS: хардварная загрузка</a></li>
<li><a href="#sec-17-2">17.2. <span class="done 3">3</span> Загрузка: BIOS → MBR (DOS Label), DOS/Windows boot, GRUB</a></li>
<li><a href="#sec-17-3">17.3. <span class="done 3">3</span> initrd</a></li>
<li><a href="#sec-17-4">17.4. <span class="done 3">3</span> Инициализация системы: последовательная, учитывая зависимости, resource/socket activation, lazy activation, cтандартные init системы</a></li>
<li><a href="#sec-17-5">17.5. <span class="done 3">3</span> Стандартные демоны: init, syslog, klog, cron, at, ssh</a></li>
<li><a href="#sec-17-6">17.6. <span class="done 3">3</span> Стандартные файлы /etc: fstab, mtab, sysctl.conf, motd, issue, nologin.</a></li>
</ul>
</li>
<li><a href="#sec-18">18. <span class="done 3">3</span> Ticket 16   Linking</a>
<ul>
<li><a href="#sec-18-1">18.1. <span class="done 3">3</span> ELF</a></li>
<li><a href="#sec-18-2">18.2. <span class="done 3">3</span> Статическая линковка</a></li>
<li><a href="#sec-18-3">18.3. <span class="done 3">3</span> Динамическая линковка, GOT, PLT</a></li>
<li><a href="#sec-18-4">18.4. <span class="done 3">3</span> PIC</a></li>
<li><a href="#sec-18-5">18.5. <span class="todo 2">2</span> Exec magic и интерпретаторы и прочее</a></li>
</ul>
</li>
<li><a href="#sec-19">19. Uncategoriesed</a>
<ul>
<li><a href="#sec-19-1">19.1. Execution levels</a></li>
<li><a href="#sec-19-2">19.2. Encryption and safety</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Legend</h2>
<div class="outline-text-2" id="text-1">
<p>
X &#x2013; нифига не написано и непонятно, где брать
0 &#x2013; нифига не написано
1 &#x2013; что-то написано, но не дописано
2 &#x2013; написано, но возможно, что что-то серьезно упущено
3 &#x2013; все хорошо.
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Sources</h2>
<div class="outline-text-2" id="text-2">
<p>
Тут только самые важные и обширные источники. Всякие статьи, которые по мере необходимости встречаются в тексте, встречаются только там (и в заголовках тем).
</p>
<ol class="org-ol">
<li>Raw notes by volhovm
</li>
<li>OS course plan
<a href="http://rain.ifmo.ru/~trojan/linux/year2009/">http://rain.ifmo.ru/~trojan/linux/year2009/</a>
</li>
<li>Yet another plan
<a href="http://rain.ifmo.ru/~trojan/linux/year2007/">http://rain.ifmo.ru/~trojan/linux/year2007/</a>
</li>
<li>Prev. year googledoc
<a href="https://docs.google.com/spreadsheets/d/1CoPjN7shou3m3kAQdsRHY1HxQYyKho5f7Qn1KeL9n-U/edit#gid=0">https://docs.google.com/spreadsheets/d/1CoPjN7shou3m3kAQdsRHY1HxQYyKho5f7Qn1KeL9n-U/edit#gid=0</a>
</li>
<li>Malakhovski's notes
<a href="https://github.com/oxij/unix-notes-ru/blob/master/compiled/main.pdf">https://github.com/oxij/unix-notes-ru/blob/master/compiled/main.pdf</a>
</li>
<li>Wikipedia ofc
</li>
<li>Very much about memory
<a href="http://www.akkadia.org/drepper/cpumemory.pdf">http://www.akkadia.org/drepper/cpumemory.pdf</a>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> <span class="todo 2">2</span> Ticket 1    RAM</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> RAM, SRAM, DRAM</h3>
<div class="outline-text-3" id="text-3-1">
<p>
<b>RAM</b> (<i>random-access memory</i>) - это оперативная память.
</p>

<p>
От постоянной памяти ее отличает:
</p>
<ol class="org-ol">
<li>скорость работы
</li>
<li>потеря данных в отсутствие питания
</li>
<li>да вообще все по-другому!
</li>
</ol>
</div>

<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1"><span class="section-number-4">3.1.1</span> SRAM</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
<b>SRAM</b> (<i>static random-access memory</i>) - статическая память.
</p>

<p>
Ячейка SRAM основана на защелке:
<img src="http://2.bp.blogspot.com/-dCCrTGB-c6U/T1zaY5TG1oI/AAAAAAAAAu8/MutoYbjglvs/s1600/SRAM.gif" alt="SRAM.gif" />
</p>

<ul class="org-ul">
<li><b>Read-операция</b>: мы даем на WL напряжение, сигнал уходит с BL и
¬BL.
</li>
<li><b>Write-операция</b>: мы даем на WL напряжение и в BL тоже даем
сигнал, он запоминается.
</li>
</ul>

<p>
Pros:
</p>
<ul class="org-ul">
<li>Быстрая
</li>
<li>Не надо ничего перезаписывать
</li>
</ul>
<p>
Cons:
</p>
<ul class="org-ul">
<li>Защелки жрут электричество все время
</li>
<li>Схема ячейки сложная, делать дороже
</li>
<li>Ячейка занимает много площади
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2"><span class="section-number-4">3.1.2</span> DRAM</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
<b>DRAM</b> (<i>dynamic random-access memory</i>) - динамическая память.
</p>

<p>
Ячейка DRAM основана на конденсаторе. Схема ячейки:
</p>


<div class="figure">
<p><img src="https://www.cs.auckland.ac.nz/~jmor159/363/html/fig/dram_cell.gif" alt="dram_cell.gif" />
</p>
</div>

<ul class="org-ul">
<li><b>Read-операция</b>: мы даем на WL напряжение, конденсаторы
разряжаются, сигнал уходит, и теперь его надо перезаписать
обратно.
</li>
<li><b>Write-операция</b>: даем на WL и BLs напряжения, те конденсаторы,
на которых 1, заряжаются, а те, на которых 0 - разряжаются.
</li>
<li><b>Замечание</b>: так как конденсаторы разряжаются сами по себе,
периодически надо их перезаписывать (memory refresh)
</li>
</ul>

<p>
Pros:
</p>
<ul class="org-ul">
<li>Дешевая
</li>
<li>Ячейки маленькие, можно много понапихать
</li>
<li>Жрет энергию только во время read/write и refresh
</li>
</ul>
<p>
Cons:
</p>
<ul class="org-ul">
<li>Медленная (конденсаторы разряжаются не мгновенно)
</li>
<li>Refresh-и тоже не прибавляют отзывчивости
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Структурно-операционная схема обычной планки памяти (DDR)</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Схема одного банка:
</p>


<div class="figure">
<p><img src="https://upload.wikimedia.org/wikipedia/commons/3/3d/Square_array_of_mosfet_cells_read.png" alt="Square_array_of_mosfet_cells_read.png" />
</p>
</div>

<p>
Банки лежат на планочке рядом. Верхняя часть адреса ячейки отвечает
за номер банка
</p>

<p>
<b>DDR</b> (<i>double-data rate</i>) - хитрость, позволяющая передавать 2 слова
за такт процессора вместо 1.  Хитрость в том, что мы передаем
данные как на восходящем, так и на нисходящем фронте меандра.
</p>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Кеши CPU: L1, L2, L3</h3>
<div class="outline-text-3" id="text-3-3">
<p>
<b>Кэш</b> - быстрый кусок SRAM рядом с процессором, в который
складываются часто используемые данные. Кэш - всегда SRAM, чтобы
было быстро, и потому всегда маленький, чтобы было не так дорого и
энергозатратно.
</p>

<ol class="org-ol">
<li>L1 - это самый маленький и близкий к процессору кэш. Он обычно
</li>
</ol>
<p>
сидит на том же куске кремния. Иногда подразделяется на L1i (кэш
инструкций) b L1d (кэш данных).
</p>
<ol class="org-ol">
<li>Его подстраховывает кэш L2 - который побольше и чуть подальше.
</li>
<li>Для многоядерных процессоров есть также кэш L3, к которому могут
обращаться все ядра. (подробнее про это все - в последнем
пункте).
</li>
</ol>

<p>
Кэши могут быть <b>inclusive</b> (L1 ⊂ L2 ⊂ L3 - данные дублируются) или
<b>exclusive</b> (данные не дублируются).
</p>

<p>
Кэш разбит на кэш-линии. Структура кэш-линии:
</p>


<div class="figure">
<p><img src="ditaa-cacheline.png" alt="ditaa-cacheline.png" />
</p>
</div>

<p>
Кроме этого мы знаем номер каждой кэш-линии.
</p>

<p>
Мы делим:
</p>
<ul class="org-ul">
<li>tag - кусок адреса того куска памяти, который дублируется в этой
кэш-линии. За тегом закреплен некоторый последовательный регион
данных размера \(2^{length\_tag}\). Нужен, чтобы искать данные по
адресу в кэше.
</li>
<li>data - собственно, сами данные (может, 256 байт, много).
</li>
<li>flags - различная мета-инфа, а еще тут бывают коды коррекции
ошибок.
</li>
</ul>


<p>
Обычный адрес в памяти интерпретируется в следующем виде:
</p>


<div class="figure">
<p><img src="ditaa-address.png" alt="ditaa-address.png" />
</p>
</div>

<ul class="org-ul">
<li>tag - как раз тот кусок, который матчится с tag в кэше.
</li>
<li>index - индекс кэш-линии, определяет, в каком наборе линий искать
данные.
</li>
<li>offset - отступ от начала линии.
</li>
</ul>

<p>
Контроллер обычной памяти же воспринимает адрес по-своему (как?).
</p>

<p>
По методике синхронизации с памятью кэши бывают <b>write-through</b> и
<b>write-back</b>.
</p>
<ol class="org-ol">
<li>write-through - это когда любой запрос на запись всегда
досылается в память.
</li>
<li>write-back - это когда данные из кэша дампятся в память только
при вытеснении.
</li>
</ol>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/CPU_cache">https://en.wikipedia.org/wiki/CPU_cache</a>
</li>
<li><a href="http://arstechnica.com/gadgets/2002/07/caching/2/">http://arstechnica.com/gadgets/2002/07/caching/2/</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> Схема параллельного извлечения</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Параллельное извлечение используется в кэше (там где у кэш-линий
есть tag). Мы просто посылаем tag адреса на компараторы
кэш-линий. Компаратор сравнивает tag линии с переданным, и высылает
1, если он совпал, и 0 - если нет.
</p>

<p>
Данные извлекаются из всех кэш-линий одновременно, и данные каждой
кэш-линии and-ятся с результатом компаратора. Выходные провода
данных спаиваются вместе, и в итоге на выходе получаются только
данные из кэш-линии с нужным тэгом.
</p>

<p>
Если же все компараторы вернули 0, то мы детектируем cache miss и
перенаправляем запрос к контроллеру памяти.
</p>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="http://www.csbio.unc.edu/mcmillan/Media/L20Spring2012.pdf">http://www.csbio.unc.edu/mcmillan/Media/L20Spring2012.pdf</a>
</li>
<li><a href="http://lwn.net/Articles/252125/">http://lwn.net/Articles/252125/</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> Извлечение демультиплексором</h3>
<div class="outline-text-3" id="text-3-5">
<p>
Демультиплексор - это штука, которая принимает n-битное число и
сигнал и дает этот сигнал на соответствующий числу выход (один из
2ⁿ).
</p>

<p>
Выглядит он следующим образом:
</p>


<div class="figure">
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/Demultiplexer_Example01.svg/483px-Demultiplexer_Example01.svg.png" alt="483px-Demultiplexer_Example01.svg.png" />
</p>
</div>

<p>
Извлекать данные демультиплексором надо так:
</p>


<div class="figure">
<p><img src="http://lwn.net/images/cpumemory/cpumemory.9.png" alt="cpumemory.9.png" />
</p>
</div>

<ul class="org-ul">
<li>Row Address Selection - демультиплексор (выбираем строку но
номеру).
</li>
<li>Column Address Selection - мультиплексор (выбираем столбец по
номеру из тех, что пришли).
</li>
</ul>

<p>
Демультиплексор также используется в кэшах с неполной
ассоциативностью, где с его помощью извлекаются кэш-линии с
заданным индексом.
</p>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> Ассоциативность</h3>
<div class="outline-text-3" id="text-3-6">
<p>
Суть кэша - в том, чтобы быстро проверить, лежат ли данные по
заданному адресу в кэше, и если да - вернуть их.
</p>

<p>
Если кэш <b>полностью ассоциативный</b> (<i>fully-associative</i>), то мы должны
сделать параллельное извлечение сразу из всего кэша! С этим есть
несколько бед:
</p>
<ul class="org-ul">
<li>Теги должны быть большими, слишком много места в кэше отведено
под тэги.
</li>
<li>Теги большие - и компараторы для них тоже большие, а значит -
дорогие и медленные.
</li>
</ul>

<p>
Однако, есть плюсы:
</p>
<ul class="org-ul">
<li>Не бывает коллизий кэша - если мы хотим положить что-то в кэш и в
нем еще вообще есть место, нам это удастся.
</li>
<li>Как следствие этого, происходит мало cache miss'ов.
</li>
</ul>

<p>
Противоположность: <b>кэш прямого отображения</b> (<i>direct-mapped
cache</i>): адрес в памяти однозначно определяет кэш-линию, в которой
эта ячейка памяти может содержаться.
</p>

<p>
Делается это так: адрес демультиплексируется по полю index,
выбирается одна кэш-линия, тэг в ней сравнивается с данным, и если
тэг равен &#x2013; данные кэш-линии возвращаются. Иначе - регистрируется
кэш-мисс.
</p>

<p>
Pros:
</p>
<ul class="org-ul">
<li>Все это делается быстро, нет кучи компараторов
</li>
</ul>
<p>
Cons:
</p>
<ul class="org-ul">
<li>Так как каждая ячейка памяти может быть сохранена только в 1
кэш-линии, возникает множество <b>коллизий</b> - это когда 2 разные
ячейки попадают в одну и ту же кэш-линию и кто-то из них
вытесняет другую
</li>
<li>Вследствие этого, много кэш-миссов
</li>
</ul>

<p>
Золотая середина - n-ассоциативный кэш, когда каждая ячейка может
содержаться в одной из n линий. Делается это так:
</p>
<ol class="org-ol">
<li>Демультиплексор отсеивает n кэш-линий по index адреса
</li>
<li>Из этих n линий по тэгу извлекаются параллельно данные
</li>
</ol>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="http://www.csbio.unc.edu/mcmillan/Media/L20Spring2012.pdf">http://www.csbio.unc.edu/mcmillan/Media/L20Spring2012.pdf</a>
</li>
<li><a href="http://arstechnica.com/gadgets/2002/07/caching/5/">http://arstechnica.com/gadgets/2002/07/caching/5/</a>
</li>
<li><a href="http://arstechnica.com/gadgets/2002/07/caching/6/">http://arstechnica.com/gadgets/2002/07/caching/6/</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7"><span class="section-number-3">3.7</span> TLB</h3>
<div class="outline-text-3" id="text-3-7">
<p>
<b>TLB</b> (<i>translation lookaside buffer</i>) &#x2013; это такой специальный
кэш, который маппит виртуальные адреса в реальные.
</p>

<p>
Он небольшой, и, конечно, не содержит все используемые виртуальные
адреса, а лишь часто используемые. Трансляцией из виртуальных
адресов в реальные занимается <b>MMU</b> (<i>memory management unit</i>) &#x2013;
специальный кусок процессора. Он глядит в TLB, и если не находит
там, пускается в долгий путь по page table'ам в основной памяти.
</p>
</div>
</div>
<div id="outline-container-sec-3-8" class="outline-3">
<h3 id="sec-3-8"><span class="section-number-3">3.8</span> Общее влияние кеша на работу с памятью</h3>
<div class="outline-text-3" id="text-3-8">
<p>
Кэш, в целом, ускоряет работу с памятью (кто бы мог
подумать?). Иногда получается так, что работа идет только с кэшом,
а к памяти обращений и вовсе нет (в случае look-aside).
</p>

<p>
?? Что здесь написать ??
</p>
</div>
</div>
<div id="outline-container-sec-3-9" class="outline-3">
<h3 id="sec-3-9"><span class="section-number-3">3.9</span> Кеши в мультипроцессорных системах и когерентность кешей</h3>
<div class="outline-text-3" id="text-3-9">
<p>
Если у нас есть много ядер, то у каждого ядра есть собственные кэши
L1 и L2.  Однако, что же делать, если одна и та же ячейка памяти
продублирована в кэшах разных ядер, и одно ядро меняет эту ячейку в
своем кэше?  Другое должно как-то увидеть это изменение.
</p>

<p>
Для таких ситуаций существует <b>протоколы когерентности
кэша</b>. Например, <b>MESI</b>:
</p>

<p>
Во flags каждой кэш-линии кодируется ее состояние, 1 из 4:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">Modified</td>
<td class="left">актуальная кэш-линия есть только в этом кэше, и она была изменена, то есть не соответствует данным в основной памяти</td>
</tr>

<tr>
<td class="left">Exclusive</td>
<td class="left">кэш-линия актуальна только в этом кэше, и она совпадает с данными в памяти</td>
</tr>

<tr>
<td class="left">Shared</td>
<td class="left">кэш-линия совпадает с данными в памяти и может присутствовать в нескольких кэшах</td>
</tr>

<tr>
<td class="left">Invalid</td>
<td class="left">кэш-линия невалидна</td>
</tr>
</tbody>
</table>

<p>
Read может происходить из любого состояния, кроме Invalid. Если
пытаемся читать из Invalid, то нужно сначала пофетчить данные
(извлечь из соседних кэшей или из памяти). После фетча Invalid
сменится на Shared.
</p>

<p>
Write может происходить только в Modified или Exclusive. Иначе
сначала нам нужно инвалидировать все копии в других кэшах, а потом
выставить статус Modified.
</p>

<p>
Перед инвалидацией Modified-линии нужно сбросить данные из нее в
память (write-back).
</p>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/MESI_protocol">https://en.wikipedia.org/wiki/MESI_protocol</a>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> <span class="todo 2">2</span> Ticket 2    CPU pipeline</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Пайплайн и стадии</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Исполнение инструкций - сложный процесс, включающий в себя много
этапов. Чтобы было быстро, процессор разбивает инструкции на этапы
и выполняет их на конвейере (<i>pipeline</i>)
</p>

<p>
Этапы конвейера:
</p>
<ol class="org-ol">
<li>Fetch: получение инструкции по адресу, на который указывает
IP. Обычно достается из кэша L1i.
</li>
<li>Decode: декодирует полученную инструкцию и, таким образом,
определяет, что делать дальше (сколько аргументов фетчить, куда
их посылать и так далее).
</li>
<li>FetchArgs: получает все аргументы инструкции (в том числе,
вычисляет effective address).
</li>
<li>Execute: непосредственно выполняет инструкцию.
</li>
<li>Commit: записывает результаты в регистры/память.
</li>
</ol>

<p>
<a href="pipeline.hs">Модель пайплайна на Хаскеле</a>
</p>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Classic_RISC_pipeline">https://en.wikipedia.org/wiki/Classic_RISC_pipeline</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Регистровый файл</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Регистровый файл - SRAM-массивчик в процессоре. Содержит в себе
ячейки с регистрами.
</p>

<p>
В простых процессорах имена регистров в коде напрямую маппятся в
эти ячейки, в процах покруче (современных) они иногда просто
переименовываются (так себя ведет, например, процедура XCHG
(кажется)).
</p>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Пузыри (pipeline bubbles)</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Пузырь - это последовательность nop-ов. Он появляется, когда только
что зафетченную инструкцию нельзя сразу начать исполнять -
например, она зависит от результата предыдущей, которая еще не
завершила выполнение.
</p>

<p>
Появление пузырей - это самый простой способ решения <b>data hazard</b>
(проблемы зависимостей данных) и <b>control hazard</b> (проблемы
переходов)
</p>

<p>
Другим способом решения data hazards является <b>forwarding</b> - отсылка
полученного результата инструкции назад. Между каждой стадией есть
буфер в который кладется промежуточный результат и процессор на
стадии fetchArgs может обращаться к этим буферам наперед. Есть еще
документирование, которое работает как "А давайте вы не будете так
делать" в отношении того, как разработчик должен писать код,
например если VLIW.
</p>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Bubble_(computing)">https://en.wikipedia.org/wiki/Bubble_(computing)</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> Предсказание переходов (branch prediction)</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Когда процессор натыкается на инструкцию j* (условный переход), он
должен ее распарсить и выполнить, прежде чем станет ясно, куда
нужно сдвинуть IP. Однако, если простаивать все это время, пока
инструкция не выполнится, будет очень долго. Поэтому процессор
пытается угадать, куда все-таки в итоге нужно будет прыгнуть, и
начинает фетчить и выполнять инструкции оттуда. Если же
предсказание было неверно, весь пайплайн сбрасывается, и инструкции
фетчатся заново с верного адреса.
</p>

<p>
Отсутствие <b>branch-prediction</b>'a - это когда IP всегда просто
сдвигается на единичку вперед. Чуть более продвинутые процы,
кстати, обрабатывают безусловные переходы (jmp) на decode-стадии,
иначе бы каждый безусловный переход был долгим и мучительным.
</p>

<p>
Самый простой нетривиальный бранч-предиктор - это 2 бита на каждый
джамп, которые олицетворяют одно из 4 состояний: true, almost true,
almost false, false.
</p>

<p>
Если в результате выполнения условия мы все-таки прыгнули, тогда
состояние предиктора сдвигается влево. Иначе - вправо.
</p>

<p>
Понятно, что если предиктор находится в состоянии True/Almost true,
то следующие инструкции мы фетчим из адреса прыжка. Иначе -
следующие инструкции фетчатся со следующего адреса. Предикшны
иногда фейлятся, это проверяется проверкой условия когда-нибудь
после прохода джампа.
</p>

<p>
В современных компуктерах branch predictor'ы гораздо более хитрые,
там таблицы всякие, но достаточно этого сказать, пожалуй.
</p>
</div>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> Out of order исполнение</h3>
<div class="outline-text-3" id="text-4-5">
<p>
<b>Out-of-order execution</b> - это технология, позволяющая динамически
изменять порядок выполнения инструкций.
</p>

<p>
Суть проста: предположим, есть следующий порядок инструкций:
</p>

<div class="org-src-container">

<pre class="src src-asm"><span style="color: #8AAFFA;">ADD</span> <span style="color: #FFA070;">rax</span>, rbx
<span style="color: #8AAFFA;">SUB</span> <span style="color: #FFA070;">rcx</span>, rax
<span style="color: #8AAFFA;">ADD</span> <span style="color: #FFA070;">r8</span>,  r9
</pre>
</div>

<p>
Вторая инструкция зависит от 1, поэтому должна ждать ее
выполнения. Однако 3 инструкция не зависит ни от той, ни от
другой - почему бы не пропустить ее между 1 и 2?
</p>

<p>
Процессоры с out-of-order исполнением имеют буфер инструкций
(<i>reservation station</i>) и очередь результатов. Обработка инструкции
происходит так:
</p>

<ol class="org-ol">
<li>Инструкция фетчится и декодится
</li>
<li>Инструкция кладется в буфер
</li>
<li>Когда что-то в регистрах/памяти меняется, в буфере ищутся
инструкции, которые от этого "чего-то" зависели. Достаем самую
старую из них.
</li>
<li>Инструкция выполняется
</li>
<li>Ее результат кладется в очередь
</li>
<li>Результаты записываются в регистры/память в порядке очереди
</li>
</ol>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Out-of-order_execution">https://en.wikipedia.org/wiki/Out-of-order_execution</a>
</li>
<li><a href="https://en.wikipedia.org/wiki/Reservation_station">https://en.wikipedia.org/wiki/Reservation_station</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> Интерфейс между устройствами ввода и CPU</h3>
<div class="outline-text-3" id="text-4-6">
<p>
Схема общения CPU с другими устройствами:
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bd/Motherboard_diagram.svg/665px-Motherboard_diagram.svg.png" alt="665px-Motherboard_diagram.svg.png" />
</p>

<p>
процессор общается со всеми остальными устройствами через чипсет
материнской платы. Чипсет - это 2 устройства - Northbridge (NB) и
Southbridge (SB) NB соединяет CPU с критичной по скорости
периферией:
</p>
<ul class="org-ul">
<li>Памятью
</li>
<li>Видеокартой на AGP/PCI-Express
</li>
<li>SB
</li>
</ul>

<p>
SB соединяется со всей остальной периферией:
</p>
<ul class="org-ul">
<li>PCI-девайсами (сетевая/звуковая карта)
</li>
<li>PCI/2 периферия (старые клавы и мышки)
</li>
<li>жесткими дисками (IDE, SATA)
</li>
<li>ROM (память BIOS)
</li>
<li>часы
</li>
</ul>

<p>
Также иногда SB соединяется с встроенной сетевой/звуковой/видео
картой.
</p>
</div>
</div>
<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7"><span class="section-number-3">4.7</span> Прерывания</h3>
<div class="outline-text-3" id="text-4-7">
<p>
Прерывания - это механизм сообщить процессору о том, что что-то
произошло и на это надо отреагировать.
</p>

<p>
Прерывания бывают следующие:
</p>
<ol class="org-ol">
<li>Hardware
<ol class="org-ol">
<li>Игнорируемые (<b>IRQ</b> - <i>interrupt request</i>) &#x2013; прерывания, имеющие
маску, по которой их можно опознавать и игнорить (почти все
хардварные прерывания такие).
</li>
<li>Неигнорируемые (<b>NMI</b> - <i>non-maskable interrupt</i>) - прерывания
без маски, которые нельзя игнорить (e.g. watchdog timer &#x2013;
строгий контроллер таймаута).
</li>
<li>Межпроцессорные &#x2013; генерируемые одним процессором/ядром для
другого.
</li>
</ol>
</li>
<li>Software &#x2013; генерируемые самим процессором из инструкции int,
как правило, используются для написания сисколлов.
</li>
</ol>

<p>
В железе прерывания реализованы как level-triggered и
edge-triggered.
</p>
<ul class="org-ul">
<li>level-triggered: устройство выставляет напряжение на проводе
запроса прерывания и держит его, пока ему не откликнутся.
</li>
<li>edge-triggered: устройство посылает импульс на провод запроса, и
южный мост запоминает, что это произошло.
</li>
</ul>

<p>
Есть еще контроллер прерывания, который специальная железка на
плате, имеющая приоритеты и умеющая отсылать только нужные
прерывания, чтобы все не приходило в процессор.
</p>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Interrupt">https://en.wikipedia.org/wiki/Interrupt</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-8" class="outline-3">
<h3 id="sec-4-8"><span class="section-number-3">4.8</span> DMA</h3>
<div class="outline-text-3" id="text-4-8">
<p>
<b>DMA</b> (<i>direct memory access</i>) &#x2013; это технология, позволяющая
устройствам общаться с памятью в обход процессора.
</p>

<p>
Когда видеокарта, например, хочет достать какие-то данные из
памяти, она посылает interrupt процессору, а он уже достает все из
памяти и отсылает видеокарте. Но на это тратится его драгоценное
время!
</p>

<p>
С DMA можно так: процессор передает работу DMA-контроллеру и
занимается своими делами. Тот же перекладывает данные из одного
места в другое и посылает процессору interrupt об окончании.
</p>

<p>
DMA можно использовать также и для копирования данных из одного
куска памяти в другой!
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> <span class="todo 2">2</span> Ticket 3    Virtual memory</h2>
<div class="outline-text-2" id="text-5">
<p>
Useful: <a href="http://www.makelinux.net/ldd3/chp-15-sect-1">http://www.makelinux.net/ldd3/chp-15-sect-1</a>
</p>
</div>
<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> <span class="done 3">3</span> Виртуальная память</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Виртуальная память - механизм, который отвечает за следующие
задачи:
</p>
<ol class="org-ol">
<li>Изоляция памяти процессов друг от друга и от памяти операционной
системы.
</li>
<li>Представление памяти для каждого процесса как единого
непрерывного куска.
</li>
<li>Использование большего количества памяти, чем физически
возможно.
</li>
</ol>

<p>
Суть в том, что каждому адресу в программном коде (виртуальному)
сопоставляется физический адрес в плашке памяти. Причем таблица
сопоставления виртуальных адресов для каждого процесса своя.
</p>

<p>
Кроме того, виртуальная память может мапаться куда-нибудь еще,
например - на диск, что позволяет создавать swap partitions.
</p>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> <span class="done 3">3</span> MMU: TLB, каталог страниц (page table)</h3>
<div class="outline-text-3" id="text-5-2">
<p>
<b>MMU</b> (<i>memory management unit</i>) &#x2013; устройство, управляющее трансляцией
виртуальных адресов в физические.
</p>

<p>
При нем есть его собственный кэш &#x2013; <b>TLB</b> (<i>translation lookaside
buffer</i>), который хранит небольшое множество часто используемых
адресов.
</p>

<p>
Если в TLB записи нет, идет поиск по таблицам страниц (page tables
&#x2013; paging). Обычно они находятся в основной памяти, но в некоторых
MMU есть для них рядышком отдельный буфер.
</p>

<p>
Обычно page tables устроены так:
</p>
<ul class="org-ul">
<li>первые 10 бит адреса индексируют запись в таблице 1-го уровня
(таблице таблиц). В записи лежит индекс страницы 2-го уровня.
</li>
<li>вторые 10 бит адреса индексируют запись в таблице 2-го уровня. В
записи лежит адрес начала 4-килобайтной страницы
</li>
<li>последние 12 бит - номер байта в странице
</li>
</ul>

<p>
Иллюстрация к page tables:
<img src="http://users.dickinson.edu/~braught/courses/cs354f97/Classes/Class17/Image63.gif" alt="Image63.gif" />
</p>

<p>
Если в таблице не нашлось нужной страницы, MMU делает либо запрос в
swap (если он настроен), либо говорит процессору, что случился page
fault.
</p>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="https://mn.wikipedia.org/wiki/Page_table">https://mn.wikipedia.org/wiki/Page_table</a>
</li>
<li><a href="https://en.wikipedia.org/wiki/Page_table">https://en.wikipedia.org/wiki/Page_table</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> <span class="todo 1">1</span> Биты: readable, writeable, executable, present, dirty, copy-on-write</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Это мета-информация о странице памяти.
</p>
<ul class="org-ul">
<li><code>readable</code> - можно ли сейчас страницу читать.
</li>
<li><code>writeable</code> - можно ли сейчас в страницу писать.
</li>
<li><code>present</code> - есть ли страница сейчас в памяти вообще (или надо лезть
в своп, например).
</li>
<li><code>executable</code> - можно ли эту страницу исполнять (т. е. перекинуть на
нее IP и читать инструкции).
</li>
<li><code>dirty</code> - модифицировалась ли страница.
</li>
<li><code>copy-on-write</code> - является ли страница copy-on-write, т.е. нужно ли
в случае записи скопировать страницу (мало ли, вдруг она
используется в нескольких процессах, как глобальные переменные
некоторой shared либы, например).
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> <span class="done 3">3</span> IOMMU</h3>
<div class="outline-text-3" id="text-5-4">
<p>
<b>IOMMU</b> - это MMU для периферических устройсв. Как мы знаем,
периферические устройства могут общаться с памятью напрямую с
помощью DMA, так вот, устройствам тоже хочется иметь свои
виртуальные адреса (пример: шейдерам на видеокарте тоже надо
разделять адресное пространство).
</p>

<p>
IOMMU - это ровно MMU, только приставленный не к процессору, а к
DMA-контроллеру.
</p>

<p>
Кроме того, IOMMU еще и повышает секьюрность, так как на компе с
физической DMA-адресацией хитровыебанное периферическое устройство
может считать/затереть важные области памяти в обход CPU через
DMA. С IOMMU такое не проканает.
</p>

<p>
sources:
</p>
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/IOMMU">https://en.wikipedia.org/wiki/IOMMU</a>
</li>
<li><a href="https://en.wikipedia.org/wiki/DMA_attack">https://en.wikipedia.org/wiki/DMA_attack</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> <span class="todo 2">2</span> Память процессов</h3>
<div class="outline-text-3" id="text-5-5">
<p>
Память процесса устроена так:
</p>


<div class="figure">
<p><img src="ditaa-virtmemory.png" alt="ditaa-virtmemory.png" />
</p>
</div>


<p>
Но это в Линуксе примерно так, а вообще, конечно, везде по-разному.
</p>

<p>
Во время переключения процесса (context switch) происходит, кроме
всего прочего, очистка TLB и переключение page tables для
процесса. Чтобы не копировать их туда-сюда, страницы 1 уровня
всегда находятся в выделенной области памяти на своем месте,
страницы нижних уровней раскиданы по памяти произвольно, и во время
переключения контекста ядро переставляет указатели на page tables 2
уровня.
</p>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="http://www.thegeekstuff.com/2012/03/linux-processes-memory-layout/">http://www.thegeekstuff.com/2012/03/linux-processes-memory-layout/</a>
</li>
<li><a href="http://unix.stackexchange.com/questions/72680/how-does-linux-update-page-table-after-context-switch">http://unix.stackexchange.com/questions/72680/how-does-linux-update-page-table-after-context-switch</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6"><span class="section-number-3">5.6</span> <span class="todo 2">2</span> Общая память</h3>
<div class="outline-text-3" id="text-5-6">
<p>
System V style общей памяти.
</p>

<p>
В Линуксе, например, можно выделять отдельные страницы памяти,
доступные для нескольких процессов.
</p>

<p>
В железе это выглядит очень просто &#x2013; в page tables разных
процессов есть ссылки на одну и ту же страницу физической памяти.
</p>

<p>
В коде это делается системными функциями:
</p>
<ul class="org-ul">
<li><code>shmget()</code> &#x2013; выделить кусок общей памяти.
</li>
<li><code>shmat()</code> &#x2013; присобачить этот кусок в виртуальную память процесса.
</li>
<li><code>shmdt()</code> &#x2013; убрать кусок из виртуальной памяти процесса.
</li>
<li><code>shmctl()</code> &#x2013; освободить общую память.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-7" class="outline-3">
<h3 id="sec-5-7"><span class="section-number-3">5.7</span> <span class="todo 2">2</span> Пулы памяти со специальными требованиями.</h3>
<div class="outline-text-3" id="text-5-7">
<p>
В ядре очень часто возникает задача создать/убить какой-то
стандартный объект, такой, как inode/process descriptor/semaphore и
т.д. Если делать это все время стандартным malloc-ом, это будет
долго и грустно &#x2013; маллок сам по себе долгий, и фрагментация
памяти - это тоже не очень. Поэтому возникает идея: стандартные
объекты ядра помещать в выделенные места.
</p>

<ul class="org-ul">
<li>Slab - это как раз такое выделенное место - 1 или несколько
последовательных страниц, предназначенных для размещения объектов
с наперед заданным размером.
</li>
<li>Slab-кэш - это набор slab-ов, предназначенных для какого-либо
типа объектов - inode там, вот это все.
</li>
</ul>

<p>
Аллокация объекта в slab-кэше происходит так:
</p>
<ol class="org-ol">
<li>Выбирается первый slab со свободными "комнатами".
</li>
<li>Если все slab-ы заняты, маллочится новый.
</li>
<li>Свободная комната в выбранном slab-е помечается как занятая, и
возвращается указатель на нее.
</li>
<li>Если это была последняя комната, slab помечается как
заполненный.
</li>
</ol>

<p>
Удаление объекта:
</p>
<ol class="org-ol">
<li>Комната объекта помечается как свободная
</li>
<li>Если это была последняя занятая комната, slab помечается как
свободный
</li>
</ol>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="http://www.win.tue.nl/~aeb/linux/lk/lk-9.html">http://www.win.tue.nl/~aeb/linux/lk/lk-9.html</a>
</li>
<li><a href="https://ru.wikipedia.org/wiki/Slab">https://ru.wikipedia.org/wiki/Slab</a>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> <span class="todo 1">1</span> Ticket 4    Maps</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> <span class="done 3">3</span> "География" адресного пространства процесса</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Смотреть память процессов в билете 3.
</p>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> <span class="todo 1">1</span> Структуры ядра описывающие процесс с MMU: работа с физической памятью, VMA</h3>
<div class="outline-text-3" id="text-6-2">
<p>
<b>VMA</b> (<i>virtual memory area</i>) &#x2013; это структура данных ядра,
помогающая менеджить куски адресного пространства процесса.
</p>

<p>
VMA представляет собой кусок памяти, обладающий одинаковыми
свойствами относительно своего содержимого &#x2013; одинаковые права
доступа/забэкаплены одним объектом. Это некоторым образом похоже на
понятие сегмента, хотя концепция "регион памяти с похожими
свойствами" ближе.
</p>

<p>
Memory map процесса имеет как минимум следующие зоны:
</p>
<ol class="org-ol">
<li><code>.text</code> &#x2013; программный код
</li>
<li><code>.bss</code>
</li>
<li><code>.data</code>
</li>
<li><code>стек</code>
</li>
</ol>
<p>
Посмотреть активные маппинги &#x2013; <code>cat /proc/PID/maps</code>.
Каждый маппинг состоит из:
</p>


<div class="figure">
<p><img src="ditaa-virtmemory.png" alt="ditaa-virtmemory.png" />
</p>
</div>

<p>
Каждому новому маппингу соответствует VMA. Структура называется
<code>vm_area_struct</code>, лежит в исхониках <code>include/linux/mm_types.h</code>.
</p>

<p>
Структуры данных относительно MMU &#x2013; какая-то НЕХ.
</p>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> <span class="done 3">3</span> Системные вызовы: brk, sbrk, mmap</h3>
<div class="outline-text-3" id="text-6-3">
<p>
Вершину хипа называют program break. Можно работать руками прямо с
вершиной хипа, выделять память и вот это все.
</p>
<ul class="org-ul">
<li><code>brk(void* addr)</code> выставляет вершину хипа куда-то.
</li>
<li><code>void* sbrk(int)</code> инкрементирует/декрементирует вершину хипа на
заданную величину.
</li>
</ul>

<p>
По очевидным причинам (слишком низкоуровнево), вызовами
пользоваться не нужно. С другой стороны, иногда через это выражают
malloc.
</p>

<p>
Есть другой механизм гибкой работы с динамической памятью:
</p>
<ul class="org-ul">
<li><code>mmap</code>, <code>numap</code>, <code>mlock</code>, <code>munlock</code> - забавные системные вызовы.
</li>
<li><code>mlock(void* addr, int len)</code> &#x2013; заблокировать регион в памяти так,
что ее страницы нельзя класть в своп.

<p>
Юзкейс &#x2013; хотим загрузить программу для расширофки HDD с
диска. Расшифровываем руками диск, грузим, выкидываем ключ, лочим
программу в памяти и тогда она никуда не пропадет.
</p>
</li>
<li><code>munlock(void* addr, int len)</code> &#x2013; обратное действие, разлочвает
регион если его часть залочена.
</li>
<li><code>mmap(addr, length, prot, flags, fd, ofs)</code> &#x2013; создает новый маппинг
региона виртуальной памяти.
<ol class="org-ol">
<li><code>addr</code> &#x2013; откуда мапить память (если NULL, ядро само выберет).
</li>
<li><code>len</code> &#x2013; длина.
</li>
<li><code>prot</code> &#x2013; флаги доступа к данному региону памяти (<code>PROT_NONE</code>,
<code>_EXEC</code>, <code>_READ</code>, <code>_WRITE</code>).
</li>
<li><code>flags</code> &#x2013; различные флаги. Самые важные из них:
<ol class="org-ol">
<li><code>MAP_ANONYMOUS</code> &#x2013; аргумент fd игнорируется, память создается
анонимной, заполняется нулями, не относится ни к какому
файлу.
</li>
<li><code>MAP_SHARED</code> &#x2013; устанавливает, что контент, котрый мы мапим,
будет доступен другим пользователям (мапится-то файл, а
файл могут видеть другие).
</li>
<li><code>MAP_PRIVATE</code> &#x2013; создает copy-on-write маппинг, который
уникален для процесса.
</li>
</ol>
</li>
<li><code>fd, ofs</code> &#x2013; если используется маппинг файлов, а не анонимный,
то файл и оффсет в файле, с которого мапить.
</li>
</ol>
</li>
<li><code>munmap(addr, length)</code> &#x2013; освободить от мапа данный кусок
памяти. Если используется <code>SHARED</code>, то к этому моменту все уже
будет записано в файл.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> <span class="done 3">3</span> Общая память: shm<sub>open</sub></h3>
<div class="outline-text-3" id="text-6-4">
<p>
Есть память, которая может быть доступна сразу многим процессам.
</p>
<ul class="org-ul">
<li><code>shm_open(name, oflag, mode)</code>

<p>
Определяем имя куска памяти, которое хотим шарить, флаги на
уровне <code>RDWR/RDONLY/CREAT..</code>, мод (chmod(2)). Возвращает файловый
дескриптор.
</p>
</li>
<li><code>shm_unlink(name)</code> удаляет кусок расшаренной памяти
</li>
</ul>

<p>
С помощью mmap тоже можно создать общую память, но отличие shm<sub>open</sub>
в том, что память открытая этим методом будет оставаться шареной до
ребута ядра.
</p>

<p>
Как этим пользоваться:
</p>
<div class="org-src-container">

<pre class="src src-text">shm = shm_open("mysharedname", O_RDWR, 0777)
addr = mmap(0, size, PROT_WRITE|PROT_READ, MAP_SHARED, shm, 0);
//&#1058;&#1077;&#1087;&#1077;&#1088;&#1100; &#1087;&#1086; &#1072;&#1076;&#1088;&#1077;&#1089;&#1091; addr &#1084;&#1086;&#1078;&#1085;&#1086; &#1095;&#1090;&#1086;-&#1090;&#1086; &#1087;&#1080;&#1089;&#1072;&#1090;&#1100;.
munmap(addr, size);
close(shm)
//&#1045;&#1089;&#1083;&#1080; &#1093;&#1086;&#1095;&#1077;&#1090;&#1089;&#1103; &#1096;&#1072;&#1088;&#1077;&#1085;&#1091;&#1102; &#1087;&#1072;&#1084;&#1103;&#1090;&#1100; &#1091;&#1076;&#1072;&#1083;&#1080;&#1090;&#1100;, &#1085;&#1091;&#1078;&#1085;&#1086; &#1089;&#1076;&#1077;&#1083;&#1072;&#1090;&#1100;:
shm_unlink("mysharedname");
</pre>
</div>

<p>
Source:
</p>
<ul class="org-ul">
<li><a href="http://habrahabr.ru/post/122108/">http://habrahabr.ru/post/122108/</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> <span class="todo 2">2</span> Реализация malloc.</h3>
<div class="outline-text-3" id="text-6-5">
<ol class="org-ol">
<li>На хипе с помощью <code>sbrk</code>.

<p>
Недостатки &#x2013; фрагментация данных. Чтобы от нее избавиться,
нужно иногда искать куски памяти которые уже освободились и
что-то с ними делать.
</p>
</li>
<li>С помощью <code>mmap</code>.
</li>
<li>И то и другое использовать, плюс добавить какие-нибудь бакеты,
из которых выдавать данные. Бакеты добавлять с помощью <code>sbrk</code>,
<code>mmap</code>'ом пользоваться если просят много памяти.
</li>
<li>Doug Lea pmalloc2 (в libc).
</li>
</ol>

<p>
Sources:
</p>
<ol class="org-ol">
<li>Doug lea outdated explained
<a href="http://gee.cs.oswego.edu/dl/html/malloc.html">http://gee.cs.oswego.edu/dl/html/malloc.html</a>
</li>
<li>Wiki, implementations
<a href="https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Implementations">https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Implementations</a>
</li>
<li>LIBC source pmalloc2 (extra hard)
<a href="https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=malloc/malloc.c;hb=HEAD">https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=malloc/malloc.c;hb=HEAD</a>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> <span class="todo 0">0</span> Ticket 5    Processes</h2>
<div class="outline-text-2" id="text-7">
<p>
Большинство тут написано в билете про TTY (14).
В этом билете ничего нету.
</p>
</div>
<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> Процессы и треды</h3>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> init, родители, дети, зомби</h3>
</div>
<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> Треды, группы тредов, процессы, группы процессов, сессии</h3>
</div>
<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4"><span class="section-number-3">7.4</span> Системные вызовы fork, clone, exec, wait</h3>
</div>
<div id="outline-container-sec-7-5" class="outline-3">
<h3 id="sec-7-5"><span class="section-number-3">7.5</span> Интерфейс bash</h3>
</div>
<div id="outline-container-sec-7-6" class="outline-3">
<h3 id="sec-7-6"><span class="section-number-3">7.6</span> Реализация переключения контекстов процессов: структуры данных ядра, состояния процессов, различные методы реализации CPS-преобразования.</h3>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> <span class="todo 2">2</span> Ticket 6    FS 0</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> <span class="todo 2">2</span> Файловые дескрипторы и пайпы</h3>
<div class="outline-text-3" id="text-8-1">
<p>
Файловый дескриптор - это int, который для текущего процесса
сопоставляется с неким файлом. Сопоставление идет так:
</p>
<ul class="org-ul">
<li><code>fd</code> - индекс в fdtable процесса. В ней лежит <code>*FdObj</code> - указатель на
структурку, в которой хранятся флаги, количество сославшихся и
ссылка на сам файл.

<div class="org-src-container">

<pre class="src src-text">FdObj = {
    counter :: Int,
    flags :: Flags,
    type :: Type,
    resource :: type
}
Type = Pipe | File | Dir | Socket | shm | blockdev | chardev | packetdev (network)
</pre>
</div>
</li>
<li><code>resource</code> указывает на файл в file table (общая для системы
таблица открытых файлов). Этот файл может быть структуркой
какого-то типа: DInode, Pipe, Socket, etc. Каждая такая
структурка так или иначе содержит в себе счетчик ссылок на себя
из процессов и ссылку на свой inode.
</li>
<li>Inode-ы, собственно, содержит адреса сегментов памяти, в которых
расположен файл.
</li>
</ul>

<p>
Пайпы - это специальные двунаправленные файлы. Делаются они
следующим образом: есть специальная виртуальная файловая система
pipefs, которая лежит вообще в отдельном неймспейсе (нет такой
папки в корне, которая бы ее содержала). В ней лежит inode, который
маппится на какой-то кусок памяти. На него ссылается файл-пайп в
file table, который вот такой:
</p>

<div class="org-src-container">

<pre class="src src-text">Pipe = {
    readers :: Int,
    writers :: Int,
    inode   :: *Inode
} (&#1087;&#1088;&#1080;&#1084;&#1077;&#1088;&#1085;&#1086; &#1090;&#1072;&#1082;)
</pre>
</div>

<p>
В fdtable процесса на него ссылается 2 FdObj: с read-only и write-only.
</p>

<p>
Ну и короче в 1 конец пишем, другой читаем!))
</p>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/File_descriptor">https://en.wikipedia.org/wiki/File_descriptor</a>
</li>
<li><a href="http://www.slideshare.net/divyekapoor/linux-kernel-implementation-of-pipes-and-fifos">http://www.slideshare.net/divyekapoor/linux-kernel-implementation-of-pipes-and-fifos</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> <span class="todo 2">2</span> Системные вызовы open, read, write, close</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li><code>open(path, flags)</code> – открыть файл по данному пути и вернуть <code>fd</code>.
</li>
<li><code>read(fd, buf, len)</code> - прочитать что-то из файла в буфер.
</li>
<li><code>write(fd, buf, len)</code> - записать чего-то туда.
</li>
<li><code>close(fd)</code> - закрыть дескриптор (удалить его из <code>fdtable</code> и
декрементнуть счетчик ссылок на файл).
</li>
</ul>

<p>
Все эти вызовы - абстракция VFS, а драйвера каких-то физических
систем предоставляют им реализации, понятно (см билет 8).
</p>
</div>
</div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> <span class="todo 1">1</span> Структуры данных ядра: таблица файловых дескрипторов, файловые объекты POSIX, флаг CLOEXEC</h3>
<div class="outline-text-3" id="text-8-3">
<p>
Таблица файловых дескрипторов - смотри выше.
</p>

<p>
Файловые объекты <code>POSIX</code> — эээм? как раз вот эти <code>DInode</code>, <code>Pipe</code>,
<code>Socket</code>?
</p>

<p>
Флаг <code>CLOEXEC</code> &#x2013; удобный флаг, который заставляет fd закрываться
всегда, когда успешно вызвана функция из семейства exec.
</p>
</div>
</div>
<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4"><span class="section-number-3">8.4</span> <span class="todo 2">2</span> Системные вызовы dup2, fcntl, flock</h3>
<div class="outline-text-3" id="text-8-4">
<ul class="org-ul">
<li><code>dup2(fd1, fd2)</code> - дублировать дескриптор: <code>fd2</code> начинает указывать на
тот файл, на который указывает <code>fd1</code>. Если <code>fd2</code> на что-то указывал
раньше, он сначала закрывается.  Удобно, когда надо перенаправить
куда-то <code>stdin</code> или <code>stdout</code>.
</li>

<li><code>fcntl</code> - йобо-функция, которая принимает кучу различных флагов и
позволяет делать почти все, что могут делать прочие функции:
ставить всевозможные флаги, лочить/анлочить, и еще дохера всякой
ненужной и advanced херни. Также, в отличие от <code>flock</code>, ей можно
делать <code>lock</code> только части файла.
</li>

<li><code>flock</code> - залочить файл за процессом. Известная фигня - нам нужно,
чтобы только мы писали/читали из файла/в файл. Лок бывает shared и
exclusive - соответственно, "много процессов читают" и "один
процесс читает и пишет". При попытке обращения к файлу прочие будут
получать access denied, НО! Лок на файл не является строго
обязательным. То есть, мало что мешает какому-то другому процессу
что-то делать с залоченным файлом, если тот очень захочет.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> <span class="todo 1">1</span> Ticket 7    Drivers/ints</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> <span class="todo 2">2</span> Драйвера устройств в пространстве ядра</h3>
<div class="outline-text-3" id="text-9-1">
<p>
Драйвер &#x2013; это такой кусок кода, который соответствует некоторому
заданному интерфейсу. Ты его короче пишешь, потом компилируешь и
запихиваешь с помощью <code>insmod/rmmod</code> в ядро, которое может делать
это в рантайме.
</p>

<p>
Для каждого вида девайса (<code>block/character/packet</code>) указывается
свой набор функций. Кроме того, нужно поимплементить <code>ioctl
   handler</code>.  sources:
</p>
<ol class="org-ol">
<li>Как сделать свой маленький драйвер:
<a href="http://www.freesoftwaremagazine.com/articles/drivers_linux">http://www.freesoftwaremagazine.com/articles/drivers_linux</a>
</li>
<li>И еще:
<a href="http://www.unitedthc.com/ELS/LinuxDriver.pdf">http://www.unitedthc.com/ELS/LinuxDriver.pdf</a>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> <span class="todo 2">2</span> Прерывания</h3>
<div class="outline-text-3" id="text-9-2">
<p>
<b>Прерывания</b> &#x2013; это такой способ сказать что-то ядру. Прерывания
делятся на хардварные и софтварные. Процессор их обрабатывает с
помощью хендлеров, которые BIOS/OS выставляет в особой таблице
прерывний при буте.
</p>
<ol class="org-ol">
<li><b>Хардварные</b> прерывания &#x2013; на ногу процессору приходит сигнал и он
что-то делает. Это какие-нибудь <code>divideByZero</code>.
</li>
<li><b>Софтварные</b> прерывания &#x2013; могут быть вызваны из кода. Все
системные вызовы реализуются через софт. прерывание (в rax
кладется дата о том, что нужно вызвать, потом вызывается int
0x80 &#x2013; UNIX).
</li>
</ol>

<p>
Стоит короче около процессора железяка, называющаяся <b>контроллером
прерываний</b> (<i>programmable interrupt controller</i>), который
прерывания менеджит прежде чем тыкать процессор. Профиты
более-менее очевидны &#x2013; более умный хендлинг, можно какие-то
прерыавния сортить по приоритетам и т.д. Прерывания можно
маскировать &#x2013; в контроллере прерываний кроме таблицы есть еще и
маска, по которой приходящие прерывания игнорируются или отмечаются
как pending.
</p>
</div>
</div>
<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3"><span class="section-number-3">9.3</span> <span class="todo 2">2</span> Монолитная обработка прерываний</h3>
<div class="outline-text-3" id="text-9-3">
<p>
Самый простой и наивный способ обрабатывать интеррапты &#x2013; это вот
наш наивный kernel. Как только пришло прерывание, обработаем
его. Все.
</p>

<p>
Более подробно &#x2013; наивный kernel должен читаться где-то в raw,
может потом сюда его TODO.
</p>

<p>
С другой стороны, может иметься в виду тот факт, что монолитно &#x2013;
запрещать прерывания в прерываниях.
</p>
</div>
</div>
<div id="outline-container-sec-9-4" class="outline-3">
<h3 id="sec-9-4"><span class="section-number-3">9.4</span> <span class="todo 2">2</span> Hi/Lo прерывания</h3>
<div class="outline-text-3" id="text-9-4">
<p>
Прерывания деляться на High и Low по приоритету. Действительно,
есть интеррапты, которые нельзя откладывать &#x2013; например, чтение из
сетевой карты (буфер переполниться, и данные будут выпадать).
</p>

<p>
Есть два принипиально разных подхода обработки прерываний
(железно):
</p>
<ol class="org-ol">
<li><b>Level triggered</b> interrupts: железка которая хочет послать
проецссору интеррапт, выставляет напряжение на линии и держит
его, пока процессор не сделает с этим что-нибудь.

<p>
Плюс &#x2013; процессор не имеет проблем с пониманием, какие девайсы
послали интеррапт &#x2013; если больше одного устройства разделяет
interrupt line, он опрашивает всех на этой линии.
</p>

<p>
Из минусов: непонятно, что делать, если устройство поставило
один интеррапт, а потом поменяло его на другой.
</p>
</li>
<li><b>Edge-triggered</b> interrupts: устройство которое хочет послать
интеррапт, посылает короткий импульс по ноге, сразу потом
прекращая. Иногда необходимо специальное железо чтобы улавливать
слишком короткие сигналы.

<p>
Такие интеррапты не имеют недостатков level-triggered. Можно
пропускать интеррапты, которые не особо важны, и мы не будем
терять важные. С другой стороны, если нет никакого железа,
которое запоминает интеррапты, можно легко пропустить такой
интеррапт, если он замаскирован.
</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-9-5" class="outline-3">
<h3 id="sec-9-5"><span class="section-number-3">9.5</span> <span class="todo 2">2</span> Polling</h3>
<div class="outline-text-3" id="text-9-5">
<p>
Общее понимание &#x2013; polling это алгоритм опрашивание переферийных
устройств на какие-либо их действия.
<a href="https://en.wikipedia.org/wiki/Polling_(computer_science)">https://en.wikipedia.org/wiki/Polling_(computer_science)</a>
</p>
</div>
</div>
<div id="outline-container-sec-9-6" class="outline-3">
<h3 id="sec-9-6"><span class="section-number-3">9.6</span> <span class="todo X">X</span> Драйвера как контексты исполнения и их отличия от процессов</h3>
<div class="outline-text-3" id="text-9-6">
<p>
???
</p>
</div>
</div>
<div id="outline-container-sec-9-7" class="outline-3">
<h3 id="sec-9-7"><span class="section-number-3">9.7</span> <span class="todo 2">2</span> Реализация драйверов: структуры данных ядра</h3>
<div class="outline-text-3" id="text-9-7">
<p>
<code>Block/char</code> девайсы работают через стандартный file интерфейс, в
то время как у network девайсов свой network-specific API. Каждый
драйвер должен зарегестрироваться в ядре с помощью специального
вызова и сруктуры, причем предоставить нужный интерфейс.
</p>
<ol class="org-ol">
<li>Character devices:
Должно инстанциировать <code>cdev</code> структуру и имплементить
<code>file_operations</code>.
</li>
<li>Block devices:
<code>getdisk</code> структура и <code>block_device_operations</code> интерфейс (+ еще
<code>make_request</code> функция).
</li>
<li>Network devices:
<code>net_device</code> структура, <code>net_device_ops</code> интерфейс.
</li>
</ol>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">file_operations</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span><span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">module</span><span style="color: #333333;"> </span>*<span style="color: #A197BF;">owner</span>;
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">loff_t</span><span style="color: #333333;"> </span>(*<span style="color: #8AAFFA;">llseek</span>)<span style="color: #333333;"> </span>(<span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">file</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">loff_t</span>,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span>);
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">ssize_t</span><span style="color: #333333;"> </span>(*<span style="color: #8AAFFA;">read</span>)<span style="color: #333333;"> </span>(<span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">file</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">char</span><span style="color: #333333;"> </span><span style="color: #A197BF;">__user</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">size_t</span>,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">loff_t</span><span style="color: #333333;"> </span>*);
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">ssize_t</span><span style="color: #333333;"> </span>(*<span style="color: #8AAFFA;">write</span>)<span style="color: #333333;"> </span>(<span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">file</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #FFA070;">const</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">char</span><span style="color: #333333;"> </span><span style="color: #A197BF;">__user</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">size_t</span>,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">loff_t</span><span style="color: #333333;"> </span>*);
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">ssize_t</span><span style="color: #333333;"> </span>(*<span style="color: #8AAFFA;">aio_read</span>)<span style="color: #333333;"> </span>(<span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">kiocb</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #FFA070;">const</span><span style="color: #333333;"> </span><span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">iovec</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">unsigned</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">long</span>,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">loff_t</span>);
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">ssize_t</span><span style="color: #333333;"> </span>(*<span style="color: #8AAFFA;">aio_write</span>)<span style="color: #333333;"> </span>(<span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">kiocb</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #FFA070;">const</span><span style="color: #333333;"> </span><span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">iovec</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">unsigned</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">long</span>,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">loff_t</span>);
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span>(*<span style="color: #8AAFFA;">readdir</span>)<span style="color: #333333;"> </span>(<span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">file</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">void</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">filldir_t</span>);
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">unsigned</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span>(*<span style="color: #8AAFFA;">poll</span>)<span style="color: #333333;"> </span>(<span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">file</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">poll_table_struct</span><span style="color: #333333;"> </span>*);
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span>(*<span style="color: #8AAFFA;">ioctl</span>)<span style="color: #333333;"> </span>(<span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">inode</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">file</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">unsigned</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span>,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">unsigned</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">long</span>);
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span>(*<span style="color: #8AAFFA;">mmap</span>)<span style="color: #333333;"> </span>(<span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">file</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">vm_area_struct</span><span style="color: #333333;"> </span>*);
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span>(*<span style="color: #8AAFFA;">open</span>)<span style="color: #333333;"> </span>(<span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">inode</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">file</span><span style="color: #333333;"> </span>*);
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span>(*<span style="color: #8AAFFA;">flush</span>)<span style="color: #333333;"> </span>(<span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">file</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">fl_owner_t</span><span style="color: #333333;"> </span><span style="color: #A197BF;">id</span>);
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span>(*<span style="color: #8AAFFA;">release</span>)<span style="color: #333333;"> </span>(<span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">inode</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">file</span><span style="color: #333333;"> </span>*);
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span>(*<span style="color: #8AAFFA;">fsync</span>)<span style="color: #333333;"> </span>(<span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">file</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">dentry</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span><span style="color: #A197BF;">datasync</span>);
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span>(*<span style="color: #8AAFFA;">fasync</span>)<span style="color: #333333;"> </span>(<span style="color: #EF5C5F;">int</span>,<span style="color: #333333;"> </span><span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">file</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span>);
<span style="color: #333333;">    </span><span style="color: #EF5C5F;">int</span><span style="color: #333333;"> </span>(*<span style="color: #8AAFFA;">flock</span>)<span style="color: #333333;"> </span>(<span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">file</span><span style="color: #333333;"> </span>*,<span style="color: #333333;"> </span><span style="color: #EF5C5F;">int</span>,<span style="color: #333333;"> </span><span style="color: #FFA070;">struct</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">file_lock</span><span style="color: #333333;"> </span>*);
<span style="color: #333333;">    </span>[...]
};
</pre>
</div>

<p>
Source:
</p>
<ul class="org-ul">
<li><a href="http://thomas.enix.org/pub/conf/rmll2010/kernel-architecture-for-drivers.pdf">http://thomas.enix.org/pub/conf/rmll2010/kernel-architecture-for-drivers.pdf</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-8" class="outline-3">
<h3 id="sec-9-8"><span class="section-number-3">9.8</span> <span class="todo X">X</span> Различные методы реализации CPS-преобразования</h3>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> <span class="todo 2">2</span> Ticket 8    FS 2</h2>
<div class="outline-text-2" id="text-10">
</div><div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1"><span class="section-number-3">10.1</span> <span class="todo 1">1</span> Файловые системы</h3>
<div class="outline-text-3" id="text-10-1">
<p>
Файловые системы - это структуры данных на диске, позволяющие
оперировать норм данными.
</p>

<p>
Обычно реализуются в виде b-tree или чего-то такого. В linux все
файлы - это <code>inode</code>.
</p>

<p>
По типу: раньше все файловые системы были плоские, то есть все
файлы лежали в корне. Сейчас почти все древовидные. Есть еще
реляционные (как в базах данных).
</p>
</div>
</div>
<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2"><span class="section-number-3">10.2</span> <span class="todo 2">2</span> Структура данных inode</h3>
<div class="outline-text-3" id="text-10-2">
<p>
Inode - структурка, которая содержит в себе информацию о файле.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #EF5C5F;">Inode</span><span style="color: #333333;"> </span><span style="color: #A197BF;">=</span><span style="color: #333333;"> </span>{
<span style="color: #333333;">    </span>permissions<span style="color: #333333;"> </span><span style="color: #A197BF;">::</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Permissions</span><span style="color: #A197BF;">,</span>
<span style="color: #333333;">    </span>owner<span style="color: #333333;"> </span><span style="color: #A197BF;">::</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">UID</span><span style="color: #A197BF;">,</span>
<span style="color: #333333;">    </span>group<span style="color: #333333;"> </span><span style="color: #A197BF;">::</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">GID</span><span style="color: #A197BF;">,</span>
<span style="color: #333333;">    </span>size<span style="color: #333333;">  </span><span style="color: #A197BF;">::</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Int</span><span style="color: #A197BF;">,</span>
<span style="color: #333333;">    </span>links<span style="color: #333333;"> </span><span style="color: #A197BF;">::</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Int</span><span style="color: #A197BF;">,</span>
<span style="color: #333333;">    </span>lastAccessed<span style="color: #333333;"> </span><span style="color: #A197BF;">::</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Datetime</span><span style="color: #A197BF;">,</span>
<span style="color: #333333;">    </span>lastModified<span style="color: #333333;"> </span><span style="color: #A197BF;">::</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Datetime</span><span style="color: #A197BF;">,</span><span style="color: #333333;">    </span><span style="color: #637579;">--</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1082;&#1086;&#1075;&#1076;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1089;&#1072;&#1084;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1076;&#1072;&#1085;&#1085;&#1099;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1092;&#1072;&#1081;&#1083;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1084;&#1077;&#1085;&#1103;&#1083;&#1080;&#1089;&#1100;</span>
<span style="color: #333333;">    </span>inodeModified<span style="color: #333333;"> </span><span style="color: #A197BF;">::</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Datetime</span><span style="color: #A197BF;">,</span><span style="color: #333333;">   </span><span style="color: #637579;">--</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1082;&#1086;&#1075;&#1076;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">inode</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1084;&#1077;&#1085;&#1103;&#1083;&#1089;&#1103;</span><span style="color: #333333;"> </span><span style="color: #637579;">(&#1087;&#1088;&#1072;&#1074;&#1072;,</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1085;&#1072;&#1087;&#1088;&#1080;&#1084;&#1077;&#1088;)</span>
<span style="color: #333333;">    </span><span style="color: #FFA070;">data</span><span style="color: #333333;"> </span><span style="color: #A197BF;">::</span><span style="color: #333333;"> </span><span style="color: #EF5C5F;">Vector</span>[13]<span style="color: #333333;"> </span>void<span style="color: #A197BF;">*</span><span style="color: #333333;">     </span><span style="color: #637579;">--</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1091;&#1082;&#1072;&#1079;&#1072;&#1090;&#1077;&#1083;&#1080;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1085;&#1072;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1076;&#1072;&#1085;&#1085;&#1099;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1092;&#1072;&#1081;&#1083;&#1072;,</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1086;&#1090;&#1084;&#1072;&#1087;&#1083;&#1077;&#1085;&#1085;&#1099;&#1077;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1074;</span><span style="color: #333333;"> </span><span style="color: #637579;">&#1087;&#1072;&#1084;&#1103;&#1090;&#1100;</span>
}
</pre>
</div>

<p>
Разные специальные <code>inode</code> (например, дисковые файлы) также содержат
всякую другую инфу, типа местоположения на диске там, <code>id</code> девайса.
</p>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Inode_pointer_structure">https://en.wikipedia.org/wiki/Inode_pointer_structure</a>
</li>
<li><a href="http://www.grymoire.com/Unix/Inodes.html">http://www.grymoire.com/Unix/Inodes.html</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-3" class="outline-3">
<h3 id="sec-10-3"><span class="section-number-3">10.3</span> <span class="todo 2">2</span> VFS</h3>
<div class="outline-text-3" id="text-10-3">
<p>
<b>VFS</b> (<i>virtual file system</i>) &#x2013; такой стандартный интерфейс думать
о разных файловых системах как об одной.
</p>

<p>
Суть проста: нам надо объединить всевозможные файловые системы
(различные - на диске, всякие виртуальные типа <code>/dev</code>, <code>/proc</code>) одним
интерфейсом.
</p>

<p>
Делается это так: на каждую файловую систему/устройство/че там еще
скрывается за VFS есть свой драйвер, который предоставляет
реализацию интерфейса VFS для себя.
</p>

<p>
Когда идет какой-то системный вызов по чтению/писанию/чему-то еще
по некоторому файловому дескриптору, ядро выясняет, кто из
драйверов ответственнен за него, и дергает его реализацию. Что
сделает драйвер - его дело: часто он инициализирует DMA-передачу
данных.
</p>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="http://www.slideshare.net/divyekapoor/linux-kernel-implementation-of-pipes-and-fifos">http://www.slideshare.net/divyekapoor/linux-kernel-implementation-of-pipes-and-fifos</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-4" class="outline-3">
<h3 id="sec-10-4"><span class="section-number-3">10.4</span> <span class="todo 1">1</span> Структуры данных: FSObject, Namespace</h3>
<div class="outline-text-3" id="text-10-4">
<ul class="org-ul">
<li>FSObject &#x2013; ну видимо значит тип данных файловой системы)))
</li>
<li>Namespace &#x2013; набор строчек и точек монтирования для текущего
процесса. Определяет, как выглядит файловая система.
</li>
<li>Маунтпоинт &#x2013; это привязка определенного куска файловой системы к
девайсу.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-text">Mountpoint = (FS, inodenoroot)
Namespace = [(Path, Mountpoint)]
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-10-5" class="outline-3">
<h3 id="sec-10-5"><span class="section-number-3">10.5</span> <span class="todo 2">2</span> Path resolution</h3>
<div class="outline-text-3" id="text-10-5">
<p>
Есть пути такого вида: <code>/aaa/bbb/ccc</code>. В каждой директории есть <code>.</code>
и <code>..</code> &#x2013; ссылки на себя и родительскую директорию. За корень выйти
нельзя: <code>/.. ≡ /</code>. Собственно, задача path resolution'а сводится к
банальному разбиению строчки по слэшам и нужным переходам.
</p>
</div>
</div>
<div id="outline-container-sec-10-6" class="outline-3">
<h3 id="sec-10-6"><span class="section-number-3">10.6</span> <span class="todo 2">2</span> Операции над namespace: mount, bind mount, move mount, chroot, pivot<sub>root</sub></h3>
<div class="outline-text-3" id="text-10-6">
<ul class="org-ul">
<li><code>mount</code> - монтирует файловую систему (добавляет запись в
Namespace).
</li>
<li><code>bind mount</code> - подмонтировать что-то уже примонтированное куда-то
еще.
</li>
<li><code>move mount</code> - подмонтировать fs по другому пути.
</li>
<li><code>chroot</code> - сменить корень namespace-а.
</li>
<li><code>pivot_root</code> - переподвесить корень: сделать корнем какого-то
ребенка, а текущий корень подвесить в его поддерево.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-7" class="outline-3">
<h3 id="sec-10-7"><span class="section-number-3">10.7</span> <span class="done 3">3</span> Linux FUSE</h3>
<div class="outline-text-3" id="text-10-7">
<p>
<b>FUSE</b> (<i>filesystem in userspace</i>) &#x2013; механизм, позволяющий
создавать свои собственные системы в userspace.
</p>

<p>
Это клево, потому что программы теперь могут использовать
файлосистемный интерфейс. Пример: какой-нибудь плеер lastfm делает
себе папочку с альбомчиками, чтобы музло слушать как файл, а на
самом деле - слушаем онлайн!
</p>
</div>
</div>
<div id="outline-container-sec-10-8" class="outline-3">
<h3 id="sec-10-8"><span class="section-number-3">10.8</span> <span class="todo 0">0</span> ФС как функция inodeno -&gt; inode</h3>
<div class="outline-text-3" id="text-10-8">
<p>
??? spurdo spardo :-DDD
</p>
</div>
</div>
<div id="outline-container-sec-10-9" class="outline-3">
<h3 id="sec-10-9"><span class="section-number-3">10.9</span> <span class="todo 1">1</span> Структуры ядра: файловый дескриптор (на устройство, файл, директорию), различные кэши, mmaping файлов.</h3>
<div class="outline-text-3" id="text-10-9">
<p>
Файловый дескриптор уже обсуждали.
</p>

<p>
Устройство: есть major (категория устройств) и minor (номер
устройства) номера, определяющие драйвер для устройства.
</p>

<p>
Файл: позиция в файле, даты изменения.
</p>

<p>
Директория: номер айноды, хэшмап из имен в айноды.
</p>
</div>
</div>
<div id="outline-container-sec-10-10" class="outline-3">
<h3 id="sec-10-10"><span class="section-number-3">10.10</span> <span class="todo 1">1</span> Кеши, mmapping</h3>
<div class="outline-text-3" id="text-10-10">
<p>
Есть open-кэш &#x2013; это типа чтобы долго имена не резолвить.
</p>

<p>
<code>mmap</code> - супер-универсальный механизм чтения файлов; как ни странно,
read реализован именно им! (сам mmap мы уже обсуждали).
</p>
</div>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> <span class="todo 2">2</span> Ticket 9    Users/access</h2>
<div class="outline-text-2" id="text-11">
</div><div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1"><span class="section-number-3">11.1</span> <span class="todo 2">2</span> Пользователи и права</h3>
<div class="outline-text-3" id="text-11-1">
<p>
Пользователь &#x2013; кто-то, кто пользуется компьютером. У него есть имя
и группа. А также, может быть, пароль. Юзер может владеть
некоторыми объектами файловой системы в разной мере.
</p>
</div>
</div>
<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2"><span class="section-number-3">11.2</span> <span class="todo 2">2</span> Модели прав доступа к объектам: дискретная и ролевая</h3>
<div class="outline-text-3" id="text-11-2">
<p>
Дискретная модель &#x2013; табличная (ну как есть, для каждого явно
определено, что ему можно, что нельзя). Такая модель используется в
linux.
</p>

<p>
Ролевая модель - у юзеров есть уровни привилегий, и данные могут
течь снизу вверх, но не сверху вниз. Более древовидная абстракция.
</p>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%91%D0%B5%D0%BB%D0%BB%D0%B0_%E2%80%94_%D0%9B%D0%B0%D0%BF%D0%B0%D0%B4%D1%83%D0%BB%D1%8B">https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%91%D0%B5%D0%BB%D0%BB%D0%B0_%E2%80%94_%D0%9B%D0%B0%D0%BF%D0%B0%D0%B4%D1%83%D0%BB%D1%8B</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-11-3" class="outline-3">
<h3 id="sec-11-3"><span class="section-number-3">11.3</span> <span class="todo 2">2</span> Права на объекты файловой системы</h3>
<div class="outline-text-3" id="text-11-3">
<p>
Права устроены так:
</p>
<ul class="org-ul">
<li>Каждый <code>inode</code> имеет владельца и группу. Также он имеет 3 числа:
права для владельца, для группы и для остальных.
</li>
<li>Числа от 0 до 7, либо <code>rwxrwxrwx</code> (read, write, execute).
</li>
<li>Права меняются командой <code>chmod</code>, владелец - командой <code>chown</code>,
группа &#x2013; командой <code>chgrp</code>.
</li>
</ul>

<p>
Sources:
</p>
<ul class="org-ul">
<li><code>chmod(1)</code>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-11-4" class="outline-3">
<h3 id="sec-11-4"><span class="section-number-3">11.4</span> <span class="todo 1">1</span> Пользователи и группы с точки зрения ядра</h3>
<div class="outline-text-3" id="text-11-4">
<p>
С точки зрения ядра, пользователи &#x2013; какие-то неадекваты, которые
хотят все испортить, поэтому нужно им все запрещать.
</p>

<p>
Source:
</p>
<ul class="org-ul">
<li><a href="http://www.cs.fsu.edu/~baker/devices/lxr/http/source/linux/kernel/user.c">http://www.cs.fsu.edu/~baker/devices/lxr/http/source/linux/kernel/user.c</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-11-5" class="outline-3">
<h3 id="sec-11-5"><span class="section-number-3">11.5</span> <span class="todo 1">1</span> Пользователи и группы с точки зрения пространства пользователя</h3>
<div class="outline-text-3" id="text-11-5">
<p>
Всем пацанам можно, а мне нельзя?!
</p>
</div>
</div>
<div id="outline-container-sec-11-6" class="outline-3">
<h3 id="sec-11-6"><span class="section-number-3">11.6</span> <span class="todo 1">1</span> Системные вызовы setuid, setgid и товарищи</h3>
<div class="outline-text-3" id="text-11-6">
<ul class="org-ul">
<li><code>setuid</code> - переназначить процесс на определенного
пользователя. Работает только тогда, когда мы <code>root</code> или этот
самый юзер.
</li>
<li><code>setgid</code> - то же для группы.
</li>
</ul>

<p>
Еще есть геттеры: <code>getgid</code>, <code>getuid</code>.
</p>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Setuid">https://en.wikipedia.org/wiki/Setuid</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-11-7" class="outline-3">
<h3 id="sec-11-7"><span class="section-number-3">11.7</span> <span class="todo 1">1</span> setuid bit</h3>
<div class="outline-text-3" id="text-11-7">
<p>
Это короче такой флажок в <code>inode</code>, который позволяет запускать что-то
с повышенными правами (от юзера поважнее).
</p>

<p>
Пример: ВНЕЗАПНО <code>ping</code>: обычный юзер не имеет права посылать и
принимать контрольные сетевые пакеты!
</p>

<p>
У него есть братишка - <code>setgid bit</code>.
</p>

<p>
Когда они выставлены на директории, они наследуются всеми
впоследствии созданными в этой директории файлами и поддиректориями.
</p>
</div>
</div>
<div id="outline-container-sec-11-8" class="outline-3">
<h3 id="sec-11-8"><span class="section-number-3">11.8</span> PAM</h3>
<div class="outline-text-3" id="text-11-8">
<p>
<b>PAM</b> (<i>pluggable authentication module</i>) &#x2013; большая и классная
либа для аутентификации. Объединяет в себе разные механизмы, можно
с ее помощью по отпечатку пальца аутентифицироваться там, все
такое.
</p>

<p>
Ей щас все пользуются. Однако есть еще <code>nsswitch</code>, который также
может менеджить пароли, и если их включить вместе, может получиться
смешно.
</p>
</div>
</div>
<div id="outline-container-sec-11-9" class="outline-3">
<h3 id="sec-11-9"><span class="section-number-3">11.9</span> /etc/passwd, /etc/shadow, /etc/group</h3>
<div class="outline-text-3" id="text-11-9">
<p>
<code>/etc/passwd</code> &#x2013; файл, который содержит информацию о юзерах. Там
имя, id, группа, комментарий, путь к домашней папке и путь к
логин-шеллу (для юзеров-демонов - это какой-нибудь
<code>/bin/false</code>). Когда-то здесь хранился и пароль, но это супер
несекьюрно, поэтому хэши паролей хранятся в отдельном файле
<code>shadow</code>.
</p>

<p>
<code>/etc/shadow</code> &#x2013; это доступный только руту файл с хэшами паролей
для всех пользователей. Отдельно от <code>passwd</code>, потому что какая-то
инфа о юзере часто требуется всяким нерутовым программам, и если
доступ к <code>passwd</code> запретить, это все сломает.
</p>

<p>
<code>/etc/groups</code> - просто список групп с айдишниками.
</p>
</div>
</div>
<div id="outline-container-sec-11-10" class="outline-3">
<h3 id="sec-11-10"><span class="section-number-3">11.10</span> Capabilities.</h3>
<div class="outline-text-3" id="text-11-10">
<p>
<b>Capabilities</b> - более модная и гибкая система прав, появившаяся с
Linux 2.2. Это разбиение всех прав суперпользователя на набор
небольших разрешений, которые можно в любом порядке комбинировать и
назначать процессу. Также мы можем навешивать capabilities
исполняемым файлам, по аналогии с <code>setuid</code> флагом.
</p>

<p>
Source:
</p>
<ul class="org-ul">
<li><a href="http://unixhelp.ed.ac.uk/CGI/man-cgi?capabilities+7">http://unixhelp.ed.ac.uk/CGI/man-cgi?capabilities+7</a>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> <span class="done 3">3</span> Ticket 10   Signals</h2>
<div class="outline-text-2" id="text-12">
</div><div id="outline-container-sec-12-1" class="outline-3">
<h3 id="sec-12-1"><span class="section-number-3">12.1</span> <span class="done 3">3</span> Стандартные сигналы</h3>
<div class="outline-text-3" id="text-12-1">
<p>
Сигналы &#x2013; это некоторый высокоуровневый аналог прерываний, который
хендлится ядром, а не процессором.
</p>

<p>
Стандартные сигналы все есть в <code>signal(7)</code>.
</p>

<p>
У каждого сигнала есть стандартные хендлеры, которые можно
определять. Хендлеры уникальны для процессов, но общие у тредов.
</p>

<p>
Сигналы можно маскировать, маска &#x2013; набор битов, которые указывают,
какие сигналы следует складывать в очередь и не вызывать на них
хендлеры.
</p>

<p>
Это не относится к <code>SIGKILL</code>, <code>SIGSTOP</code>, они не маскируются.
</p>

<p>
Сигнал назыавется <code>pending</code> если его можно достать, блокирующийся
сигнал &#x2013; сигнал, у которого в маске 1.
</p>

<p>
Когда обычные сигналы приходят в количестве больше одного, то вообще остается только один.
</p>
</div>
</div>
<div id="outline-container-sec-12-2" class="outline-3">
<h3 id="sec-12-2"><span class="section-number-3">12.2</span> <span class="done 3">3</span> Реалтаймовые сигналы</h3>
<div class="outline-text-3" id="text-12-2">
<p>
Реалтаймовые сигналы &#x2013; модные новые (с 2.2) сигналы для
синхронизации тредов.
</p>

<p>
У них много плюсов:
</p>
<ul class="org-ul">
<li>Можно блочить больше одного сигнала, в отличии от обычных.
</li>
<li>Вместе с сигналом можно передавать немного данных (указатель/int).
</li>
<li>Порядок доставки гарантируется.
</li>
</ul>

<p>
Если приходят одновременно и обычные, и реалтаймовые, то сначала
выпадают обычные (linux), но по POSIX в общем случае этот порядок
не зафиксирован.
</p>
</div>
</div>
<div id="outline-container-sec-12-3" class="outline-3">
<h3 id="sec-12-3"><span class="section-number-3">12.3</span> <span class="done 3">3</span> Системные вызовы kill, sigaction.</h3>
<div class="outline-text-3" id="text-12-3">
<p>
Понятно, вызывают сигналы. Sigaction оперирует хендлерами.
</p>
</div>
</div>
<div id="outline-container-sec-12-4" class="outline-3">
<h3 id="sec-12-4"><span class="section-number-3">12.4</span> <span class="done 3">3</span> Прерывание сигналами: кода программы, обработчиков сигналов, системных вызовов</h3>
<div class="outline-text-3" id="text-12-4">
<p>
Рассмотрим стандартные сигналы, которые мы умеем хендлить.
</p>

<p>
Есть проблема с сигналом, пока мы находимся в хендлере. Поэтому все
системные вызовы делятся на 3 категории:
</p>
<ol class="org-ol">
<li><code>atomic</code> &#x2013; не прерываются сигналом. Например, <code>date</code>.
</li>
<li><code>interruptable</code> &#x2013; могут быть прерваны сигналом EINTR. Пример:
sleep, epoll.
</li>
<li><code>restartable</code> &#x2013; после сигнала восстанавливаются внутри кода и
работают коррректно. Пример: <code>read/write</code>.
</li>
</ol>

<p>
Какие вызовы системные как обрабатываются, зависит от вызова и
флага <code>SA_RESTART</code> на хендлере сигнала. Есть ряд вызовов, для которых
<code>SA_RESTART</code> решает, будет ли вызов прерван, или нет.
</p>

<p>
Если же сигнал <code>SIGSTOP</code>, то когда мы выйдем из суспенда, системный
вызов упадет с <code>EINTR</code>.
</p>

<p>
Sources:
</p>
<ul class="org-ul">
<li><code>signal(7)</code>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12-5" class="outline-3">
<h3 id="sec-12-5"><span class="section-number-3">12.5</span> <span class="done 3">3</span> Сигналы и треды</h3>
<div class="outline-text-3" id="text-12-5">
<p>
Сигналы деляться на <code>process-oriented</code> (<code>kill(2)</code>), и
<code>thread-oriented</code> (<code>pthread_kill(2)</code>).
</p>
<ol class="org-ol">
<li><b>Process-oriented</b>. Есть процесс и группа тредов. У тредов
раздельные маски. Сигнал приходит кому-то (не определено), у
кого не заблочена маска.  Если заблочена у всех &#x2013; становится в
общую очередь процесса. Если нету маски и дефолтное действие &#x2013;
terminate, убивается весь процесс.
</li>
<li><b>Thread-oriented</b>. Сигнал отправляется конкретному треду, будет
обработан или замаскирован для конкретного треда. Если нет
хендлера и стандартное действие terminate, убивается процесс.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-12-6" class="outline-3">
<h3 id="sec-12-6"><span class="section-number-3">12.6</span> <span class="done 3">3</span> Семантика сигналов: TERM, KILL, STOP, CONT, CHLD, PIPE, ILL/FPE, SEGV, BUS.</h3>
<div class="outline-text-3" id="text-12-6">
<p>
Use <code>man signal</code>!
</p>
<ul class="org-ul">
<li><code>PIPE</code> &#x2013; write to pipe with no readers
</li>
<li><code>ILL/FPE</code> &#x2013; illegal instruction/floating point exception
</li>
<li><code>BUS</code> &#x2013; Bus error (memory error)
Отличие от <code>SEGV</code>:
<ul class="org-ul">
<li><code>SEGV</code>: address not mapped to object, invalid permissions for
mapped object.
</li>
<li><code>BUS</code>: invalid address alignment, non-existent physical
address, object specific hardware error.
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13"><span class="section-number-2">13</span> <span class="todo 0">0</span> Ticket 11   Polling</h2>
<div class="outline-text-2" id="text-13">
<p>
Этот билет пуст. TODO.
</p>
</div>
<div id="outline-container-sec-13-1" class="outline-3">
<h3 id="sec-13-1"><span class="section-number-3">13.1</span> Мултиплексирование ввода-вывода</h3>
</div>
<div id="outline-container-sec-13-2" class="outline-3">
<h3 id="sec-13-2"><span class="section-number-3">13.2</span> O<sub>NONBLOCK</sub></h3>
</div>
<div id="outline-container-sec-13-3" class="outline-3">
<h3 id="sec-13-3"><span class="section-number-3">13.3</span> Edge и level triggered события</h3>
</div>
<div id="outline-container-sec-13-4" class="outline-3">
<h3 id="sec-13-4"><span class="section-number-3">13.4</span> Преобразование асинхронного ввода-вывода в синхронный CPS-преобразованием</h3>
</div>
<div id="outline-container-sec-13-5" class="outline-3">
<h3 id="sec-13-5"><span class="section-number-3">13.5</span> Структуры данных пространства ядра для реализации мультиплексора файловых дескрипторов</h3>
</div>
<div id="outline-container-sec-13-6" class="outline-3">
<h3 id="sec-13-6"><span class="section-number-3">13.6</span> Системные вызовы select, poll, epoll</h3>
</div>
<div id="outline-container-sec-13-7" class="outline-3">
<h3 id="sec-13-7"><span class="section-number-3">13.7</span> Управление скоростью передачи данных через файловые дескрипторы.</h3>
</div>
</div>
<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14"><span class="section-number-2">14</span> <span class="todo 0">0</span> Ticket 12   Synchronisation</h2>
<div class="outline-text-2" id="text-14">
<p>
Этот билет тоже пуст. TODO.
</p>
</div>
<div id="outline-container-sec-14-1" class="outline-3">
<h3 id="sec-14-1"><span class="section-number-3">14.1</span> Синхронизация</h3>
</div>
<div id="outline-container-sec-14-2" class="outline-3">
<h3 id="sec-14-2"><span class="section-number-3">14.2</span> Спинлоки</h3>
</div>
<div id="outline-container-sec-14-3" class="outline-3">
<h3 id="sec-14-3"><span class="section-number-3">14.3</span> Ядерные семафоры</h3>
</div>
<div id="outline-container-sec-14-4" class="outline-3">
<h3 id="sec-14-4"><span class="section-number-3">14.4</span> Блокировки и лизинги на файлы</h3>
</div>
<div id="outline-container-sec-14-5" class="outline-3">
<h3 id="sec-14-5"><span class="section-number-3">14.5</span> Структуры данных пространства ядра для реализации блокировок и лизингов</h3>
</div>
<div id="outline-container-sec-14-6" class="outline-3">
<h3 id="sec-14-6"><span class="section-number-3">14.6</span> <span class="todo 1">1</span> Системные вызовы: flock, fcntl.</h3>
<div class="outline-text-3" id="text-14-6">
<p>
Смотри тикет 6
</p>
</div>
</div>
</div>
<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15"><span class="section-number-2">15</span> <span class="done 3">3</span> Ticket 13   Netstack</h2>
<div class="outline-text-2" id="text-15">
</div><div id="outline-container-sec-15-1" class="outline-3">
<h3 id="sec-15-1"><span class="section-number-3">15.1</span> <span class="done 3">3</span> Сетевой стек</h3>
<div class="outline-text-3" id="text-15-1">
<p>
Сетевой стек &#x2013; весь набор протоколов необходимых для соединения
компюьтеров друг к другу.
</p>

<p>
<b>OSI</b> &#x2013; один из первых базовых сетевых стеков, который не
допилили. <b>BSD сокеты</b> &#x2013; протокол, который развивался
параллельно. Проблема OSI с их разработкой была в планировке, к
примеру часть разработчиков хотела разрабатывать пакетную передачу
данных (на тот момент новшество), но разработчики из бывшых
телефонных компаниях считали эту затею плохой. До пакетной передачи
соединение обеспечивалось правильным подключением клиентов друг к
другу через свичи.
</p>

<p>
Существует три широко используемых протокола низшего уровня:
MAC(через Ethernet/DSL), PPP, ARP.
</p>

<p>
Первый всем хорошо известен, второй &#x2013; это как раз телефоны, третий
используется для общения между устройствами в сети для обмена
данными необходимыми для других протоколов (IP → MAC).
</p>
</div>
</div>
<div id="outline-container-sec-15-2" class="outline-3">
<h3 id="sec-15-2"><span class="section-number-3">15.2</span> <span class="done 3">3</span> PPP</h3>
<div class="outline-text-3" id="text-15-2">
<p>
<b>Point-to-Point Protocol</b> &#x2013; протокол, который применяется для
соединения двух нодов. Физически используется в телефонии (как
стандартной, так и сотовой), оптических сетях и где угодно.
</p>

<p>
Есть два протокола, похожие на PPP: <b>PPPoE</b>, <b>PPPoA</b> &#x2013; over
Ethernet/over ATM, использующиеся в основном провайдерами чтобы
настраивать доступ клиента к внешнему миру.
</p>

<p>
PPP пользуется протоколом <b>LCP</b> (<i>Link Control</i>) для того, чтобы
установить сессию между узлами (например, пользователем и
провайдером).
</p>

<p>
PPP поддерживает 3 типа аутентификация для разной защиты. PAP
(<i>Password Authentication Protocol</i>) &#x2013; протокол для аутентификации
пользоватьского пароля на выделенном сервере. Это самый менее
секьюрный вариант, пользователь просто отправляет пароль на сервер,
а сервер его верифицирует. Ничего не шифруется.
</p>

<p>
Есть <b>CHAP</b> (<i>Challenge Handshake Authentication</i>), который отсылает
challenge message клиенту на машину, содержащию какую-то рандомную
чушь. Машина клиента зашифровывает это вместе с паролем и
отправляет обратно на сервер, который это отправляет на сервер
аутентификации. Последний зашифровывает challenge с
пользовательским паролем с проверяет наличие в базе. Используется
модель shared secret, чтобы аутентифицировать пользователя.
</p>

<p>
Самый секьюрный вариант &#x2013; <b>EAP</b>, про него много.
</p>

<p>
PPPoE &#x2013; протокол уровня Ethernet, представляющий виртуальное
соединение по PPP. Используется провайдерами, как уже было
сказано. PPPoE discovery, процесс, который соединяет машины,
выглядит так:
</p>
<ol class="org-ol">
<li>Initiation &#x2013; клиент высылает специальный пакет на сервер.
</li>
<li>Offer &#x2013; сервер отвечает другим похожим пакетом.
</li>
<li>Request &#x2013; клиент на основании Offer создает пакет и отсылает на
сервер.
</li>
<li>Confirmation &#x2013; сервер понимает, что клиент живой, выдает
уникальный ID клиенту для PPP сессии и высылает подтверждение
клиенту.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-15-3" class="outline-3">
<h3 id="sec-15-3"><span class="section-number-3">15.3</span> <span class="done 3">3</span> Ethernet</h3>
<div class="outline-text-3" id="text-15-3">
<p>
Самый простой сетевой порт это <b>COM</b>. У него 6 проводов, одна пара
из которых передает данные в одну сторону, пара в другую, еще пара
сигнальная. Двухпроводное решение широко используется, есть
однопроводные, которые очень сложные и непопулярные (чипы в
домофонах!). После установления соединения, по проводу передается
меандр. Проблемы COM-порта в нарушении целостности сигнала из-за
наводки.
</p>

<p>
Ethernet реализован чаще всего в формате <b>UTP</b> (<i>unshielded twisted
pair</i>) &#x2013; много маленьких проводов очень сильно скручены друг между
другом. Сигнал по витой паре задается разницой потенциалов (по 2м
соседним проводам передаются сигналы, а смысл имеет их
разница). Такое решение имеет смысл, потому что любая наводка
одинаково искажает сигнал на двух проводах и разность остается
неизменной. UTP чаще всего в этой стране встречается в формате двух
и четырех пар проводов. Проводов для синхронизации нету, <code>SIGHUB</code>
генерируется по таймауту.
</p>

<p>
Еще есть коаксиальный кабель (тонкий кабель внутри обертки), профит
которого в том, что обертка как-то защищает внутренний кабель от
помех, выступая некой клеткой Фарадея.
</p>

<p>
Сеть по формату Ethernet до 1Гб/c реализуется подключением всех
юзеров к одной общей ethernet-шине. Политика такая: пока кто-то
посылает пакеты, другие молчат. Если есть несколько пользователей,
которые пользуются шиной одновременно, все замолкают на рандомный
интервал времени, потом продолжают. <a href="https://en.wikipedia.org/wiki/Carrier_sense_multiple_access_with_collision_detection">CSMA/CD</a>
</p>

<p>
Сеть с большей скоростью нуждается в различных вспомогательных
машинах, типа хабов. Хаб &#x2013; железяка, которая передает пакеты,
которые ему приходят, на все свои выходы (броадкастит).
</p>

<p>
Есть еще параллельный COM для принтеров, называется
LBT. Параллельные шины плохи, потому что сложно синхронизировать
передачу данных по многим проводам одновременно, учитывая всякие
помехи.
</p>

<p>
Ethernet пакет по стандарту (802.3) состоит из:
</p>
<ol class="org-ol">
<li>Преамбула (какие-то метаданные).
</li>
<li>Header
<ol class="org-ol">
<li>Size of packet (or data). MTU &#x2013; 1500.
</li>
<li>Два MAC-адреса (отправитель и получатель).
</li>
<li>Протокол (ethertype) &#x2013; есть разные форматы ethernet (LLC,
Ethernet II).
</li>
</ol>
</li>
<li>Payload (основные данные).
</li>
<li>CRC (контрольные суммы) всего кроме данных.
</li>
</ol>
<p>
Больше здесь: <a href="https://en.wikipedia.org/wiki/Ethernet_frame">Ethernet Frame</a>.
</p>

<p>
<b>Wifi</b> представляет из себя Ethernet по радио. Есть некоторый
диапазон частот разрешенный для использования wifi-устройствами,
который разделен на поддиапазоны &#x2013; каналы. В разных странах
используются разные диапазоны. Wifi передает синусоиду, все как по
радио, с этими вашими модуляциями.
</p>
</div>
</div>
<div id="outline-container-sec-15-4" class="outline-3">
<h3 id="sec-15-4"><span class="section-number-3">15.4</span> <span class="done 3">3</span> IP</h3>
<div class="outline-text-3" id="text-15-4">
<p>
<b>IP</b> протокол находится на уровне выше и обычно запихивается в
Ethernet. IP пакет содержит флаги, IP адресата/адресанта, данные и
crc для всего кроме данных.
</p>

<p>
Сетевые карты обычно фильтруют пакеты которые ей не принадлежат
(адрес назначения не совпадает с нашим) на уровне MAC, IP пакеты
фильтрует уже ОС. И то и другое поведение может быть изменено с
помощью <a href="https://en.wikipedia.org/wiki/Promiscuous_mode">promiscuous mode</a> опции.
</p>

<p>
<b>Ethernet bonding</b> — это объединение двух или более физических
сетевых интерфейсов в один виртуальный для обеспечения
отказоустойчивости и повышения пропускной способности. Гуглится.
</p>

<p>
IP &#x2013; уникальный идентификатор размером в 4 байта. Подсети бывают
классов A, B и C. Для класса A определена маска <code>255.0.0.0</code>, для B
<code>255.255.0.0</code>, для C <code>255.255.255.0</code>. Кроме того, определены
зарезервированные адреса для сетей:
</p>
<ul class="org-ul">
<li>A: <code>10.0.0.0</code>.
</li>
<li>B: <code>172.16.0.0 -- 172.13.0.0</code>.
</li>
<li>C: <code>192.168.0.0 -- 192.168.255.0</code>.
</li>
</ul>

<p>
Маска подсети &#x2013; число от 0 до 32, означающее количество единичек
перед ноликами в двоичной записи 4-байтового числа. Маска
записывается как IP. <code>24 -- 255.255.255.0</code>, <code>31 --
   255.255.255.255</code>. Первая нотация называется префиксной (CIDR).
</p>

<p>
Работает это следующим образом. Пусть нужно отправить пакет. У
каждого интерфейса в компьютере есть своя маска и IP (<i>ifconfig
-a</i>). ОС выбирает интерфейс, который наиболее близок по маске с ip
с ip адресата (сравниваются and, полагаю). В BSD сокетах это
поведение реализуется, если делать <code>bind(0.0.0.0)</code>. Можно сделать
<code>bind</code> на конкретный интерфейс, и тогда пакеты будут отправляться
ровно куда надо.
</p>

<p>
Ядро хранит таблицу роутинга, которая говорит, какие пакеты в какой
интерфейс пихать (<code>ip r</code>, <code>netstat -rn</code>, <code>route</code>). Есть дефолтный
гейтвей (шлюз по умолчанию), в который отправляются пакеты, если
они не матчатся по другим маскам (<code>default</code> в <code>route</code>).
</p>
</div>
</div>
<div id="outline-container-sec-15-5" class="outline-3">
<h3 id="sec-15-5"><span class="section-number-3">15.5</span> <span class="done 3">3</span> ARP</h3>
<div class="outline-text-3" id="text-15-5">
<p>
Проблема отправки Ethernet-пакетов состоит в том, что нам нужны
MAC-адреса (можно указать <code>MAC broadcast ff:ff:ff:ff:ff:ff</code>). Что
делать, если у нас есть только IP?
</p>

<p>
Если IP адрес не лежит в нашей локальной сети, то все просто - мы
знаем MAC-адрес роутера, Ethernet-пакет дойдет до него, роутер его
распакует и отправит дальше куда нужно. Что, если роутера нет - у
нас простая локальная сеть?
</p>

<p>
Для того, чтобы по IP найти MAC, существует протокол <b>ARP</b>. Ядро
содержит ARP-таблицу, которая заполняется по мере необходимости и
отображает IP в MAC (<code>arp -e</code>). Если в таблице нет записи, а нужно
отправить, по сети прогоняется ARP-запрос на уровне "у кого тут
такой ip?", и получает ответ.
</p>

<p>
Обратный протокол получения IP по MAC первоначально назывался
<b>RARP</b> (<i>reversed ARP</i>). Потом он перетек в <b>BOOTP</b>, теперь это
<b>DHCP</b>. Существенная разница RARP и DHCP в том, что DHCP &#x2013;
протокол на уровне TCP/IP, а RARP был на netlink уровне (самом
низком). Зачем DHCP оборачивать в IP &#x2013; никто не знает.
</p>
</div>
</div>
<div id="outline-container-sec-15-6" class="outline-3">
<h3 id="sec-15-6"><span class="section-number-3">15.6</span> <span class="done 3">3</span> Hardware</h3>
<div class="outline-text-3" id="text-15-6">
<ul class="org-ul">
<li><b>Хаб</b> &#x2013; железяка, которая передает пакеты, которые ему приходят,
на все свои выходы (броадкастит).
</li>
<li><b>Свитч</b> &#x2013; это хаб с ARP таблицей внутри, который умеет
отправлять пакеты не всем сразу (как хаб), а только тем, кому
надо, если в ARP-таблице есть необходимая запись.
</li>
<li><b>Маршрутизатор</b> &#x2013; это свитч с таблицей маршрутизации! Конечно,
он тоже имеет ARP, и чаще всего связывает локальную сеть с
внешним миром. В таком случае, обычно, в локальной сети у нодов
дефолтный гейтвей как раз машрутизатор. Сам маршрутизатор
получает свой дефолтный гейтвей обычно от провайдера.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-15-7" class="outline-3">
<h3 id="sec-15-7"><span class="section-number-3">15.7</span> <span class="done 3">3</span> TCP/UDP/SCTP</h3>
<div class="outline-text-3" id="text-15-7">
<p>
Протоколы, которые обычно запихивают в IP: <b>UDP</b>, <b>TCP</b>, <b>SCIP</b>.
</p>
<ol class="org-ol">
<li><b>UDP, TCP</b>: хедеры, в UDP crc берется от хедеров, в TCP от всего
пакета. UDP не обеспечивает никакого механизма проеврки доставки
пакета, в отличии от TCP. TCP/UDP пакеты внутри содержат порт
(<code>/etc/services</code>).  Механизм подключения в TCP похож на
трехкратное рукопожатие:
<ol class="org-ol">
<li>Отправляется запрос 1→2 (syn)
</li>
<li>Отправляется подтверждение о получении запроса 2→1 (syn-ack,
ack = acknowledgment), эта сторона запоминает кому отправила
syn-ack.
</li>
<li>Клиент отправляет 1→2 (ack) еще раз и сервер проверяет,
правда ли, что отправлял клиенту syn-ack. Если да, соединение
установлено.
</li>
</ol>
<p>
Забавное наблюдение заключается в том, что можно много раз
отправлять некоторому набору серверов syn с подмененным ip
возврата, и syn-ack будут возвращаться на желаемый адрес, от
чего желаемому адресу может стать плохо. Еще минус &#x2013; приходится
хранить в сервере данные о том, кому отправил syn-ack.
</p>
</li>
<li><b>SCTP</b> (<i>stream control transport protocol</i>) &#x2013; штука похожая на
TCP, но если среди N пакетов некоторые зафейлились, то только
зафейленные будут отправляться заново (в TCP все начиная с
первого зафейленного). Кроме того, этот протокол подразумевает,
что всякие данные для подключения отправляются клиенту от
сервера зашифрованными и только сервер может их расшифровать,
когда эти же данные ему придут в ack. Отпадает необходимость
помнить о syn-ack которые сервер отправляет.
</li>
</ol>

<p>
<b>IPv6</b> имеет все из коробки внутри. Имеет обратную совместимость с
IPv4, зашитый внутрь MAC. Утверждается, что использование IPv6
избавляет от необходимости использовать NAT и DHCP.
</p>
</div>
</div>
<div id="outline-container-sec-15-8" class="outline-3">
<h3 id="sec-15-8"><span class="section-number-3">15.8</span> <span class="todo 2">2</span> BSD sockets: API, Stream-сокеты, Datagram-сокеты, RAW-сокеты, файловый объект для accept-сокета.</h3>
<div class="outline-text-3" id="text-15-8">
<p>
Read <code>man socket</code>.
</p>

<p>
BSD socket API выглядит примерно так (по всему лучше читать man):
</p>
<ul class="org-ul">
<li><code>socket(...)</code> &#x2013; создать сокет. Тут устанавливаются всякие
параметры, тип сокета (<code>datagram</code> &#x2013; UDP, <code>stream</code> &#x2013; TCP),
другие настройки.
</li>
<li><code>connect(...)</code> &#x2013; создать соединение на сокете. Первоначально
сокет висит в пространстве и ничего не делает, connect его
инициализирует.
</li>
<li><code>bind(...)</code> &#x2013; другой способ инициализации сокета, серверный.
</li>
<li><code>listen(...)</code> &#x2013; обычно следует за bind.
</li>
<li><code>getaddrinfo(...)</code> &#x2013; супер обобщенный вызов, возвращающий данные
о хосте, которые могут быть использованы для создания
сокетов. Прелесть в том, что он удобный и одинаковый для ipv4/v6
сокетов (и еще много чего).
</li>
<li>Далее с сокетами можно обращаться с помощью <code>read/write</code>, но есть
специальные вызовы: <code>send</code>, <code>recv</code>, <code>sendto</code>, <code>recvfrom</code>,
<code>sendmsg</code>, <code>recvmsg</code>. Все они &#x2013; это <code>write/read</code> со специальными
флагами + можно передавать какие-нибдуь допопции + падает если
соединения нет + еще перделки.
</li>
</ul>

<p>
Есть файл <code>/etc/nsswitch.conf</code>. Сервисы типа <code>getaddrinfo</code> пользуются
им чтобы определить откуда искать данные. К примеру, в <code>nsswitch</code>
поле <code>hosts</code> хранит ~"files dns"~, что соответствует <code>/etc/host.conf</code> и
<code>/etc/resolv.conf</code>.
</p>

<p>
Есть демон nscd, который занимается тем, что резолвит запросы
"откуда мне бы почитать". Этот демон первоначально запускается от
рута и как-то связан с ldap, может резолвить пароли. Есть еще PAM,
которой все пользуются (su), и иногда эти сервисы могут
конфликтить.
</p>

<p>
<code>man socket</code> описывает семейства сокетов как IPv4, IPv6, полезно
еще знать про существование <code>AF_UNIX</code>, который используется для
общения ядра самого с собой.  Сокет конкретного семейства имеет
тип.
</p>

<p>
RAW сокеты &#x2013; это уровень IPv4, но сырой, без части
хедеров. Поскольку с такими сокетами можно набагать и застопорить
какую-нибудь очередь IO, они доступны только руту.
</p>
</div>
</div>
<div id="outline-container-sec-15-9" class="outline-3">
<h3 id="sec-15-9"><span class="section-number-3">15.9</span> <span class="done 3">3</span> ICMP, TFTP, DNS, NAT</h3>
<div class="outline-text-3" id="text-15-9">
<p>
<b>ICMP</b> протокол, который завернут в Ethernet, используется для
общения между роутерами, логирования ошибок, для
ping/traceroute. IP пакеты имеют TTL и на каждом hop отправляют
запрос обратно.
</p>

<p>
<b>TFTP</b> &#x2013; UDP-протокол, обеспечивающий наивную реализацию того, что
делает FTP (достань-ка мне тот файл).
</p>

<p>
<b>DNS</b> &#x2013; <code>/etc/resolv.conf</code>. Та самая штука, которая мапит имена в
<code>&lt;host,port&gt;</code>. Самый простой вариант использовать DNS &#x2013;
<code>gethostbyname</code> &#x2013; как раз получает IP по хосту.
</p>

<p>
 DNS пакеты имеют тип и имя. Типы: A(IPv4), AAAA(IPv4), MX(email),
TXT(что угодно). Именем является хост. Ответы бывают рекурсивными и
нет. Рекурсивные ответы возвращают кучу ip-адресов, соответсвтующих
одному хосту (например, сервер распределяется между несколькими
хостами для уменьшения нагрузки).
</p>

<p>
<b>NAT</b> (<i>network address translation</i>): пусть есть локальная сеть и
 мы пользуемся внутри локальной адресацией. Тогда если узел
 отправляет пакет во внешний мир, он проходит через шлюз по
 умолчанию. Устройство, которое имеет адрес шлюза, содержит
 таблицу, которая сохраняет данные о пакетах. Устройство подменяет
 source пакета на свой, и отправляет куда надо. Когда возвращается
 ответ, он перенаправляется юзеру согласно таблице. Существуют
 хаки, которые позволяют отправлять пакеты напрямую. Гуглить
 <code>tsocks</code>, <code>UPnP</code>.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-16" class="outline-2">
<h2 id="sec-16"><span class="section-number-2">16</span> <span class="done 3">3</span> Ticket 14   Terminals/Groups</h2>
<div class="outline-text-2" id="text-16">
</div><div id="outline-container-sec-16-1" class="outline-3">
<h3 id="sec-16-1"><span class="section-number-3">16.1</span> <span class="done 3">3</span> Терминалы, псевдотерминалы и режимы их работы</h3>
<div class="outline-text-3" id="text-16-1">
<p>
Как это было раньше:
</p>
<ol class="org-ol">
<li><b>Line discipling</b> &#x2013; это набор правил для обработки текста.
Различают два мода line discipling:
<ol class="org-ol">
<li><code>raw</code> &#x2013; приложение обрабатывает все сигналы с клавиатуры,
которые ей приходят (так делает vim/emacs/&#x2026;)
</li>
<li><code>cooked</code> &#x2013; приложение получает данные построчно, причем
обработкой строчек перед отправлением (редактирование)
занимается ОС.
</li>
</ol>
</li>
<li><b>TTY driver</b> &#x2013; это драйвер, который занимается кучей разных
вещей, в том числе определяет понятие бэкграундных процессов и
основного, возможности их останавливать и запускать в разных
режимах.
</li>
<li><b>UART</b> (<i>Universal Asynchronous Receiver and Transmitter</i>) &#x2013;
это драйвер операционной системы, который занимается физическим
транслированием байтов, контролем четности битов (parity check)
и прочее.
</li>
</ol>

<p>
<b>TTY</b> &#x2013; это тройка <code>&lt;Line discipline, TTY, UART&gt;</code>.
</p>

<p>
Как работает TTY в древник пека:
</p>

<div class="org-src-container">

<pre class="src src-text">Hardware.......................   Kernel..........................................   Userspace......
Terminal---Physical line---UART---[--UART Driver---Line Discipline---TTY Driver--]---{User Processes}
</pre>
</div>

<p>
Как это работает в POSIX:
</p>

<p>
У нас нет никакого UART. Нет никакого физического терминала, вместо
этого есть видео терминал &#x2013; эмулирующаяся штука, которая содержит
framebuffer &#x2013; виртуальное или реальное устройство, которое хранит
битмапы и умеет выводить их на экран. И этот видео терминал
рендерится в VGA дисплей.
</p>

<div class="org-src-container">

<pre class="src src-text">Hardware.....  Kernel......................................................    Userspace.......
Display&lt;-------VGA Driver&lt;----&#9488;
                            Terminal Emulator--Line Discipline--TTY driver----{User Processes}
Keyboard---&gt;Keyboard driver-&gt;-&#9496;
</pre>
</div>

<p>
Чтобы облегчить себе жизнь, были созданы псевдотерминалы &#x2013;
<code>pty(7)</code>. <b>PTY</b> &#x2013; это пара псевдоустройств, одно из которых (<code>slave</code>)
эмулирует текстовый терминал. Когда к терминалу хочет подлючиться
какая-то программа, то она будет управляться той программой,
которая открыла другой конец (<code>master</code>).
</p>

<p>
Вот как работает утилита <code>script(1)</code>: <a href="https://upload.wikimedia.org/wikipedia/commons/e/ef/Termios-script-diagram.png">Тут</a> (очень большая, решил не
встраивать). Она фактически запускает внутри себя баш, который
посылает все наверх, а в это время script пишет всякий инпут/аутпут
в файл.
</p>

<p>
Sources:
</p>
<ul class="org-ul">
<li>TTY unmistyfied (очень советую, просто супер забавная статья).
<a href="http://www.linusakesson.net/programming/tty/index.php">http://www.linusakesson.net/programming/tty/index.php</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-16-2" class="outline-3">
<h3 id="sec-16-2"><span class="section-number-3">16.2</span> <span class="done 3">3</span> Группы процессов, сессии, управление заданиями</h3>
<div class="outline-text-3" id="text-16-2">
<p>
Процесс может быть в одном из пяти состояний:
</p>
<ul class="org-ul">
<li>R &#x2013; запущен или может быть запущен
</li>
<li>D &#x2013; ждет какого-то евента в непрерываемом сне
</li>
<li>S &#x2013; прерываемый сон (ждем евента или сигнала)
</li>
<li>T &#x2013; остановлен либо по контрольному сигналу либо дебаггером
</li>
<li>Z &#x2013; зомби, закончившийся, но о котором забыл родитель (не сделал wait(2))
</li>
</ul>

<div class="org-src-container">

<pre class="src src-text">       &#9484;--&#8594;S---&#9516;-------&#9488;
       &#8595;       &#8595;       &#8595;
D &#8592;--&#8594; R &#8592;---&#8594; T &#8592;---&#8594; Z
       &#8739;               &#8593;
       &#9492;---------------&#9496;
</pre>
</div>

<p>
<code>ps 1</code> выводит запущенные/спящие процессы и чего они ждут. Более
того, в графе <code>STAT</code> может быть флажок s &#x2013; этот процесс лидер
сессии.
</p>

<p>
Управление заданиями &#x2013; это все действия с процессами, которые
касаются откладывания на задний фон, суспендинга, и прочих похожих
вещей.
</p>

<p>
Сессии и задания &#x2013; это разные уровни объединения процессов в группы. Выгляит это так:
</p>
<ul class="org-ul">
<li>{Процессы} ⊂ Группа.
</li>
<li>{Группа} ⊂ Сессия.
</li>
<li>У каждой группы есть лидер группы (<i>process leader</i>), у сессии
есть лидер сессии (<i>session leader</i>). Сессия соответствует
некоторому терминалу. (Примечание: на самом деле есть tid &#x2013;
thread id, уровень ниже процесса, треды объединяются в процессы
(<i>thread group</i>), и у таких групп есть лидеры, при закрытии
которого треды тоже умирают).
</li>
</ul>

<p>
Логика такова: <code>fork</code> создает процесс в своей группе, сессия менеджит
сигналы. Bash понимает что пришел, например, <code>^C</code> и отправляет его
текущей fg группе, от чего умирают все <code>pid</code>'ы в ней. Шелл является
лидером сессии и поэтому каждый новый запуск чего-нибудь создает
новую группу.
</p>

<p>
Понятно как делать foreground/background процессы если ты
шелл. Типа просто создаешь с помощью некоторого системного вызова
(полагаю, что <code>clone</code>) новую группу и чилда, и запускаешь, либо
связывая текущий <code>stdin/out</code> с запущенным чилдом, либо отмечаешь, что
они живут и работаешь дальше с юзером.
</p>

<p>
<code>fg/bg</code> &#x2013; утилиты, которые могут взять последнюю использованную
группу процессов и отправить ее в background/foreground.
</p>
</div>
</div>
<div id="outline-container-sec-16-3" class="outline-3">
<h3 id="sec-16-3"><span class="section-number-3">16.3</span> <span class="done 3">3</span> Сигналы: INT, HUP, TSTP, TTIN, TTOU, WINCH</h3>
<div class="outline-text-3" id="text-16-3">
<p>
Поскольку в UNIX все <code>tty/pty</code> являются файлами, то ими можно
управлять с помощью классного <code>ioctl(2)</code> &#x2013; швейцарского ножа UNIX
относительно девайсов. Есть некоторая загадочная проблема с
асинхронностью работы ядра с приложением, если юзать в приложении
вызовы к <code>ioctl</code>. Поэтому на помощь приходят сигналы.
</p>

<p>
Полный список сигналов есть в man, мы рассмотрим следующие:
</p>
<ol class="org-ol">
<li><code>SIGHUP</code>
<ul class="org-ul">
<li>Default action: Terminate.
</li>
<li>Possible actions: Terminate, Ignore, Function call.
</li>
<li>Отсылается драйвером UART к сессии целиком, когда мы замечаем
зависание на девайсе. По дефолту оно убивает все процессы. Тем
не менее, программы типа <code>nohup(1)</code> и <code>screen(1)</code> отключаются от
сессии, так что их процессы не заметят <code>SIGHUP</code>.
</li>
</ul>
</li>
<li><code>SIGINT</code>
<ul class="org-ul">
<li>Default action: Terminate.
</li>
<li>Possible actions: Terminate, Ignore, Function call.
</li>
<li>Отпавляется драйвером TTY конкретной forground job обычно по
<code>^C</code> (пока это поведение не выключить с помощью <code>stty</code>). По
дефолту SIGINT аффектит группу и убивает ее сразу (напомним,
что в шелл группа &#x2013; это какая-нибудь пайпнутая
последовательность команд или любая конкретная команда,
которая была запущена, а также все ее чилды).
</li>
</ul>
</li>
<li><code>SIGQUIT</code>
<ul class="org-ul">
<li>Default action: Core dump.
</li>
<li>Possible actions: Core dump, Ignore, Function call.
</li>
<li><code>SIGQUIT</code> &#x2013; это <code>SIGINT</code> по <code>^\</code>, который имеет немного
другое дефолтное действие и помогает, когда программа нагло
игнорирует <code>SIGINT</code> (если конечно не стоит хендлер и на
<code>QUIT</code>).
</li>
</ul>
</li>
<li><code>SIGSTOP</code>
<ul class="org-ul">
<li>Default action: Suspend.
</li>
<li>Possible actions: Suspend.
</li>
<li>Очень модный сигнал, который нельзя превентить и
замаскировать. Обычно <code>SIGSTOP</code> не вызывается напрямую. По
<code>^Z</code> отправляется <code>SIGSTP</code>, а потом само приложение себе
посылает <code>SIGSTOP</code>.
</li>
</ul>
</li>
<li><code>SIGTSTP</code>
<ul class="org-ul">
<li>Default action: Suspend.
</li>
<li>Possible actions: Suspend, Ignore, Function call.
</li>
<li>Работает как <code>INT/QUIT</code>, но магическая кнопка &#x2013; <code>^Z</code> и
дефолтное действие &#x2013; остановить.
</li>
</ul>
</li>
<li><code>SIGCONT</code>
<ul class="org-ul">
<li>Default action: Wake up.
</li>
<li>Possible actions: Wake up, Wake up + Function call.
</li>
<li>Выводит процесс из состояния сна. Он посылается, когда юзер
вызывает <code>fg</code>.
</li>
</ul>
</li>
<li><code>SIGTSTP</code>
<ul class="org-ul">
<li>Еще один сигнал (наравне с <code>SIGSTOP</code> и <code>SIGSTP</code>), суть
которого в том же самом и большинство источников утверждает,
что именно этот сигнал посылается по <code>^Z</code>.
</li>
</ul>
</li>
<li><code>SIGTTIN</code>
<ul class="org-ul">
<li>Default action: Suspend.
</li>
<li>Possible actions: Suspend, Ignore, Function call.
</li>
<li>Если бэкграундный процесс пытается читать из TTY, этот сигнал
посылается, чтобы та задача засуспендилась.
</li>
</ul>
</li>
<li><code>SIGTTOU</code>
<ul class="org-ul">
<li>Default action: Suspend.
</li>
<li>Possible actions: Suspend, Ignore, Function call.
</li>
<li>Если бэкграундный процесс пытается писать в TTY, ему
посылается <code>SIGTTOU</code>, который засуспендит задачу.
</li>
</ul>
</li>
<li><code>SIGWINCH</code>
<ul class="org-ul">
<li>Default action: Ignore.
</li>
<li>Possible actions: Ignore, Function call.
</li>
<li>TTY девайс следит за параметрами терминала, и эта информация
должна периодически обновляться. Если размер изменился, TTY
посылает <code>SIGWITCH</code> foreground'ной задаче. Всякие редакторы
должны корректно растягиваться и перерисоваться.
</li>
</ul>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-16-4" class="outline-3">
<h3 id="sec-16-4"><span class="section-number-3">16.4</span> <span class="done 3">3</span> Демоны и демонизация</h3>
<div class="outline-text-3" id="text-16-4">
<p>
Демоны &#x2013; это такие задачи, которые висят в фоне и не аффектят
другие процессы напрямую. Демоны не принадлежат группам и не
привязаны к TTY. Обычно демонизируют всякие серверы и сервисы.
</p>

<p>
Чтобы стать демоном, нужно:
</p>
<ol class="org-ol">
<li>Закрыть <code>stdin~/~stdout~/~stderr</code>.
</li>
<li>Отсоединиться от TTY. В этом две сути &#x2013; демон и все его потомки
не смогут открыть терминал и что-то испортить. Плюс, демоны не
будут зависимы от <code>HUP</code>, когда юзер выходит из shell после запуска
сервера.
</li>
</ol>

<p>
Хорошей практикой для сетевых демонов есть:
</p>
<ol class="org-ol">
<li>Поменять директорию на <code>/</code>.
</li>
<li>Поменять собственную маску создания файлов (<code>chmod</code>).
</li>
<li>Нормализовать <code>PATH</code>.
</li>
<li>Записать свой <code>pid</code> в <code>/var/run</code> или еще куда-нибудь.
</li>
<li>Дополнительно, настроить логирование.
</li>
<li>Дополнительно, сделать <code>chroot</code> в какой-нибудь удобный
environment, где ничего нельзя испортить.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-16-5" class="outline-3">
<h3 id="sec-16-5"><span class="section-number-3">16.5</span> <span class="done 3">3</span> Getty и рандомные факты</h3>
<div class="outline-text-3" id="text-16-5">
<p>
<b>Getty</b> &#x2013; это программа, которая открывает терминал <code>/dev/ttN</code>,
выставляет свою частоту. Обычно getty запускается <code>init</code>'ом.
</p>

<p>
Потом она принтит <code>issue</code>, <code>login</code>, <code>motd</code>.
</p>

<p>
Рандомные факты:
</p>
<ol class="org-ol">
<li><code>setgrp(pid, sr)</code> &#x2013; проеряет, правда ли, что <code>pid</code> не лидер
группы.
</li>
<li><code>setsid()</code> &#x2013; стартует новую сессию, <code>sid=pid</code>, <code>pgrp=pid</code>.
</li>
<li>Когда ты открываешь терминал с getty, терминал выставляется как
дефолтный.
</li>
<li>При подключении нового деваяса соединенного с терминалом,
возникает <code>HUP</code>, и отправляется всем процессам у которых
<code>tty=current_tty</code>.
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-17" class="outline-2">
<h2 id="sec-17"><span class="section-number-2">17</span> <span class="todo 2">2</span> Ticket 15   Booting</h2>
<div class="outline-text-2" id="text-17">
</div><div id="outline-container-sec-17-1" class="outline-3">
<h3 id="sec-17-1"><span class="section-number-3">17.1</span> <span class="todo 2">2</span> Pre-BIOS: хардварная загрузка</h3>
<div class="outline-text-3" id="text-17-1">
<p>
Материнская плата имеет огромное число всяких разных защелок,
кнопка включения/reset приводит их в детерменированное
состояние. Затем подается питание на процессор и указатель
направлен в константную память, в которой лежит BIOS.
</p>

<p>
Тут Ян минут 5-10 рассказывал про то, как это действительно
работает, но у меня этого нету :(.
</p>
</div>
</div>
<div id="outline-container-sec-17-2" class="outline-3">
<h3 id="sec-17-2"><span class="section-number-3">17.2</span> <span class="done 3">3</span> Загрузка: BIOS → MBR (DOS Label), DOS/Windows boot, GRUB</h3>
<div class="outline-text-3" id="text-17-2">
<p>
Первым делом BIOS инициализируется. Затем иницализируется VGA BIOS
&#x2013; штука которая инициализирует VGA-контроллер. Происходит проверка
системы на целостность, прогоняются тесты. Существуют различные
вариации селф-тестов, в зависимости от желаемого времени
прохождения. Первоначально целью этих тестов было получить размер
оперативной памяти (программа подсчитывала количество байтов
линейно).
</p>

<p>
Далее проверяется наличие всех необходимых контроллеров. Ровно тут
существовала популярная ошибка "no keyboard detected" &#x2013; старые
операционные системы не могли работать без клавиатуры. Более того,
раньше никто не задумывался о необходимости запускать ПК без
клавиатуры или видеокарты, так как самый популярные юзкейс &#x2013;
серверы, а раньше из обычных ПК серверы никто не делал, там железо
требовалось особое. Кстати говоря, клавиатуры подключались через
PS/2 &#x2013; он очень простой, в этом профит.
</p>

<p>
Если у BIOS происходят какие-то ошибки, понять, какие конкретно,
сейчас можно по специфическим гудкам, которые он издает с помощью
встроенного динамика (и документации). BIOS можно дампить, он там
свой стейт как-то в CMOS хранит.
</p>

<p>
После прохождения self-тестов BIOS предоставляет возможность что-то
сделать, войти в какой-нибудь GUI по нажатию <code>f11</code>, например. Раньше
кастомизация BIOS происходила с помощью джамперов, которые
выставлялись один раз перед загрузкой.  Затем происходит загрузка с
дефолтного boot устройства. Тут необходимо посвятить время основной
загрузке с жесткого диска и немного сетевой загрузке.
</p>

<p>
При сетевой загрузке используется <b>PXE</b>. У нас есть сетевая карта,
драйвер к которой давным-давно был расположен на самой кате, а
сейчас он есть в BIOS. BIOS может с ее помощью вытаскивать
необходимые данные. Есть несколько вариантов PXE на данный момент,
самый популярный &#x2013; <code>pxelinux</code>, или <code>ipxe</code>. Первый поддерживает
TCP, и это очень круто, потому что TFTP по UDP может терять пакеты
и если ядро большое, можно много раз безуспешно пробовать его
загружать. Частая практика с PXE использовать chained requests:
один PXE вытаскивает с сервера некоторый код, который предоставляет
GUI для того, чтобы выбрать другой удаленный сервер и выбрать ядро,
которое тебе нравится (например).
</p>

<p>
Стандартная загрузка с жесткого диска происходит следующим образом:
BIOS загружает необходимые ему драйвера: ATA-IDE, SATA-SCSI,
USB. USB драйвера труднее писать из-за того, что USB необходимо
постоянно поллить (значит ли это, что драйвера для USB не всегда
включены в BIOS?). Затем BIOS грузит в оперативную память первые
512б и загружается с них.
</p>

<p>
Есть несколько вариантов разметки жесткого диска, которые позволяют
делать разные приятные вещи, к примеру MBR или GPT. Отметим, что
нет ничего противозаконного загружаться напрямую из какого-то кода
(как grub или ваш<sub>кастомный</sub><sub>загрузчик</sub>).
</p>

<ul class="org-ul">
<li>MBR (DOS label) формат: 512b. Последние два байта это 0x55AA,
необходимы для первоначальной проверки того, что шина
работает. Кроме того, это индицирует, что диск размечен MBR а не
чем-то другим. Первые 510б &#x2013; это jump, метаданные, загрузчик и
TBL. Jump просто перепрыгивает метаданные. Все, что делает код &#x2013;
загружает нужный кусок памяти и запускает его.

<p>
TBL (загрузочная таблица) содержит 4 основных (primary) раздела,
для каждого определено boot bit, тип, старт (адрес) и длина. Boot
bit показывает, что с этого раздела нужно грузиться. Кроме 4
основных разделов можно добавить еще некоторые дополнительные
(extended).  Любой раздел кроме уже перечисленного содержит (в
таблице) свой тип и другие данные. Linux игнорирует
TBL-информацию о типе, но для DOS это критично. Обычно ядро лежит
по фиксированному адресу на диске.
</p>

<p>
Важное замечание: fdisk не дает создать раздел раньше чем
некоторый оффсет с начала диска по причине того, что начало
обычно резервируется для MBR + еще потенциально
чего-нибудь. Кроме того, даже начало MBR не совпадает с началом
диска, а есть еще оффсет, который свойственен для конкретной
модели HDD ввиду того, что дорожки близко к центру плохо
отцентрованы.  GRUB обычно устанавливается как раз сразу за MBR и
занимает секцию кода в MBR. Также GRUB содержит рядом со своим
исполняемым кодом различные драйвера. GRUB похож на маленькую OS,
которая загружает разделы с помощью драйверов которые вот там
есть и показывает GUI, предоставляя возможность настраивать все,
что настраивается.
</p>

<p>
Забавный факт: с некоторых пор GRUB начал хранить себя еще и с crc,
по причине того, что Windows никак не защищает этот кусок памяти,
и туда могут благополучно писать кто хочет, в том числе и
Photoshop, который хранит где-то в этом месте свои ключи
регистрации, чтобы пользователи после переустановки системы не
могли сбросить лицензию.
</p>
</li>

<li>С GPT памяти на то же, что использовалось в MBR, намного
больше. В начале есть MBR-совместимая таблица, потом
располагаются 512 ячеек TBL. Утверждается, что с помощью BIOS без
внешнего загрузчика нельзя загружать что либо в файловой системе,
то есть единственный вариант &#x2013; ядро класть прямо по адресу.
</li>
</ul>

<p>
EFI &#x2013; это такой BIOS, который пишет в NVRAM все загрузочные
данные, а конкретно откуда и с каким оффсетом лежат ядра, всякие
аргументы и прочее.
</p>

<p>
Про то, чем UEFI не BIOS. Подробно, читабельно (советую).
</p>
<ul class="org-ul">
<li><a href="https://www.happyassassin.net/2014/01/25/uefi-boot-how-does-that-actually-work-then/">https://www.happyassassin.net/2014/01/25/uefi-boot-how-does-that-actually-work-then/</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-17-3" class="outline-3">
<h3 id="sec-17-3"><span class="section-number-3">17.3</span> <span class="done 3">3</span> initrd</h3>
<div class="outline-text-3" id="text-17-3">
<p>
Initrd &#x2013; это cpio архив, который грузится в память, а ядро затем
монтирует это как дефолтную систему. Основная цель initrd &#x2013;
обеспечить дополнительную функциональность, когда слишком
сложно/лень писать новый модуль ядра. Initramfs &#x2013; это модификация
initrd, доступная в linux с 2.6.13, которая монтируется как tmpfs.
</p>

<p>
Пусть у нас есть ядро и initrd. Ядро обычно находится по некоторому
фиксированному адресу. Ядру передаются параметры, в том числе
<code>root={dev|UUID}</code>, который говорит, что монтировать в корень
(<code>blkid</code>). Ядро обычно сжато bzImage, с тех пор, как оно стало
достаточно большим &#x2013; это довольно специфичный архивный формат (не
связан с bzip2), основанный на gzip. В начале этого архива есть
программа для разархивации.
</p>

<p>
GRUB запускает ядро, распаковывает initrd и монтирует его в корень
(<code>/</code>). Затем запускается <code>/init</code>, который дает старт загрузке. Всякие
встроенные устройства типа роутеров как раз имеют ровно ядро и
initrd, которые лежат в некоторой NVRAM.
</p>

<p>
В таких встроенных системах пользуется популярностью busybox &#x2013;
программа, которая имитирует стандартный набор утилит linux (парсит
0 аргумент и запускает что надо). В случае, если установлен
busybox, <code>/bin/{ls, mv, cp, cat}</code> &#x2013; symlink'и на busybox (<code>busybox
   --help, busybox --install -s dir</code> &#x2013; устанавливает симлинки на
себя). Цель busybox &#x2013; иметь кучу всего, при этом не тратя много
памяти (стандартные утилиты имеют достаточно ограниченный
функционал, меньший, чем оригиналы).
</p>

<p>
После этого создаются <code>/dev/{stdin, stdout, stderr, console}</code> и
console выставляется на все стандартные std&#x2026; (<code>exec &lt; /dev/console
   &amp;&amp; exec &gt; /dev/console &amp;&amp; exec 2&gt; /dev/console</code>).
</p>

<p>
Следующим шагом возникает необходимость примонтировать какую-нибудь
файловую систему, и это делают двумя способами:
</p>
<ol class="org-ol">
<li><code>mount -t procfd ... /proc, mount -t sysfs ... /sys; launch udev.</code>
</li>
<li>Монтируется некоторая специфическая система (Ян не вспомнил
названия), которая имеет udev внутри и создает все <code>inode</code>'ы
автоматически.
</li>
</ol>

<p>
<code>udev(7)</code> &#x2013; это демон, который создает netlink (<code>socket(2)</code>) сокет
с ядром, в которое ядро дампит информацию про устройства, а потом
парсит эти данные, классифицирует (connect/disconnect/modify) и
согласно правилам в <code>/etc/udev</code> что-то делает (чаще всего создает
что-то в <code>/dev</code>, переименовывает или меняет симлинки). Существует
также поведение udev, которое называется settle (<code>udevadm(8)</code>) &#x2013;
udev обрабатывает всю очередь событий и выходит.
</p>

<p>
После этого можно отмонтировать себя и загрузить желаемый раздел (а
между тем что-нибудь еще расшифровать или сделать еще что-нибудь
интересное, что позволяет initrd). Если используется busybox, то
определить файловую систему помогает <code>blkid</code>, если нет, то
полноценный mount сам может. Есть еще проблема с инициализацией
SATA, так что <code>blkid</code> умеет ждать в цикле
инициализации. Альтернативный подход к решению проблемы &#x2013; libsata
модуль, которым никто не пользуется, потому что никому не нужен
модуль, который ждет SATA и блокирует систему.
</p>

<p>
Теперь мы можем примонтировать <code>/</code> и запустить init. Сделать это
можно с помощью <code>pivot_root &amp;&amp; exec /sbin/init</code>. Внутренний init
делает что-то специфическое, свойственное для системы. В этом месте
как раз мы расшифровываем диск, если он зашифрован.
</p>

<p>
Можно тут загрузить вместо init просто emacs, который умеет делать
сам практически все необходимое, тогда в <code>/bin</code> кроме него нужно
положить еще mount, а busybox'а с головой должно хватить (тут много
шутят про "emacs OS still needs a better editor" &#x2013; возьмите
evil/viper/vimpulse с собой!).
</p>

<p>
Рассмотрим пример с USB:
</p>
<ol class="org-ol">
<li>USB воткнут в порт.
</li>
<li>Проходит 300мс, необходимые для того, чтобы убедиться, что USB
всунут плотно (лол).
</li>
<li>Контроллер на флешке понимает, что он подключился куда-то и
отправляет сигнал.
</li>
<li>Проходит через южный и северный мосты.
</li>
<li>В процессор, который получает прерывание.
</li>
<li>Ядро обрабатывает прерывание, смотрит на контроллер, понимает
какой драйвер нужен.
</li>
<li>Смотрит в табличку специальную, осознает какой модуль за это
отвечает (если в ядре нету драйвера).
</li>
<li>Hotplugging: в ядро загружается код, который представляет из
себя нужный модуль (код мерджится с кодом ядра), с
зависимостями. Или все падает, если чего-то нет, хотя обычно
утилиты конфигурации ядра (<code>make menuconfig</code>) такого не
допускают, компилируя все зависимости.
</li>
<li>создается <code>sys/...</code>, в дело вступает udev и создает
<code>/dev/sdd{..}</code>.
</li>
<li>Все последующие прерывания обрабатываются уже из загруженного
модуля.
</li>
</ol>

<p>
Все операции во время hotplugging'а происходят с помощью UNIX
сокетов, которые должны быть вкомпилированы в ядро, иначе мы
получим бесконечный цикл попыток загрузить модуль с UNIX сокетами.
</p>

<p>
Все модули загружаются автоматически, но иногда приходится делать
это вручную. Например, с помощью <code>/etc/init.d/modules</code>.
</p>

<p>
Firmware загружается напрямую в железо (как например драйвер
видеокарточки), и затем появляется возможность общаться с картой
через стандартный интерфейс (opengl какой-нибудь).
</p>
</div>
</div>
<div id="outline-container-sec-17-4" class="outline-3">
<h3 id="sec-17-4"><span class="section-number-3">17.4</span> <span class="done 3">3</span> Инициализация системы: последовательная, учитывая зависимости, resource/socket activation, lazy activation, cтандартные init системы</h3>
<div class="outline-text-3" id="text-17-4">
<ul class="org-ul">
<li>Последовательная инициализация &#x2013; запустить все
последовательно!
</li>
<li>С зависимостями &#x2013; имеется некоторый набор
сервисов, которые превращаются в граф.
</li>
<li>Resource activation &#x2013; не запускать сервер, пока не будет в том
необходимости, то есть клиенты раньше сервера.
</li>
<li>Lazy activation &#x2013; полагаю, что приоритеты, как в systemd.
</li>
</ul>

<p>
Init системы:
</p>
<ul class="org-ul">
<li>Первоначально был <b>System V init</b> &#x2013; демон, который создавал
<code>/dev/initctl</code> сокет при старте. Можно отправлять в этот сокет
команды запускать runlevel'ы (определены в <code>/etc/inittab</code>).

<p>
Типа ты запускаешь runlevel с помощью <code>rc N</code> команды, и тогда rc
запускает <code>/etc/rc&lt;N&gt;.d/*K kill</code>, потом <code>/etc/rcN.d/*S start</code>, смена
runlevel'а останавливает все предыдущие процессы.
Дефолтно:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="right">0</td>
<td class="left">halt</td>
</tr>

<tr>
<td class="right">1</td>
<td class="left">single user</td>
</tr>

<tr>
<td class="right">2</td>
<td class="left">многопользовательский без сети</td>
</tr>

<tr>
<td class="right">3</td>
<td class="left">многопользовательский с сетью</td>
</tr>

<tr>
<td class="right">6</td>
<td class="left">reboot</td>
</tr>
</tbody>
</table>

<p>
System V init вполне себе ОК, когда задач не очень много, так что
его используют на всяких встроенных системах, читалках и тд. С
большим количеством задач становится плохо.  Вторая проблема &#x2013;
это демоны, их трудно трекать.
</p>
</li>
<li>Перед systemd, arch linux пользовался какой-то модификацией
System V с поддержкой асинхронного запуска программ.
</li>
<li>Первое нормальное решение вместо System V &#x2013; это <b>Upstart</b>, штука
очень похожая на System V, но умеющая трекать демонов и
мультизадачная, на основе событий &#x2013; некоторые скрипты создают
евенты, которые другие события слушают, так что можно запускать
что-то асинхронно. На события можно подписываться.
</li>
<li><b>Socket activation</b> &#x2013; решение создавать все сокеты и каналы перед
выполнением задач, а потом все сразу запустить. Такая штука
использовалась некогда в Mac OS.
</li>
<li><b>Systemd</b> &#x2013; init с поддержкой мультизадачности на графе
сервисов, ребра которых либо сокеты, либо просто непосредственный
запуск ресурса. Это более оптимально чем socket activation из-за
того, что вершины имеют приоритет + проблемы с демонами решены с
помощью механизма cgroups. Cgroups представляет собой набор
процессов, объединенных круче, чем обычные группы процессов, а
именно: можно ограничить группе доступ к памяти, дать группам
разный приоритет по отношении к CPU/IO, можно убивать,
чекпоинтить и рестартить всю группу сразу. Проблема демонов
решена ровно потому, что из cgroup нельзя просто так выйти.
</li>
<li><b>Openrc</b> &#x2013; gentoo init, который очень похож на systemd, но без
безумных идей. Openrc тащит!
</li>
</ul>

<p>
Тут нужно сказать почему systemd и kdbus &#x2013; полная фигня (Ян не
любит их, минут 15 объяснял почему).
</p>
</div>
</div>
<div id="outline-container-sec-17-5" class="outline-3">
<h3 id="sec-17-5"><span class="section-number-3">17.5</span> <span class="done 3">3</span> Стандартные демоны: init, syslog, klog, cron, at, ssh</h3>
<div class="outline-text-3" id="text-17-5">
<ol class="org-ol">
<li><code>init daemon</code> &#x2013; уже обсудили
</li>
<li><code>syslog</code> - демон, который читает из ядра логи и пишет их.
<ul class="org-ul">
<li>Поговаривают, он читает <code>/dev/log</code> сокет и делает что-то
согласно <code>/etc/syslog.conf</code>.

<p>
<a href="http://www.k-max.name/linux/syslogd-and-logrotate/">http://www.k-max.name/linux/syslogd-and-logrotate/</a>
</p>
</li>
<li>На gentoo все пользутся syslog-ng или rsyslog, которые умеют
делать что-то с логами согласно конфигурации &#x2013; класть их в
<code>/var/log</code> или пересылать по сети.

<p>
<a href="https://wiki.gentoo.org/wiki/Rsyslog">https://wiki.gentoo.org/wiki/Rsyslog</a>
</p>
</li>
</ul>
</li>
<li><code>klog</code>. Тоже логгер какой-то видимо, про него ничего нету в
интернетах.
</li>
<li><code>cron</code>. Супер-полезная штука, которая делает какие-то вещи по
расписанию, будь то бекапы или обновления, или еще что угодно.
</li>
<li><code>at</code>. Демон <code>atd</code> висит и исполняет команды, которые его
попросили (единажды).
</li>
<li><code>ssh</code>. <code>sshd(8)</code> и <code>ssh</code> &#x2013; программы, которые позволяют
установить зашифрованное сообщение с другой машиной на
незашифрованной сети
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-17-6" class="outline-3">
<h3 id="sec-17-6"><span class="section-number-3">17.6</span> <span class="done 3">3</span> Стандартные файлы /etc: fstab, mtab, sysctl.conf, motd, issue, nologin.</h3>
<div class="outline-text-3" id="text-17-6">
<ol class="org-ol">
<li><code>fstab</code> &#x2013; file system table, файл который говорит, какие
разделы куда нужно монтировать при init'е.
</li>
<li><code>mtab</code> &#x2013; mounted table, там написано что сейчас замонтировано и
как.
</li>
<li><code>sysctl.conf</code> &#x2013; содержит настройки, которые необходимы sysctl
для смены конфигурации ядра в рантайме.
</li>
<li><code>motd</code> (<i>message of the day</i>) &#x2013; все что там написано выводится
после успешного login.
</li>
<li><code>issue</code> &#x2013; выводится до логина.
</li>
<li><code>nologin</code> &#x2013; если <code>/etc/login</code> существует, то логиниться можно
только root'у.
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-18" class="outline-2">
<h2 id="sec-18"><span class="section-number-2">18</span> <span class="done 3">3</span> Ticket 16   Linking</h2>
<div class="outline-text-2" id="text-18">
<p>
Mustread:
</p>
<ol class="org-ol">
<li>Strange, complex
<a href="http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf">http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf</a>
</li>
<li>Simple, useful
<a href="https://github.com/oxij/unix-notes-ru/blob/master/compiled/main.pdf">https://github.com/oxij/unix-notes-ru/blob/master/compiled/main.pdf</a>
</li>
</ol>
</div>
<div id="outline-container-sec-18-1" class="outline-3">
<h3 id="sec-18-1"><span class="section-number-3">18.1</span> <span class="done 3">3</span> ELF</h3>
<div class="outline-text-3" id="text-18-1">
<p>
Файлы мы умеем компилировать, линковать и запускать. Под
компиляцией понимается превращение кода на чем-то в набор
op-code'ов, находящихся в некотором формате. <b>Tool chain</b> &#x2013;
последовательность действий необходимая для создания рабочего
бинарника из кода.
</p>

<p>
<code>.h</code> файлы представляют собой типы, методы, оффсеты и прочее. <code>.c</code>
файлы хранят другие вещи и компилируются в бинарник, формат
которого в подавляющем большинстве случаев ELF (есть еще COFF, но
никто его не использует).
</p>

<p>
ELF состоит из:
</p>
<ol class="org-ol">
<li>ELF Header. Содержит информацию про то, что это вообще такое,
всякие версии, архитектуру и прочее.
</li>
<li>Program header:
<div class="org-src-container">

<pre class="src src-text">| type | flags | offset in body | length in body | offset in memory&lt;vm, ph&gt; | length in memory |
</pre>
</div>

<p>
Оффсет в физической памяти игнорируется, если программа
юзерспейсная. Мапить вообще в физическую память полезно если
какие-то страницы закэшированы, а какие-то нет. Тип может быть
разным, к примеру <code>MEM</code> значит что оно замаплено в память,
<code>INTERPRET</code> это сегмент, где находится интерпретатор. <code>DWARF</code> значит
дебаг, <code>RPATH</code> содержит перемнные окружения.
</p>

<p>
Самый простой интерпретатор ELF парсит программные хедеры и
загружает сегменты туда, куда указано (в свое новое адресное
пространство).
</p>
</li>
<li>Body. Всякие секции и код.
</li>
<li>Section table
<div class="org-src-container">

<pre class="src src-text">| labelname | type | &lt;offset, length in body&gt; |
</pre>
</div>

<p>
Большинство секций &#x2013; это просто функции, но есть специальные:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left"><code>.init</code></td>
<td class="left">инициализация</td>
</tr>

<tr>
<td class="left"><code>.fini</code></td>
<td class="left">конец инициализации</td>
</tr>

<tr>
<td class="left"><code>.ctor</code></td>
<td class="left">конструкторы</td>
</tr>

<tr>
<td class="left"><code>.dtor</code></td>
<td class="left">деструкторы</td>
</tr>

<tr>
<td class="left"><code>.data</code></td>
<td class="left"><code>section .data</code></td>
</tr>

<tr>
<td class="left"><code>.text</code></td>
<td class="left"><code>section .text</code></td>
</tr>

<tr>
<td class="left"><code>.sym</code></td>
<td class="left">таблица символов <code>{name → address}</code></td>
</tr>

<tr>
<td class="left"><code>.rel</code></td>
<td class="left">таблица релокаций</td>
</tr>
</tbody>
</table>

<p>
Поясним, что символом называется любая глобальная переменная,
метка, функция и вообще все, у чего есть имя. Очевидно, что в
<code>.sym</code> не может быть коллизий &#x2013; в программе нет функций с
одинаковыми именами и т.д.
</p>
</li>
</ol>

<p>
Насчет аллокаций: по дефолту если мы вызываем какую-то внешнюю
фукнцию из кода, то в объектнике появляется <code>call 0x0</code>, а в таблицу
аллокаций добавляется {оффсет этого <code>call</code>, имя метки}.  Структура
таблицы релокаций:
</p>
<div class="org-src-container">

<pre class="src src-text">| name | type | offset |
</pre>
</div>
<p>
Что бы это могло значить &#x2013; дальше станет понятнее!
</p>
</div>
</div>
<div id="outline-container-sec-18-2" class="outline-3">
<h3 id="sec-18-2"><span class="section-number-3">18.2</span> <span class="done 3">3</span> Статическая линковка</h3>
<div class="outline-text-3" id="text-18-2">
<p>
Когда <code>ld</code> линкует файлы, он:
</p>
<ol class="org-ol">
<li>Берет кучу <code>.o</code> файлов, с зависимостями.
</li>
<li>Добавляет свои специальные объектники, чтобы сегенерировать
<code>_start</code> и прочие жизненно важные вещи <code>(crti.o, crtn.o,...)</code>.
</li>
<li>Игнорирует прогрмамные хедеры (выкидывает), мерджит объектники,
склеивая секции в том порядке, в котором были даны аргументы.
</li>
<li>С каждым новым мерджем генерируeтся новый программный хедер.
</li>
<li>Резолвит таблицу релокаций, но пока не подставляет конкретные
вызовы.
</li>
</ol>

<p>
Когда наступает время создать бинарник из <code>.o</code>, <code>ld</code>:
</p>
<ol class="org-ol">
<li>Проверяет наличие <code>_start</code>, другие вещи
</li>
<li>Заполняет адреса из таблицы релокаций.
</li>
<li>Выкидывает <code>section table</code>.
</li>
</ol>

<p>
То есть смотрит на все дырки, в которых ничего не написано (это
хранится в <code>.rel</code>) и суммирует туда те адреса, которые значатся в
таблице.
</p>

<p>
Еще разок: на этапе компиляции в объектник были дырки и непонятно
было, что вставлять, потом при мердже в таблицу добавились нужные
записи.
</p>

<p>
Линковка на уровне символов (<i>symbol-level linking</i>) это
выкидывание ненужных символов на этапе создания бинарника. В <b>Plan
9</b> это главная идея. С использованием линковки с выбрасыванием
ненужного + статической можно легко имплементировать исполнение в
контейнерах. Плюс забавно, что статически линковать выгоднее
иногда, чем использовать динамическую линковку (пока мы не юзаем
чего-нибудь ресурсоемкого типа каких-нибудь firefox).
</p>
</div>
</div>
<div id="outline-container-sec-18-3" class="outline-3">
<h3 id="sec-18-3"><span class="section-number-3">18.3</span> <span class="done 3">3</span> Динамическая линковка, GOT, PLT</h3>
<div class="outline-text-3" id="text-18-3">
<p>
Проблемы статической линковки: жирные бинарники, нужно
перекомпилировать все подряд.
</p>

<p>
Решение: на этапе мерджа мы мерджим то, что можно, а функции из
внешних библиотек проверяем на целостность. При динамическом
запуске динамический загрузчик кроме нашего кода загружает в память
еще и библиотеку, причем расставляет правильные адреса вызовам.
</p>

<p>
Есть проблема, что разложение объектников в памяти может портиться,
поэтому непонятно, как расставлять адреса на этапе динамической
загрузки. В x64 поддерживается relative адресация, а если такого
нету, то можно использовать такой хак: Пусть в объектнике все
адреса меток располагаются так, будто они начинаются с нуля, тогда
при загрузке на адрес N можно ко всем вызовам прибавить N и будет
работать. Код который можно так использовать, называют
релокабельным.
</p>

<p>
Насчет внешних вызовов, следует пользоватся таблицей релокации.
</p>

<p>
Пусть у нас есть код, секция данных, и еще две секции &#x2013; таблица
внешних вызовов и таблица внешних данных. Все call на внешние
функции указывают на записи в таблице внешних вызовов, а там
написано <code>jmp X</code>, где <code>X</code> потом поставит компилятор. Аналогично с
глобальными переменными, только вместо jump хранится просто
адрес. То есть мы получили блоб кода с двумя табличками, которые
нужно поменять и код будет работать. Такой код к тому же можно
сделать релокабельным, то есть все внутренние метки имеют адрес как
будто они нумеруются с нуля.
</p>

<p>
Тогда делаем следующее:
</p>
<ol class="org-ol">
<li>Берем кучу объектников, клеим, клеим, клеим (то, что клеится
хорошо, то есть не содержит вызовов куда-то туда, что мы не
компилируем &#x2013; либы).
</li>
<li>Получаем несколько бинарников.
</li>
<li>Раскладываем в память, добавляя ко всем вызовам внутри каждого
бинарника адрес по которому он кладется (релокативность вот
этого блоба) &#x2013; если требуется и у нас не relative
раскладывание, оно в x64 из коробки.
</li>
<li>Динамический загрузчик расставляет адреса в 2 таблички каждого
бинарника.
</li>
<li>Управление передается <code>_start</code>.
</li>
</ol>

<p>
На деле вместо таблицы внешних вызовов в таблицу внешних данных
кладутся адреса функций. После чего ее называют <b>GOT</b> (<i>Global
offset table</i>) &#x2013; для каждого бинарника на нее ссылаются все вызовы
внутри него, а в самой табличке динамический линковщик проставляет
адреса.
</p>

<p>
С другой стороны, таблицу внешних вызовов выкидвать не нужно, а
стоит поменять в каждом <code>jmp X</code> <code>X</code> на соответствующий элемент из
GOT, а таблицу назовем <b>PLT</b> (<i>procedure linkage table</i>).
</p>

<p>
Еще раз в виде определений:
</p>
<ol class="org-ol">
<li>GOT &#x2013; таблица в которой лежат адреса всех внешних переменных и
функций.
</li>
<li>PLT &#x2013; таблица на которую ссылается код релокабельного
бинарника, состоит из jmp на GOT.
</li>
</ol>

<p>
Тогда динамическому линковщику нужно заполнять только GOT.
</p>
</div>
</div>
<div id="outline-container-sec-18-4" class="outline-3">
<h3 id="sec-18-4"><span class="section-number-3">18.4</span> <span class="done 3">3</span> PIC</h3>
<div class="outline-text-3" id="text-18-4">
<p>
Иногда хочется (из соображений безопасности) класть бинарник в
случайное место памяти. Кроме того, затратно каждый раз прибавлять
к каждой инструкции в коде адрес начала бинарника когда мы его
куда-то кладем.
</p>

<p>
<b>PIC</b> (<i>placement independent code</i>) &#x2013; код, исполнение которого не
зависит от того, куда мы его положили.
</p>

<p>
Вопрос в том, как сделать относительную адресацию на архитектуре,
на которой это не работает по дефолту. В x64 есть RIP-addressing,
который работает из коробки.
</p>

<p>
Простое решение &#x2013; хранить ссылку на GOT в <code>ebx</code>, а все обращения к
локальным переменным и регистрам проиходит через GOT.
</p>
</div>
</div>
<div id="outline-container-sec-18-5" class="outline-3">
<h3 id="sec-18-5"><span class="section-number-3">18.5</span> <span class="todo 2">2</span> Exec magic и интерпретаторы и прочее</h3>
<div class="outline-text-3" id="text-18-5">
<p>
<b>Shebang</b> &#x2013; если файл начинается с <code>#!</code>, то это не ELF, а shebang
формат, ядро запускает интерпретатор ровно оттуда, что указано
после <code>#!</code>.
</p>

<p>
<b>Exec magic</b> &#x2013; это вот это самое <code>#!</code>, которое <code>0x23
   0x21</code>. Exec-функции умеют как раз парсить эту магию и понимать, что
нужно делать с файлом, как искать интерпретатор и т.д.
</p>

<p>
Насчет magic еще есть очень важное замечание, которое есть в
<code>magic(1)</code>. Вкратце, если я все правильно понимаю,
<code>/etc/share/misc/magic*</code> файлы определяют, в каких местах в файлах
могут находиться некоторые критичные данные, которые помогают
типизировать его. Соответственно, сопоставляется MIME-тип. Утилита
<code>file</code> прогоняет 3 теста (проеврка fs, проверка magic, проверка
language). Насчет третьего вообще хз, а что делают первые два
более-менее понятно.
</p>

<p>
Кроме того, в UNIX есть два динамических загрузчика &#x2013; один в ядре,
который осиляет только простые ELF, другой юзерспейсный, очень
сложный, но скомпилированный в простой ELF.
</p>

<p>
Под динамическим загрузчиком понимают именно второй, он обычно
лежит в <code>/lib/ld-linux.so.VERSION</code>, где <code>VERSION</code> &#x2013; его мажорная
версия. По дефолту в переменной окружения <code>LD_LIBRARY_PATH</code> лежат
библиотеки, которые ld осматривает при линковке.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-19" class="outline-2">
<h2 id="sec-19"><span class="section-number-2">19</span> Uncategoriesed</h2>
<div class="outline-text-2" id="text-19">
</div><div id="outline-container-sec-19-1" class="outline-3">
<h3 id="sec-19-1"><span class="section-number-3">19.1</span> Execution levels</h3>
<div class="outline-text-3" id="text-19-1">
<p>
There's -2 level of execution, for example something that governs
how to operate with cooler.  Available protocols for hard drives
and stuff:
</p>
</div>
</div>
<div id="outline-container-sec-19-2" class="outline-3">
<h3 id="sec-19-2"><span class="section-number-3">19.2</span> Encryption and safety</h3>
<div class="outline-text-3" id="text-19-2">
<p>
TPM &#x2013; hardware, that has 256-bit registers, near 20 items of them,
has clear operation and extend reg data operation &#x2013; takes hash
from data, hashes it with register and writes to it. TMP has some
processor, that can clear, extend, and built-in algorithms of
encryption, like AES (very secure, there's a proof, thats energy to
decrypt it is more than the energy to melt the Earth:
<a href="http://www.eetimes.com/document.asp?doc_id=1279619">http://www.eetimes.com/document.asp?doc_id=1279619</a>). There's also
seal operation, that takes registers, data, and uses registers to
encrypt data, then puts data into one of hardware box; There's also
unseal operation, that does the opposite.  Hardware encryption:
LUKS, 2mb of data in the start of disk, that contains metadata,
salt, master-key, header, algorithm for hashing passwords and disk,
and then it's some magic. The disk is always encrypted. Hash cache
is algorithm of detecting SPAM &#x2013; user that sends email generates
hash collisions and it takes lot of computer time.  That's not
clearly secure (LUKS) because one can replace initrd. That's called
evil maid strategy. We can encrypt all except grub, but there can
be an malware in grub. There can be a solution with outer flash
drive, that contains everything but encrypted binary blob (even
LUKS header). With TPM it's easier, because things that BIOS does
are extended. BIOS CAN HAVE MALWARE TOO!! PARANOID!! TXT is a
technology by Intel that allows you to trust your processor, and it
uses TMP to extend some hardware id.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">&#1040;&#1074;&#1090;&#1086;&#1088;: Volkhov Mikhail, Dmitry Mukhutdinov</p>
<p class="date">Created: 2015-12-15 Tue 02:37</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.2 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
