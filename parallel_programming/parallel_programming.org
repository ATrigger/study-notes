#+TITLE: Конспект по ПП от Елизарова

* Какие-то материалы:
  https://www.slideshare.net/secret/6dv9wtl1pDOTgu
  https://www.slideshare.net/secret/h3wT59xRPciKM6
  https://www.slideshare.net/secret/yDV9vtRs61gEdg

  https://www.slideshare.net/secret/E1asIyWYNfvkNv
  https://www.slideshare.net/secret/LnSxMJ7JZ25JFe
  Консенсус:
  https://www.slideshare.net/secret/LnSxMJ7JZ25JFe
  Реализация ссылочных структуры:
  https://www.slideshare.net/secret/zrtgOfnRQY6K0Z
  Массивы, CASN, R/W Locks, STM:
  https://www.slideshare.net/secret/8ZkekdbzRSIjsP

  Рекомендуемые учебники: · The Art of Multiprocessor Programming,
  Maurice Herlihy, Nir Shavit,
  http://www.amazon.com/The-Multiprocessor-Programming-..  Это
  основной учебник для осеннего семестра. Его надо знать и любить.

  · Concurrent and Distributed Computing in Java, Vijay K. Garg,
  http://www.amazon.com/Concurrent-Distributed-Computin..  Обзор для
  всех частей курса (пригодится так же и для второго семестра).
* 07.09.2015
  NUMA -- not uniform memory access (все знают, что это еще с 1
  курса)

  Операционные системы (классификация по параллельности):
  1. Однозадачные
  2. Пакетные задания (batch processing)
  3. Многозадачные
     1. Кооперативная многозадачность
     2. Вытесняющая многозадачность
* 14.09.2015
  Линеаризуемость -- суперское свойство, тащемта.
  Даже если в каждом потоке все операции атомарны, мы не можем
  утверждать, что объект линеаризуем (пример с class Queue, def enq,
  def deq).
  Мы вот хотим линеаризуемую очередь.

  Самый простой метод сделать так -- это использование блокировок
  (locks, mutex (mutual exclusion)).
  Идея: заведем в объекте member Mutex m, будем его лочить и
  разлочивать. Этот объект будет гарантировать, что объект будет
  застрявать на .lock, если мьютекс уже залочен и т.д.
  Код с mutex'ами будет thread-safe, если операции будут защищены
  одним мьютексом.

  Как написать mutex, собственно?
  1. Тут мы рассматриваем примитивную неработающую имплементацию
     mutex'а
  2. Тут мы рассматриваем еще одну имплементацию, но работающую
     относительно гарантий взаимного исключения.
     Но алгоритм не гарантирует прогресс, то есть могут застопориться
     на wait() оба потока.
  3. Пример который решает проблемы 2, но один поток может голодать
     (starvation-freedom -- требование, чтобы если поток хочет войти в
     секцию, то он войдет за конечное время)
  4. алгоритм Петерсона -- гарантирует взаимное исключение, отсутствие
     взаимной блокировки и отсутствие голодания.
  5. алгоритм петерсона для N потоков -- все то же самое, но может
     делать O(N²) ожидания, к.

  Блокировки бывают грубыми и тонкими. Грубая -- блокировать всю
  операцию целиком. Тонкая -- блокировать операции над общими
  объектами внутри, а не вызов, но тогда необходима двухфазовая
  блокировка.

  Есть проблема deadlock'а. Допустим, что есть два mutex'а, мы лочимся
  в одном треде сначала по m1, потом по m2, в другом треде
  наоборот. Можем задедлочиться тут короче.
* 21.09.2015
  Алгоритмы без блокировок.
  Lock-free алгоритмы имеют некоторые безусловые условия прогресса:
  1. Obstruction-free (отсутствие помех) -- свойство алгоритма, в
     котором если остановить всп потоки кроме одного в любом месте,
     один должен завершиться за конечное время. Так должно работать
     для каждого объекта.
     Очевидно, что объект с блокировкой не имеет такого
     свойства.
  2. Lock-freedom -- если много потоков пытаются сделать операцию,
     то хотя бы один поток должен ее исполнить за конечное
     время. Плохо то, что это условие не исключает голодания.
  3. Wait-freedom (самое сильное условие) -- если какой-то поток
     пытается выполнить операцию, то он это сделает (вне
     зависимости от действия/бездействия других потоков).

  Объекты без блокировки.
  ОБъекты бывают с lock-freedom, но этот термин перегружен.
  * Регистры без блокировки
    * Свойства физических регистров:
      1. Неатомарны
      2. Работают без ожидания.
      3. Предполагают только одного читателя и одного писателя
      4. Попытка записать и прочитать одновременно -- UB
      5. Они безопасные (safe) -- в смысле, после записи, будет
         прочитано последнее записанное значение.
    * Классификация регистров
      1. Безопасные (safe), регулярные (regular) -- при чтении
         выдает последнее записанное, или то, что уже пишется,
         атомарные (atomic) -- линеаризуемое (как регулярный,
         только если уже прочитал новое значение, то старое нельзя
         прочитать).
      2. По количеству потоков (SR, MR, SW, MW : single/multi
         reader/writer)

    * Будем строить более сложные регистры из простых требуя
      wait-free условие.
      Пусть у нас есть Safe SRSW Boolean регистр.
      1. Regular SRSW Boolean
         #+BEGIN_SRC text
           safe shared boolan r
           threadlocal boolean last

           def write(x):
             if (x != last)
               last = x
               r = x

           def read(): return r
         #+END_SRC
      2. Regular SRSW M-Valued
         Пусть у нас массив r хранит булевые значения, и число в
         нем хранится последовательностью единиц,
         терминированной нулем. Тогда это реализуется так:

         #+BEGIN_SRC text
           regular shared boolean[M] r

           def write(x): // Справа налево
             r[x] = 0
             for i = x-1 downto 0: r[i] = 1

           def read(): // Слева направо
             for i = 0 to M-1: if r[i] == 0: return i
         #+END_SRC
      3. Atomic SRSW M-Valued
         Будем хранить пару -- значение и версию. Версию можно
         разумно ограничить. Есть алгоритм без жульничества с
         версиями, но он на практике плох.

         #+BEGIN_SRC text
           safe shared (int x, int v) r
           threadlocal (int x, int v) lastRead
           threadlocal int lastWriteV

           def write(x):
             lastWriteV++
             r = (x, lastWriteV)

           def read():
             cur = r
             if cur.v > lastRead.v:
               lastRead = cur
             return lastRead.x
         #+END_SRC

         Атомарный регистр: проблемы
         1. Версии -- могут хранить пару в регуярном, но версии
            растут неограниченно.
         2. Блокировки -- алгоритм Лампорта будет работать на
            регулярных регистрах, но это не дает алгоритм без ожидания

         Теорема: не существует алгоритма построения атомарного
         регистра без ожидания, который использует конечное
         число регулярных регистров конечного размера так, чтобы
         их писал только писатель, а читал только читатель
         * Доказательство
           Нужна обратная связь от читателя к писателю.
      4. Atomic MRSW M-Valued
         Нужно отслеживать версию записанного значения, храня пару
         (x, v) в каждом из N регистров в которые пишет писатель.
         Наивно сделать это нельзя.
         Заведем N*(N-1) регистров для общения между читателями.

         1. Каждый читатель выбирает более позднее значение из
            записанного писателем и из прочитанных значенией
            других читателей
         2. ??? Что-то ридеры пишут во все остальные ячейки для
            других читателей
      5. Atomic MRMW M-Valued
         Нужна поддержка N писателей
         Отслеживаем версию записанного значения
         1. Каждый читатель выбирает более позднюю версию
         2. Для проставления версий писателями используем doorway
            секцию из алгоритма булочника (Лампорта)
            * Версия состоит из пары номера потока писателя и
              собственно числа
    * Атомарный снимок состояния N регистров
      Наивная реализация не обеспечивает атомарность.

      #+NAME: lock-free implementation
      #+BEGIN_SRC text
        shared (int x, int v) r[N]

        // wait-free
        def update(i, x):
            r[i] = (x, r[i].v + 1)

        // lock-free
        def scan():
            old = copy()
            loop:
                cur = copy()
                if forall i: cur[i].v == old[i].v
                   return cur.x  // we can get starvation here,
                                 // if update is executed too frequent
                old = cur
      #+END_SRC

      #+NAME: wait-free implementation
      #+BEGIN_SRC text
        def update():
            ??? Потеряна

        shared (int x, int v, int[N] s) r[N]

        // wait-free, O(N^2)
        def scan():
            old = copy()
            boolean updated[N]
            loop:
                cur = copy()
                for i = 0..N-1:
                    if cur[i].v != old[i].v:
                       if updated[i]: return cur.s
                       else:
                        update[i] = true
                        old = cur
                        continue loop
                return cur.x
      #+END_SRC
      * Лемма: Если значение поменялось второй раз, значит копия
        снимка s была получена вложенной операцией scan.
* 05.10.2015
  #+NAME: Консенсус
  #+BEGIN_SRC text
    class Consensus:
          def decide(val):
          ...
          return decision
  #+END_SRC
  Каждый поток использует объект Consensus один раз.
  Требуются две вещи:
  * Согласованность (consistency): все потоки должны вернуть одно и то
    же значение из метода decide.
  * Обоснованность (validity): возвращенное значение было входным
    значением какого-то из потоков.

  #+NAME: Консенсус с блокировкой
  #+BEGIN_SRC text
    shared int decision
    Mutex mutex

    def decide(val):
        mutex.lock()
        if (decision == NA):
           decision = val
        mutex.unlock()
        return decision
  #+END_SRC
  Но мы хотим без ожидания.

  Все не так просто.
  Консенсусное число:
  1. Если с помощью класса атомарных объектов С и атомарных регистров
     можно реализовать консенсусный протокол без ожидания для N
     потоков (и не больше), то говорят что у класса С консенсусное
     число равно N.
  2. Теорема:
     Атомарные регистры имеют консенсусное число 1.
     * То есть с помощью атомарных регистров даже 2 потока не могут
       придти к консенсусу без ожидания (докажем от противного) для 2х
       возможных значений при T = {0, 1}
     * С ожиданием задача решается очевидно (с помощью любого
       алгоритма взаимного исключения).

     Определения и леммы для любых классов объектов:
     * Определения и концепции
       1. Исходны объекты атомарны. Любое исполнение можно
          рассматривать как последовательное в каком-то порядкеc
       2. Рассматриваем дерево состояния, листья -- конечные состояния
          помеченные 0 или 1 (в зависимости от значения консенсуса).
       3. x-валентное состояние системы (x = 0,1) -- консенсус по всех
          нижестоящих листьях будет x.
       4. Бивалентное состояние -- возможен консенсус как 0 так и 1
       5. Критическое состояние -- такое бивалентное состояние, все
          дети которого одновалентны.
     * Лемма: Существует начальное бивалентное состояние
       Это нетривиально следует из того факта, что алгоритм без
       ожиданий.
       Возьмем конечное количество шагов, построим дерево
       ???
     * Лемма: Существует критическое состояние
       Тоже следует из wait-free. Если есть бивалентное, будем
       смотреть его детей. Если есть хотя бы один бивалентный ребенок,
       то спускаемся в него, пока бивалентных детей больше нету.
       За счет конечности дерева такое будет существовать, и
       валентность детей будет различна (иначе валентность самого узла
       тоже определена).

     Для атомарных регистров рассмотрим возможные пары операций в
     критическом состоянии:
     * Операции над разными регистрами коммутируют.
     * Два чтения коммутируют.
     * Любая операция + запись -- состояние пишущего потока не зависит
       от порядка операций. Противоречие (в чем???)
  3. Бывают Read-Modify-Write регистры.
     #+NAME: read-modify-write reg
     #+BEGIN_SRC text
       class RMWRegister:
             private shared int reg

             def read():
                 return reg

             def getAndF(args):
                 do atomically:
                    old = reg
                    reg = F(args)(reg)
                    return old
     #+END_SRC
     Функция F может быть getAndSet, getAndIncrement,...

     #+NAME: Consensus for RMW reg, реализация для 2х потоков
     #+BEGIN_SRC text
       threadlocal int id // 0 or 1

       shared RMWRegister rmw
       shared int proposed[2]

       def decide(val):
           proposed[id] = val
           if (rmw.getAndF() == v0)
               return proposed[i]
           else:
               return proposed[1-i]
     #+END_SRC

     * Консенсусное число нетривиального RMW регистра >= 2
       Нужно чтобы была хотя бы одна подвижная точка функции F,
       например F(v0) == v1 != v0.

  4. Common2 RMW регистры
     * F1 и F2 коммутируют если F1(F2(x)) == F2(F1(x))
     * F1 перезаписывает F2 если F1(F2(x)) == F1(x)
     * Класс С RMW регистров принадлежит Common2 если любая пара
       функций либо коммутирует либо одна из функций перезаписывает
       другую
     * Теорема: нетривиальный класс Common2 RMW регистров имеет
       консенсусное число 2
       Третий поток не может отличить глобальное состояние при
       изменении порядка ????
  5. Универсальные объекты
     Объект с консенсусным числом ∞ называется универсальным объектом.
     По определению, с его помощью можно реализовать консенсусный
     протокол для любого числа потоков.

     #+NAME: CAS register
     #+BEGIN_SRC text
       class CASRegister:
             private shared int reg

             def CAS(expect, update):
                 do atomically:
                    old = reg
                    if old == expect:
                       reg = update
                       return true
                    return false
     #+END_SRC
     CAS -- самый популярный универсальный объект, процессоры в том
     или ином виде его реализуют.

     * CAS и консенсус
       #+NAME: реализация протокола через CAS+READ
       #+BEGIN_SRC text
         def decide(val):
             if CAS(NA, val):
                 return val
             else:
                 return read()
       #+END_SRC

     * Универсальность консенсуса. Теорема.
       Любой последовательый объект можно реализовать без ожидания для
       N потоков используя консенсусный протокол для N объектов

       + Такое построение -- универсальная конструкция
       + Следствие 1: С помощью любого класса объектов с консенсусным
         числом N можно реализовать любой объект с консенсусным числом
         ≤ N
       + Следствие 2: С помощью универсального объекта можно
         реализовать вообще любой объект
         * Сначала реализуем консенсус для любого числа потоков (по
           определению универсального объекта)
         * Потом через консенсус любой другой объект используя
           универсальную конструкцию.
       + Доказательство теоремы
         1. Универсальная конструкция без блокировки через CAS
            #+BEGIN_SRC text
              shared CASRegister reg

              def concurrentOperationX(args):
                  loop:
                      old = reg.read()
                      upd = old.deepCopy()
                      res = upd.serialOperationX(args)
                  until reg.CAS(old, upd)
                  return res
            #+END_SRC

            * Без блокировки универсальная конструкция проста и
              проктична, если использовать CAS в качестве примитива.
            * Для реализации через консенсус надо чтобы каждый объект
              консенсуса пользовался потоком один раз
            * Для реализации без ожидания нужно чтобы потоки помогали
              друг другу.
         2. Через консенсус
            #+NAME: Через консенсус без блокировки
            #+BEGIN_SRC text
              class Node:
                    val               // readonly
                    Consensus next    // init fresh obj

              shared Node root        // readonly
              threadlocal Node last   // init rood

              def concurrentOperationX(args):
                  loop:
                      old = last.val
                      upd = old.deepCopy()
                      res = upd.serialOperationX(args)
                      node = new Node(upd)
                      last = last.next.decide(node)
                  until last == node
                  return res
            #+END_SRC

            * Но с ожиданием

         3. Через консенсус без ожидания (1)
            СЛИШКОМ БЫСТРО
         4. Через консенсус без ожидания (2)
         5. Через консенсус без ожидания (3)
         6. Через консенсус без ожидания (4)
  6. Сводная иерархия
     |--------------------------------------------+--------------------|
     | Объект                                     | Консенсусное число |
     |--------------------------------------------+--------------------|
     | Атомарные регичтры                         | 1                  |
     | Снимок состояния нескольких регистров      |                    |
     |--------------------------------------------+--------------------|
     | getAndSet, getAndAdd, очередь, стек        | 2                  |
     |--------------------------------------------+--------------------|
     | Атомарная запись m регистров из m(m+1)/2   | m                  |
     |--------------------------------------------+--------------------|
     | compareAndSet, LoadLinked/StoreConditional | ∞                  |
     |--------------------------------------------+--------------------|
