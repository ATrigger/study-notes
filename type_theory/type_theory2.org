#+TODO: X 0 1 2 | OK
#+TITLE: Tеория типов, часть вторая.

* Martin-Lof type system
** Вступление
   Напомним всем, чем отличается конструктивный интуиционизм от
   классического подхода. Наглядная иллюстрация: конструктивное
   доказательство очень близко к компьютерной программе. Пусть нужно
   доказать:
   (∀x∈A)(∃y∈B)P(x,y)                                        (1)
   С конструктивной точки зрения, вывод такого утверждения значит
   показать функцию f, такую что f:A → B, и она дает ровно нужный y для
   того чтобы удовлетворить P(x, y). Тогда если (1) выражает некоторую
   спецификацию, то конкретная f -- это программа, удовлетворяющая этой
   спецификации. Отсюда конструктивное доказательство может
   рассматриваться как программа, а процесс вычисления значения --
   нормализация доказательства.

   # Забавные (?) факты.
   Был такой ученый, значит, Brouwer Luitzen Egbertus Jan (Брауер
   Лёйтзен Эгберт Ян, фамилия -- первое) (1881-1966), голлндский
   математик. Ему удалось в некоторый момент показать, что в
   некоторых случаях невычислимость функций классической математики
   исходит не от аксиомы выбора, как тогда было принято считать, а от
   таких вещей, как правило исключенного третьего, доказательство от
   противного и закон снятия двойного отрицания. Брауера называют
   основоположником интуиционизма, хотя идею в основном развил
   Гейтинг, его ученик (Гейтинг сформулировал интуиционистскую логику
   в 1930).

   # Рассказать что-то про интенсиональность и экстенциональность
   # теории типов.
** Утверждения как множества
#   Первоначально идея воспринимать утверждения как множества была
#   выдвинута Карри, впоследствии того, что было замечено сходство
#   аксиом импликативного фрагмента интуиционистской логики первого
#   порядка:
#   A ⊃ B ⊃ A
#   (A ⊃ B ⊃ C) ⊃ (A ⊃ B) ⊃ A ⊃ C
#   С типами базовых комбинаторов K и S:
#   K ∈ A → B → A
#   S ∈ (A → B → C) → (A → B) → A → C
#   Тогда MP соответствует применению функций (комбинаторов).
   Утверждения можно сопоставлять множествам. Это можно увидеть,
   рассмотрев объяснения Гейтинга в терминах доказательств.
   Для импликации верно:
   Доказательство A ⊃ B -- функция, которая по каждому доказательству
   A выдает доказательство B.
   Нотация функции или метода тут примитивна в конструктивной
   математике, и функцию из A в B можно рассматривать как программу,
   которая, когда применена к элементу из A, выдает элемент B как
   выходной параметр. Давайте тогда сопоставим утверждение с набором
   его доказательств:
   * A ⊃ B сопоставимо с A → B, множество функций из A в B.
   Элементы из A → B имеют форму λx.b, где b ∈ B, и b зависит от x∈A.

   Гейтинг обяъсняет конъюнкцию как пару из двух доказательств. Тогда
   сопоставление с множеством очевидно:
   * A ∧ B сопоставимо с A × B, прямое произведение A и B.

   Для дизъюнкции -- она верна, если у нас есть доказательство одного
   из двух утверждений, причем с конкретным указанием, какого. Отсюда:
   * A ∨ B сопоставимо с A + B.
   Элементы A + B имеют форму inl(a) или inr(b), где a∈A, b∈B.

   ¬A ≡ A ⊃ ⊥.
   С таким определением, где ⊥ -- противоречие, утвеждение без
   доказательства, сопоставление таково:
   * ¬A сопоставимо с A → ∅.

   Чтобы отождествить утверждения с кванторами, нам нужны операции на
   наборах множеств. Пусть B[x ← a] -- выражение, полученное
   подстановкой a для всех свободных вхождений x в B. Тогда Гейтингово
   объяснение таково:
   Доказательство (∃x ∈ A)B состоит из построения элемента a множества A
   вместе с доказательством B[x ← a].
   Таким образом, доказательство -- пара. Сопоставимое с парой
   множество -- это непересекающееся объединение множеств,
   обозначающееся (∑x ∈ A)B. Элементы -- пары <a,b>, где a∈A, b∈B[x ← a].
   Тогда формальное сопоставление таково:
   * (∃x ∈ A)B сопоставляется с множеством (∑x ∈ A)B.

   И, наконец, квантор всеобщности:
   Доказательство (∀x ∈ A)B -- функция (метод/программа), которая
   каждому элементу a из множества A сопоставляет доказательство
   B[x ← a].
   Множество, которое соответствует квантору всеобщности -- прямое
   произведение семейства множеств, обозначается (Πx ∈ A)B. Элементы
   этого множества -- функции, которые, в применении к элементу a ∈ A
   возвращают элемент B[x ← a]. Отсюда, формально:
   * (∀x ∈ A)B сопоставляется с множеством (Πx ∈ A)B.
   Элементы (Πx ∈ A)B находятся в форме λx.b, где b ∈ B, причем как b
   так и B зависят от x ∈ A. Отметим, что если B не зависит от x, то
   (Πx ∈ A)B есть то же самое, что и A → B, отсюда можно обойтись без
   →, если есть прямое произведение семейства множеств. В этом же
   смысле, (∑x ∈ A)B есть ничто иное, как A × B, когда B не зависит от
   x.

   Все эти нотации -- сахар, который будет раскрыт позже.
** Типы, их равенство, равенство объектов
   Базовая нотация в MLTT -- нотация типа. Объясним, что такое тип, и
   что значит для двух типов быть идентичными. Мы проводим суждение
   A -- тип, и формально записываем это как "A type", когда знаем
   условия для того, чтобы утверждать "некий объект имеет тип A" и
   когда знаем условия для того, чтобы утверждать, что два объекта типа A
   идентичны. Последнее условие должно определять отношение
   эквивалентности.
   Первое есть удовлетворение следующего условия:
   a -- объект типа A.
   Что формально записывается:
   a ∈ A.
   Второе -- удовлетворение такого условия:
   a и b -- идентичные объекты типа A.
   Что формально записывается
   a = b ∈ A

   A -- тип, если знаем условия для того, чтобы утверждать:
   1. a ∈ A
   2. a = b ∈ A

   Равенство на типах выполняется, когда объект одного типа является
   объектом и другого типа и когда два идентичных объекта одного типа
   являются идентичными для другого.
   A и B идентичны.
   A = B.
   Равенство на объектах симметрично, рефлексивно и транзитивно.
   * a ∈ A                ⇒⇒ a = a ∈ A
   * a = b ∈ A            ⇒⇒ b = a ∈ A
   * a = b ∈ A, b = c ∈ A ⇒⇒ a = c ∈ A
   Равенство на типах тоже есть отношение эквивалентности.
   * A type       ⇒⇒ A = A
   * A = B        ⇒⇒ B = A
   * A = B, B = C ⇒⇒ A = C
   Кроме того, равенство на типах:
   * a ∈ A, A = B     ⇒⇒ a ∈ B
   * a = b ∈ A, A = B ⇒⇒ a = b ∈ B
** Гипотетические суждения, контекст
   Гипотетическое суждение -- суждение, сделанное в контексте:
   x₁ ∈ A₁, x₂ ∈ A₂, ... xₙ ∈ Aₙ
   Где A₁ тип, A₂ тип в контексте x₁ ∈ A₁, ... Aₙ тип в контексте
   всех перед ним.

   Пусть C -- тип, не зависящий ни от каких посылок. Тогда A -- тип,
   когда x ∈ C:
   A type [x ∈ C]
   То есть для любого c ∈ C A[x ← c] есть тип.
   Тогда A будет называться семеством типов над (over) C.

   * A = B [x ∈ C] значит, что A[x ← c], B[x ← c] одинаковые типы для
     любого c ∈ C.
   * a ∈ A [x ∈ C] значит, что a -- объект типа A при x ∈ C, то есть
     мы уже знаем, что a[x ← c] есть объект типа A[x ← c] для любого
     c ∈ C.

   Пусть x₁∈A, x₂∈A₂,...xₙ∈Aₙ -- контекст длины n-1.
   Тогда верно:
   A₁ type
   A₁ type [x₁ ∈ A₁]
   ...
   Aₙ type [x₁ ∈ A₁, x₂ ∈ A₂, ... x{n-1} ∈ A{n-1}]

   Допустим мы хотим знать
   A type [x₁ ∈ A₁, ... xₙ ∈ Aₙ]
   Это значит (формально), что мы хотим знать следующее:
   A[x₁ ← a] type [x₂ ∈ A₂ [x₁ ← a],... xₙ ∈ Aₙ [xₙ ← a]]
   Причем такое утврерждение должно быть верно в пустом контексте.
   Тогда если к томе же a = b ∈ A, также верно:
   A[x₁ ← a] = A[x₁ ← b] [x₂ ∈ A₂ [x₁ ← a],... xₙ ∈ Aₙ [xₙ ← a]]
   Формально это выражается так:
   * A type [x₁ ∈ A₁...xₙ ∈ Aₙ], a ∈ A₁     ⇒⇒
     A[x₁ ← a] type [x₂ ∈ A₂[x₁ ← a],.. xₙ ∈ Aₙ[x₁ ← a]]
   * A type [x₁ ∈ A₁...xₙ ∈ Aₙ], a = b ∈ A₁ ⇒⇒
     A[x₁ ← a] = A[x₁ ← b] [x₂ ∈ A₂[x₁ ← a],.. xₙ ∈ Aₙ[x₁ ← a]]

   Подстановка в равных типах:
   Пусть A, B -- типы в контексте [x₁ ∈ A₁...xₙ ∈ Aₙ].
   * A = B [x₁ ∈ A₁...xₙ ∈ Aₙ], a ∈ A₁ ⇒⇒
     A[x₁ ← a] = B[x₁ ← a] [x₂ ∈ A₂[xᵢ ← a],...xₙ ∈ Aₙ[xᵢ ← a]]

   Подстановка в объектах:
   Пусть A -- тип в контексте [x₁ ∈ A₁...xₙ ∈ Aₙ].
   * a ∈ A [x₁ ∈ A₁...xₙ ∈ Aₙ], a ∈ A₁ ⇒⇒
     a[x₁ ← a] ∈ A[x₁ ← a] [x₂ ∈ A₂[xᵢ ← a],...xₙ ∈ Aₙ[xᵢ ← a]]

   Подстановка в равных объектах:
   Пусть c = d ∈ A -- тип в контексте [x₁ ∈ A₁...xₙ ∈ Aₙ].
   * c = d ∈ A [x₁ ∈ A₁...xₙ ∈ Aₙ], a ∈ A₁ ⇒⇒
     c[x₁ ← a] = d[x₁ ← a] ∈ A[x₁ ← a]
                            [x₂ ∈ A₂[xᵢ ← a],...xₙ ∈ Aₙ[xᵢ ← a]]

   Предположение:
   A₁ type
   A₂ type [x₁ ∈ A₁]
   ...
   Aₙ type [x₁ ∈ A₁ ... до n-1]
   A type [x₁ ∈ A₁ ... xₙ ∈ Aₙ]
   ⇒⇒
   x ∈ A[x₁ ∈ A₁...xₙ ∈ Aₙ, x ∈ A]
