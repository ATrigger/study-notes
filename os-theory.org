#+TODO: X 0 1 2 | 3
#+TITLE: Tickets for exam on operating systems lectures course given by Yan Malakhovski, 4th term, 2015

* Legend
  X -- нифига не написано и непонятно, где брать
  0 -- нифига не написано
  1 -- что-то написано, но не дописано
  2 -- написано, но возможно, что что-то серьезно упущено
  3 -- все хорошо.
* Sources
  Тут только самые важные источники. Всякие статьи, которые по мере необходимости встречаются в тексте, встречаются только там.
  1. Raw notes by volhovm
  2. OS course plan
     http://rain.ifmo.ru/~trojan/linux/year2009/
  3. Yet another plan
     http://rain.ifmo.ru/~trojan/linux/year2007/
  4. Prev. year googledoc
     https://docs.google.com/spreadsheets/d/1CoPjN7shou3m3kAQdsRHY1HxQYyKho5f7Qn1KeL9n-U/edit#gid=0
  5. Malakhovski's notes
     https://github.com/oxij/unix-notes-ru/blob/master/compiled/main.pdf
  6. Wikipedia ofc
* Ticket 1
** RAM, SRAM, DRAM
** Структурно-операционная схема обычной планки памяти (DDR)
** Кеши CPU: L1, L2, L3
** Схема параллельного извлечения
** Извлечение демультиплексором
** Ассоциативность
** TLB
** Общее влияние кеша на работу с памятью
** Кеши в мультипроцессорных системах и когерентность кешей
* Ticket 2
** Пайплайн и стадии
** Регистровый файл
** Пузыри (pipeline bubbles)
** Предсказание переходов (branch prediction)
** Out of order исполнение
** Интерфейс между устройствами ввода и CPU
** Прерывания
** DMA
* Ticket 3
** Виртуальная память
** MMU: TLB, каталог страниц (page table)
** Биты: readable, writeable, executable, present, dirty, copy-on-write
** IOMMU
** Память процессов
** Общая память
** Пулы памяти со специальными требованиями.
* 0 Ticket 4
** "География" адресного пространства процесса
** Структуры ядра описывающие процесс с MMU: работа с физической памятью, VMA
** Системные вызовы: brk, sbrk, mmap
** Общая память: mmaping файлов и shm_open
** Реализация malloc.
* 0 Ticket 5
** Процессы и треды
** init, родители, дети, зомби
** Треды, группы тредов, процессы, группы процессов, сессии
** Системные вызовы fork, clone, exec, wait
** Интерфейс bash
** Реализация переключения контекстов процессов: структуры данных ядра, состояния процессов, различные методы реализации CPS-преобразования.
* 0 Ticket 6
** Файловые дескрипторы и пайпы
** Системные вызовы open, read, write, close
** Структуры данных ядра: таблица файловых дескрипторов, файловые объекты POSIX, флаг CLOEXEC
** Системные вызовы dup2, fcntl, flock
** Структуры данных ядра для реализации пайпов, семафоров, блокировок на файлы.
* 0 Ticket 7
** Драйвера устройств в пространстве ядра
** Прерывания
** Монолитная обработка прерываний
** Hi/Lo прерывания
** Polling
** Драйвера как контексты исполнения и их отличия от процессов
** Реализация драйверов: структуры данных ядра, различные методы реализации CPS-преобразования.
* 0 Ticket 8    FS
** Файловые системы
** Структура данных inode
** VFS
** Структуры данных: FSObject, Namespace
** Path resolution
** Операции над неймспейсами: mount, bind mount, move mount, chroot, pivot_root
** Linux FUSE
** ФС как функция inodeno → inode
** Структуры ядра: файловый дескриптор (на устройство, файл, директорию), различные кеши
** mmaping файлов.
* 0 Ticket 9    Users/access
** Пользователи и права
** Модели прав доступа к объектам: дискретная и ролевая
** Права на объекты файловой системы
** Пользователи и группы с точки зрения ядра
** Пользователи и группы с точки зрения пространства пользователя
** Системные вызовы setuid, setgid и товарищи
** setuid bit
** PAM
** /etc/passwd, /etc/shadow, /etc/group
** Capabilities.
* 0 Ticket 10   Signals
** Стандартные сигналы
** Маски
** Правила доставки
** Реалтаймовые сигналы
** Маски и очереди
** Правила доставки
** Системные вызовы kill, sigaction
** Прерывание сигналами: кода программы, обработчиков сигналов, системных вызовов
** Реентрабельность и безопасные системные вызовы
** Сигналы и треды
** Семантика сигналов: TERM, KILL, STOP, CONT, CHLD, PIPE, ILL/FPE, SEGV, BUS.
* 0 Ticket 11   Polling
** Мултиплексирование ввода-вывода
** O_NONBLOCK
** Edge и level triggered события
** Преобразование асинхронного ввода-вывода в синхронный CPS-преобразованием
** Структуры данных пространства ядра для реализации мультиплексора файловых дескрипторов
** Системные вызовы select, poll, epoll
** Управление скоростью передачи данных через файловые дескрипторы.
* 0 Ticket 12   Synchronisation
** Синхронизация
** Спинлоки
** Ядерные семафоры
** Блокировки и лизинги на файлы
** Структуры данных пространства ядра для реализации блокировок и лизингов
** Системные вызовы: flock, fcntl.
* 2 Ticket 13   Netstack
** Сетевой стек
   Сетевой стек -- весь набор протоколов необходимых для соединения компюьтеров друг к другу.
   OSI -- один из первых базовых сетевых стеков, который не допилили. BSD сокеты -- протокол, который развивался параллельно. Проблема OSI с их разработкой была в планировке, к примеру часть разработчиков хотела разрабатывать пакетную передачу данных (на тот момент новшество), но разработчики из бывшых телефонных компаниях считали эту затею плохой. До пакетной передачи соединение обеспечивалось правильным подключением клиентов друг к другу через свичи.
   Существует три широко используемых протокола низшего уровня: MAC(через Ethernet/DSL), PPP, ARP.
   Первый всем хорошо известен, второй -- это как раз телефоны, третий используется для общения между устройствами в сети для обмена данными необходимыми для других протоколов (IP → MAC).
** PPP
** Ethernet
   Самый простой сетевой порт это COM. У него 6 проводов, одна пара из которых передает данные в одну сторону, пара в другую, еще пара сигнальная. Двухпроводное решение широко используется, есть однопроводные, которые очень сложные и непопулярные (чипы в домофонах!). После установления соединения, по проводу передается меандр. Проблемы COM-порта в нарушении целостности сигнала из-за наводки.
   Ethernet реализован чаще всего в формате UTP (unshielded twisted pair) -- много маленьких проводов очень сильно скручены друг между другом. Сигнал по витой паре задается разницой потенциалов (по 2м соседним проводам передаются сигналы, а смысл имеет их разница). Такое решение имеет смысл, потому что любая наводка одинаково искажает сигнал на двух проводах и разность остается неизменной. UTP чаще всего в этой стране встречается в формате двух и четырех пар проводов. Проводов для синхронизации нету, SIGHUB генерируется по таймауту.
   Еще есть коаксиальный кабель (тонкий кабель внутри обертки), профит которого в том, что обертка как-то защищает внутренний кабель от помех, выступая некой клеткой Фарадея.
   Сеть по формату Ethernet до 1Гб/c реализуется подключением всех юзеров к одной общей ethernet-шине. Политика такая: пока кто-то посылает пакеты, другие молчат. Если есть несколько пользователей, которые пользуются шиной одновременно, все замолкают на рандомный интервал времени, потом продолжают. [[https://en.wikipedia.org/wiki/Carrier_sense_multiple_access_with_collision_detection][CSMA/CD]]
   Сеть с большей скоростью нуждается в различных вспомогательных машинах, типа хабов.
   Хаб -- железяка, которая передает пакеты, которые ему приходят, на все свои выходы (броадкастит).
   Есть еще параллельный COM для принтеров, называется LBT. Параллельные шины плохи, потому что сложно синхронизировать передачу данных по многим проводам одновременно, учитывая всякие помехи.

   Ethernet пакет по стандарту (802.3) состоит из:
   1. Преамбула (какие-то метаданные)
   2. Header
      1. Протокол (ethertype) -- есть разные форматы ethernet (LLC, Ethernet II)
      2. Size of packet (or data). MTU -- 1500.
      3. Два MAC-адреса (отправитель и получатель)
   3. Payload (всякие данные)
   4. CRC всего кроме данных
   Больше здесь: [[https://en.wikipedia.org/wiki/Ethernet_frame][Ethernet Frame]].

   Wifi представляет из себя Ethernet по радио. Есть некоторый диапазон частот разрешенный для использования wifi-устройствами, который разделен на поддиапазоны -- каналы. В разных странах используются разные диапазоны. Wifi передает синусоиду, все как по радио, с этими вашими модуляциями.
** IP
   IP протокол находится на уровне выше и обычно запихивается в Ethernet. IP пакет содержит флаги, IP адресата/адресанта, данные и crc для всего кроме данных.
   Сетевые карты обычно фильтруют пакеты которые ей не принадлежат (адрес назначения не совпадает с нашим) на уровне MAC, IP пакеты фильтрует уже ОС. И то и другое поведение может быть изменено с помощью [[https://en.wikipedia.org/wiki/Promiscuous_mode][promiscuous mode]] опции.
   Ethernet bonding — это объединение двух или более физических сетевых интерфейсов в один виртуальный для обеспечения отказоустойчивости и повышения пропускной способности. Гуглится.

   IP -- уникальный идентификатор размером в 4 байта. Подсети бывают классов A, B и C. Для класса A определена маска 255.0.0.0, для B 255.255.0.0, для C 255.255.255.0. Кроме того, определены зарезервированные адреса для сетей: A: 10.0.0.0, B: 172.16.0.0 -- 172.13.0.0, C: 192.168.0.0 -- 192.168.255.0. Маска подсети -- число от 0 до 32, означающее количество единичек перед ноликами в двоичной записи 4-байтового числа. Маска записывается как IP. 24 -- 255.255.255.0, 31 -- 255.255.255.255. Первая нотация называется префиксной (CIDR).
   Работает это следующим образом. Пусть нужно отправить пакет. У каждого интерфейса в компьютере есть своя маска и IP (ifconfig -a). ОС выбирает интерфейс, который наиболее близок по маске с ip с ip адресата (сравниваются and, полагаю). В BSD сокетах это поведение реализуется, если делать bind(0.0.0.0). Можно сделать bind на конкретный интерфейс, и тогда пакеты будут отправляться ровно куда надо.
   Ядро хранит таблицу роутинга, которая говорит, какие пакеты в какой интерфейс пихать (ip r, netstat -rn, route). Есть дефолтный гейтвей (шлюз по умолчанию), в который отправляются пакеты, если они не матчатся по другим маскам (default в route).
** ARP
   Проблема отправки IP пакетов состоит в том, что нам нужны MAC-адреса (можно указать MAC broadcast ff:ff:ff:ff:ff:ff). Для того, чтобы по IP найти MAC, существует протокол ARP. Ядро содержит ARP-таблицу, которая заполняется по мере необходимости и отображает IP в MAC (arp -e). Если в таблице нет записи, а нужно отправить, по сети прогоняется ARP-запрос на уровне "у кого тут такой ip?", и получает ответ.
   Обратный протокол получения IP по MAC первоначально назывался RARP (reversed ARP). Потом он перетек в BOOTP, теперь это DHCP. Существенная разница RARP и DHCP в том, что DHCP -- протокол на уровне TCP/IP, а RARP был на netlink уровне (самом низком). Зачем DHCP оборачивать в IP -- никто не знает.
** Hardware
   Свитч -- это хаб с ARP таблицей внутри, который умеет отправлять пакеты не всем сразу (как хаб), а только тем, кому надо, если в ARP-таблице есть необходимая запись.
   Маршрутизатор -- это свитч с таблицей маршрутизации! Конечно, он тоже имеет ARP, и чаще всего связывает локальную сеть с внешним миром. В таком случае, обычно, в локальной сети у нодов дефолтный гейтвей как раз машрутизатор. Сам маршрутизатор получает свой дефолтный гейтвей обычно от провайдера.
** TCP/UDP/SCIP
   Протоколы, которые обычно запихивают в IP: UDP, TCP, SCIP
   1. UDP, TCP: хедеры, в UDP crc берется от хедеров, в TCP от всего пакета. UDP не обеспечивает никакого механизма проеврки доставки пакета, в отличии от TCP. TCP/UDP пакеты внутри содержат порт (/etc/services).
      Механизм подключения в TCP похож на трехкратное рукопожатие:
      1. Отправляется запрос 1→2 (syn)
      2. Отправляется подтверждение о получении запроса 2→1 (syn-ack, ack = acknowledgment), эта сторона запоминает кому отправила syn-ack
      3. Клиент отправляет 1→2 (ack) еще раз и сервер проверяет, правда ли, что отправлял клиенту syn-ack. Если да, соединение установлено.
      Забавное наблюдение заключается в том, что можно много раз отправлять некоторому набору серверов syn с подмененным ip возврата, и syn-ack будут возвращаться на желаемый адрес, от чего желаемому адресу может стать плохо. Еще минус -- приходится хранить в сервере данные о том, кому отправил syn-ack.
   2. SCTP (stream control transport protocol) -- штука похожая на TCP, но если среди N пакетов некоторые зафейлились, то только зафейленные будут отправляться заново (в TCP все начиная с первого зафейленного). Кроме того, этот протокол подразумевает, что всякие данные для подключения отправляются клиенту от сервера зашифрованными и только сервер может их расшифровать, когда эти же данные ему придут в ack. Отпадает необходимость помнить о syn-ack которые сервер отправляет.

   IPv6 имеет все из коробки внутри. Имеет обратную совместимость с IPv4, зашитый внутрь MAC. Утверждается, что использование IPv6 избавляет от необходимости использовать NAT и DHCP.
** BSD sockets: API, Stream-сокеты, Datagram-сокеты, RAW-сокеты, файловый объект для accept-сокета.
   man socket
   BSD socket API выглядит примерно так (по всему лучше читать man):
   * socket(...) -- создать сокет. Тут устанавливаются всякие параметры, тип сокета (datagram -- UDP, stream -- TCP), другие настройки.
   * connect(...) -- создать соединение на сокете. Первоначально сокет висит в пространстве и ничего не делает, connect его инициализирует.
   * bind(...) -- другой способ инициализации сокета, серверный.
   * listen(...) -- обычно следует за bind.
   * getaddrinfo(...) -- супер обобщенный вызов, возвращающий данные о хосте, которые могут быть использованы для создания сокетов. Прелесть в том, что он удобный и одинаковый для ipv4/v6 сокетов (и еще много чего).
     Есть файл /etc/nsswitch.conf. Сервисы типа getaddrinfo пользуются им чтобы определить откуда искать данные. К примеру, в nsswitch поле hosts хранит "files dns", что соответствует /etc/host.conf и /etc/resolv.conf. Есть демон nscd, который занимается тем, что резолвит запросы "откуда мне бы почитать". Этот демон первоначально запускается от рута и как-то связан с ldap, может резолвить пароли. Есть еще PAM, которой все пользуются (su), и иногда эти сервисы могут конфликтить.

   man socket описывает семейства сокетов как IPv4, IPv6, полезно еще знать про существование AF_UNIX, который используется для общения ядра самого с собой.
   Сокет конкретного семейства имеет тип. RAW сокеты -- это уровень IPv4, но сырой, без части хедеров. Поскольку с такими сокетами можно набагать и застопорить какую-нибудь очередь IO, они доступны только руту.

** ICMP, TFTP, DNS, NAT
   ICMP протокол, который завернут в Ethernet, используется для общения между роутерами, логирования ошибок, для ping/traceroute. IP пакеты имеют TTL и на каждом hop отправляют запрос обратно.
   TFTP -- UDP-протокол, обеспечивающий наивную реализацию того, что делает FTP (достань-ка мне тот файл).
   DNS -- /etc/resolv.conf. Та самая штука, которая мапит имена в <host,port>. Самый простой вариант использовать DNS -- gethostbyname -- как раз получает IP по хосту. DNS пакеты имеют тип и имя. Типы: A(IPv4), AAAA(IPv4), MX(email), TXT(что угодно). Именем является хост. Ответы бывают рекурсивными и нет. Рекурсивные ответы возвращают кучу ip-адресов, соответсвтующих одному хосту (например, сервер распределяется между несколькими хостами для уменьшения нагрузки).
   NAT (network address translation): пусть есть локальная сеть и мы пользуемся внутри локальной адресацией. Тогда если узел отправляет пакет во внешний мир, он проходит через шлюз по умолчанию. Устройство, которое имеет адрес шлюза, содержит таблицу, которая сохраняет данные о пакетах. Устройство подменяет source пакета на свой, и отправляет куда надо. Когда возвращается ответ, он перенаправляется юзеру согласно таблице. Существуют хаки, которые позволяют отправлять пакеты напрямую. Гуглить tsocks, UPnP.
* 0 Ticket 14
** Терминалы и управление заданиями в POSIX
** Терминалы, псевдотерминалы и режимы их работы
** Группы процессов и сессии
** Foreground и background группы
** Сигналы: INT, HUP, TSTP, TTIN, TTOU, WINCH
** Демоны и демонизация.
* 0 Ticket 15
  There's -2 level of execution, for example something that governs how to operate with cooler.
  Available protocols for hard drives and stuff:
  ATA-IDE, SATA-SCSI. BIOS loads first 512b - MBR - from hard drive and loads system. Standard MBR program reads something from HDD. For example, any bootloader like grub or lilo. USB is harder to program than sata -- one should rapidly poll USB device to get any data, so the driver is harder to write.
  PXE is loading from network, that uses driver for the netcard on your motherboard. Long time ago, a driver for netcard was located on the netcard itself. It uses Now the most popular is pxelinux or ipxe. pxelinux also supports TCP that's cool, because basic TFTP by UDP can lose some packets, and it's kind of critical, when kernel size is bigger then epsilon, so there's an overhead because of re-downloading the kernel.
** Загрузка: BIOS → MBR (DOS Label), DOS/Windows boot, GRUB
** initrd
** Инициализация системы: последовательная, учитывая зависимости, resource/socket activation, lazy activation
** Стандартные init системы: System V init (не забыв про runlevel), Upstart, OpenRC, systemd
** Стандартные демоны: init, syslog, klog, cron, at, ssh
** Стандартные файлы /etc: fstab, mtab, sysctl.conf, motd, issue, nologin.
* 0 Ticket 16
** Запуск программ, динамическая линковка и загрузка
** Exec magic и интерпретаторы
** Релокация кода: релокационные дырки, кеширование релокаций, GOT, PIC
** Объектные, исполняемые и библиотечные файлы
** Формат ELF
** ld-linux и его x86 32 шные ужасы.
