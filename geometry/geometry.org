* Трехмерные выпуклые оболочки (CHN)
  В чем проблема с оболочкой?

  (CHN_1)

  Начнем с подзадачи: пусть у нас есть две каких-то верхних оболочки в
  ℝ² , разделенных по иксу. Мы хотим объединить эти верхних оболочки,
  проведя касательную сверху. Как такую касательную построить? (inb4
  такая существует, потому что "палка сверху падает на холмики"). Как
  искать такую касательную за логарифм?

  Очевидно, что касательная не проходит по экстремальным точкам
  (нарисуем большой холмик и рядом маленький).

  Если мы хотим за логарифм, то че делать?

  (CHN_2)

  Предположим, что есть пара точек на холмах. Будем типа пользоваться
  некоторым подобием бинпоиска на двух холмах сразу -- четыре границы
  одновременно. Ну, два массивчика -- это два множества точек для двух
  оболочек, отсортированных по иксу.

  (CHN_3) описывает классификацию всех попаданий касательной к кускам
  выпуклой оболочки для левой и правой кучи. Эта классификация важна,
  так как по ней мы будем определять текущее состояние. Как эти
  состояния отличать, понятно -- считаем повороты. Случаи с двумя
  точками по одну сторону классифицируются поворотом.

  (CHN_4)

  Рассмотрим случай A в CHN_2. Рассмотрим прямую l и какую-то
  касательную к левой куче. Утверждается, что если мы будем
  поворачивать касательную вокруг точки касания, поворачивать вниз, то
  пересечение касательной и l как точка, будет опускаться вниз.
  Короче случай A распознается так: это случай слева a), а справа
  г). Тогда мы можем отрезать нижние куски выпуклых оболочек.

  Проверка на два случая делается за 2*2 = 4 поворота.

  Рассмотрим остальные случаи, например B в CHN_2. В этом случае мы
  можем откинуть нижнюю часть правой оболочки. Симметричный случай
  тоже очевиден.

  Случай с двумя касательными тоже распознается однозначно и есть
  ответом.

  (CHN_5)

  Пусть на правом холме у нас касательная, а на левом точка из случая
  a) -- CHN_5 A. Тогда на левом холме мы можем откусить нижний кусок, а на правом
  -- левый нижний от касательной. Симметрично тоже.

  CHN_5 B тоже так решается, то есть можно слева откусить нижний, а
  справа нижний левее точки касания.

  (CHN_6)

  Теперь рассмотрим самый нетривиальный случай: пусть слева б), а
  справа д). Рассмотрим пересечение прямых l₁ и l₂. Прямые проведем
  через текущие вершины и следующие выше. Проверим точку L пересечения
  l₁ и l₂. Тогда если прямая L лежит полностью в интервале между
  холмами, то можем выкинуть и у левого и у правого нижние куски. Если
  точка L лежит в левом холме (левее самой правой точки левого холма),
  то мы выкидываем весь нижний кусок только левого холма вместе с этой
  точкой. Аналогично с правым холмом.

  Теперь мы умеем решать задачу найти касательную двух верхних
  полуоболочек.

  Тут Славик рассказал способ найти касательную точки и многоугольника
  с помощью подразбиения многоугольника на подмногоугольники (каждый
  вложенный берет точки предыдущего через одну). Потом он типа ищет
  для самого вложенного треугольника касательную, а потом
  передвигается к более богатым многоугольникам, сдвигая касательную
  влево или вправо на одну вершину. Тоже алгоритм за log(n). Типа на
  каждом шаге есть step, мы рассматриваем текущего кандидата на
  касательную + step и -step. Выбираем лучшего, переходим к нему и
  делим шаг на два.

  А как найти все четыре касательные для двух выпуклых множеств?
  Можно разбить на несколько и сведем к предыдущей задачи. Без этого?
  Нетривиальненько.



  Теперь мы хотим честного итеративного построения. Можно хранить
  оболочки skip-листом и вместо бинпоиска просто спускаться на нижний
  уровень и ходить там. Вот мы идем по какому-то уровню, берем
  вершинку. Вдруг мы поняли, что нужно отрезать левую часть
  листа. Пойдем вправо. Спускаемся вниз, если нужно пойти в какую-то
  сторону, а та вершина уже "отрезана".

  (CHN_7)

  Пусть есть оболочка, являющаяся общей частью двух оболочек. Типа
  дана оболочка, есть указатель на точку, по которой нужно
  разделиться. Причем у нас есть синяя и красная (карандашом) часть.
  Тогда мы можем фактически сделать две оболочки -- это за 2 * logn
  для объединения двух скиплистов.

  А как вообще все хранить, чтобы было итеративно? Будем хранить
  дерево, в котором листья -- наши точки, а другие узлы -- это верхняя
  оболочка сыновей. Это n*logn памяти, а хотим меньше. Причем
  неочевидно, как делать удаление. Как добавить? Прокинуть вершину
  вниз и перестроить все оболочки вверх во время просеивания. Если
  дерево нужно балансировать, то тоже нормально -- перестроим
  что-нибудь.

  Можно, формально, хранить немного не так: в самом верхнем узле будет
  храниться честная выпуклая оболочка всех точек. А в не верхнем,
  будем хранить только ту часть выпуклой оболочки, которая не является
  общей с родителем. Ну, типа, как раз синяя или красная часть. Тогда
  при продавливании точки вниз все проще: разбиваем текущую выпуклую
  оболочку (сначала корневую), объединяем за log с
  чилдами. Определяем, куда кидать точку -- влево или вправо. На одну
  часть забиваем. Так проходим вниз и добавляем вершинку. Заметим, что
  теперь уже не нужно хранить ничего в листах, так как два соседних
  листа однозначно определяются оболочкой в их паренте. Дальше строим
  оболочку и просеиваем вверх. Типа двух братьев берем, объединяем,
  отдаем паренту оболочку, себе оставляем только те части, которые не
  входят в парента.

  Итого мы умеем удалять и добавлять вершинки за log²n.


  Антон решил пояснить за то, как нужно делать мердж skip-листов. Лист
  мы держим сверху за вершину самого высокого уровня. Сплит: дали нам
  вершинку, нашли ее в самом нижнем уровне. Удаляем, обрезаем. Идем
  влево, пока не можем подняться наверх, поднимаемся, делаем вершинку
  терминальной, и так до верхнего уровня. Аналогично идем вправо и
  делаем ее первой. Мердж делается так же, про асимптотику думать не
  нужно.
